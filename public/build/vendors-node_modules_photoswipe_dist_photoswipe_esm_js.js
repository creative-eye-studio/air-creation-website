"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_photoswipe_dist_photoswipe_esm_js"],{

/***/ "./node_modules/photoswipe/dist/photoswipe.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/photoswipe/dist/photoswipe.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PhotoSwipe)
/* harmony export */ });
/*!
  * PhotoSwipe 5.3.6 - https://photoswipe.com
  * (c) 2023 Dmytro Semenov
  */
/** @typedef {import('../photoswipe.js').Point} Point */

/**
 * @template {keyof HTMLElementTagNameMap} T
 * @param {string} className
 * @param {T} tagName
 * @param {Node} [appendToEl]
 * @returns {HTMLElementTagNameMap[T]}
 */
function createElement(className, tagName, appendToEl) {
  const el = document.createElement(tagName);
  if (className) {
    el.className = className;
  }
  if (appendToEl) {
    appendToEl.appendChild(el);
  }
  return el;
}

/**
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */
function equalizePoints(p1, p2) {
  p1.x = p2.x;
  p1.y = p2.y;
  if (p2.id !== undefined) {
    p1.id = p2.id;
  }
  return p1;
}

/**
 * @param {Point} p
 */
function roundPoint(p) {
  p.x = Math.round(p.x);
  p.y = Math.round(p.y);
}

/**
 * Returns distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {number}
 */
function getDistanceBetween(p1, p2) {
  const x = Math.abs(p1.x - p2.x);
  const y = Math.abs(p1.y - p2.y);
  return Math.sqrt((x * x) + (y * y));
}

/**
 * Whether X and Y positions of points are equal
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {boolean}
 */
function pointsEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

/**
 * The float result between the min and max values.
 *
 * @param {number} val
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */
function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

/**
 * Get transform string
 *
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 * @returns {string}
 */
function toTransformString(x, y, scale) {
  let propValue = `translate3d(${x}px,${y || 0}px,0)`;

  if (scale !== undefined) {
    propValue += ` scale3d(${scale},${scale},1)`;
  }

  return propValue;
}

/**
 * Apply transform:translate(x, y) scale(scale) to element
 *
 * @param {HTMLElement} el
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 */
function setTransform(el, x, y, scale) {
  el.style.transform = toTransformString(x, y, scale);
}

const defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';

/**
 * Apply CSS transition to element
 *
 * @param {HTMLElement} el
 * @param {string} [prop] CSS property to animate
 * @param {number} [duration] in ms
 * @param {string} [ease] CSS easing function
 */
function setTransitionStyle(el, prop, duration, ease) {
  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions
  // out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions
  // in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions
  el.style.transition = prop
    ? `${prop} ${duration}ms ${ease || defaultCSSEasing}`
    : 'none';
}

/**
 * Apply width and height CSS properties to element
 *
 * @param {HTMLElement} el
 * @param {string | number} w
 * @param {string | number} h
 */
function setWidthHeight(el, w, h) {
  el.style.width = (typeof w === 'number') ? `${w}px` : w;
  el.style.height = (typeof h === 'number') ? `${h}px` : h;
}

/**
 * @param {HTMLElement} el
 */
function removeTransitionStyle(el) {
  setTransitionStyle(el);
}

/**
 * @param {HTMLImageElement} img
 * @returns {Promise<HTMLImageElement | void>}
 */
function decodeImage(img) {
  if ('decode' in img) {
    return img.decode().catch(() => {});
  }

  if (img.complete) {
    return Promise.resolve(img);
  }

  return new Promise((resolve, reject) => {
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}

/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */
/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */
const LOAD_STATE = {
  IDLE: 'idle',
  LOADING: 'loading',
  LOADED: 'loaded',
  ERROR: 'error',
};


/**
 * Check if click or keydown event was dispatched
 * with a special key or via mouse wheel.
 *
 * @param {MouseEvent | KeyboardEvent} e
 * @returns {boolean}
 */
function specialKeyUsed(e) {
  return ('button' in e && e.button === 1) || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
}

/**
 * Parse `gallery` or `children` options.
 *
 * @param {import('../photoswipe.js').ElementProvider} [option]
 * @param {string} [legacySelector]
 * @param {HTMLElement | Document} [parent]
 * @returns HTMLElement[]
 */
function getElementsFromOption(option, legacySelector, parent = document) {
  /** @type {HTMLElement[]} */
  let elements = [];

  if (option instanceof Element) {
    elements = [option];
  } else if (option instanceof NodeList || Array.isArray(option)) {
    elements = Array.from(option);
  } else {
    const selector = typeof option === 'string' ? option : legacySelector;
    if (selector) {
      elements = Array.from(parent.querySelectorAll(selector));
    }
  }

  return elements;
}

/**
 * Check if browser is Safari
 *
 * @returns {boolean}
 */
function isSafari() {
  return !!(navigator.vendor && navigator.vendor.match(/apple/i));
}

// Detect passive event listener support
let supportsPassive = false;
/* eslint-disable */
try {
  /* @ts-ignore */
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
    get: () => {
      supportsPassive = true;
    }
  }));
} catch (e) {}
/* eslint-enable */

/**
 * @typedef {Object} PoolItem
 * @prop {HTMLElement | Window | Document | undefined | null} target
 * @prop {string} type
 * @prop {EventListenerOrEventListenerObject} listener
 * @prop {boolean} [passive]
 */

class DOMEvents {
  constructor() {
    /**
     * @type {PoolItem[]}
     * @private
     */
    this._pool = [];
  }

  /**
   * Adds event listeners
   *
   * @param {PoolItem['target']} target
   * @param {PoolItem['type']} type Can be multiple, separated by space.
   * @param {PoolItem['listener']} listener
   * @param {PoolItem['passive']} [passive]
   */
  add(target, type, listener, passive) {
    this._toggleListener(target, type, listener, passive);
  }

  /**
   * Removes event listeners
   *
   * @param {PoolItem['target']} target
   * @param {PoolItem['type']} type
   * @param {PoolItem['listener']} listener
   * @param {PoolItem['passive']} [passive]
   */
  remove(target, type, listener, passive) {
    this._toggleListener(target, type, listener, passive, true);
  }

  /**
   * Removes all bound events
   */
  removeAll() {
    this._pool.forEach((poolItem) => {
      this._toggleListener(
        poolItem.target,
        poolItem.type,
        poolItem.listener,
        poolItem.passive,
        true,
        true
      );
    });
    this._pool = [];
  }

  /**
   * Adds or removes event
   *
   * @private
   * @param {PoolItem['target']} target
   * @param {PoolItem['type']} type
   * @param {PoolItem['listener']} listener
   * @param {PoolItem['passive']} [passive]
   * @param {boolean} [unbind] Whether the event should be added or removed
   * @param {boolean} [skipPool] Whether events pool should be skipped
   */
  _toggleListener(target, type, listener, passive, unbind, skipPool) {
    if (!target) {
      return;
    }

    const methodName = unbind ? 'removeEventListener' : 'addEventListener';
    const types = type.split(' ');
    types.forEach((eType) => {
      if (eType) {
        // Events pool is used to easily unbind all events when PhotoSwipe is closed,
        // so developer doesn't need to do this manually
        if (!skipPool) {
          if (unbind) {
            // Remove from the events pool
            this._pool = this._pool.filter((poolItem) => {
              return poolItem.type !== eType
                || poolItem.listener !== listener
                || poolItem.target !== target;
            });
          } else {
            // Add to the events pool
            this._pool.push({
              target,
              type: eType,
              listener,
              passive
            });
          }
        }

        // most PhotoSwipe events call preventDefault,
        // and we do not need browser to scroll the page
        const eventOptions = supportsPassive ? { passive: (passive || false) } : false;

        target[methodName](
          eType,
          listener,
          eventOptions
        );
      }
    });
  }
}

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/**
 * @param {PhotoSwipeOptions} options
 * @param {PhotoSwipeBase} pswp
 * @returns {Point}
 */
function getViewportSize(options, pswp) {
  if (options.getViewportSizeFn) {
    const newViewportSize = options.getViewportSizeFn(options, pswp);
    if (newViewportSize) {
      return newViewportSize;
    }
  }

  return {
    x: document.documentElement.clientWidth,

    // TODO: height on mobile is very incosistent due to toolbar
    // find a way to improve this
    //
    // document.documentElement.clientHeight - doesn't seem to work well
    y: window.innerHeight
  };
}

/**
 * Parses padding option.
 * Supported formats:
 *
 * // Object
 * padding: {
 *  top: 0,
 *  bottom: 0,
 *  left: 0,
 *  right: 0
 * }
 *
 * // A function that returns the object
 * paddingFn: (viewportSize, itemData, index) => {
 *  return {
 *    top: 0,
 *    bottom: 0,
 *    left: 0,
 *    right: 0
 *  };
 * }
 *
 * // Legacy variant
 * paddingLeft: 0,
 * paddingRight: 0,
 * paddingTop: 0,
 * paddingBottom: 0,
 *
 * @param {'left' | 'top' | 'bottom' | 'right'} prop
 * @param {PhotoSwipeOptions} options PhotoSwipe options
 * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
 * @param {SlideData} itemData Data about the slide
 * @param {number} index Slide index
 * @returns {number}
 */
function parsePaddingOption(prop, options, viewportSize, itemData, index) {
  let paddingValue = 0;

  if (options.paddingFn) {
    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
  } else if (options.padding) {
    paddingValue = options.padding[prop];
  } else {
    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);
    // @ts-expect-error
    if (options[legacyPropName]) {
      // @ts-expect-error
      paddingValue = options[legacyPropName];
    }
  }

  return Number(paddingValue) || 0;
}

/**
 * @param {PhotoSwipeOptions} options
 * @param {Point} viewportSize
 * @param {SlideData} itemData
 * @param {number} index
 * @returns {Point}
 */
function getPanAreaSize(options, viewportSize, itemData, index) {
  return {
    x: viewportSize.x
      - parsePaddingOption('left', options, viewportSize, itemData, index)
      - parsePaddingOption('right', options, viewportSize, itemData, index),
    y: viewportSize.y
      - parsePaddingOption('top', options, viewportSize, itemData, index)
      - parsePaddingOption('bottom', options, viewportSize, itemData, index)
  };
}

/** @typedef {import('./slide.js').default} Slide */
/** @typedef {Record<Axis, number>} Point */
/** @typedef {'x' | 'y'} Axis */

/**
 * Calculates minimum, maximum and initial (center) bounds of a slide
 */
class PanBounds {
  /**
   * @param {Slide} slide
   */
  constructor(slide) {
    this.slide = slide;
    this.currZoomLevel = 1;
    this.center = /** @type {Point} */ { x: 0, y: 0 };
    this.max = /** @type {Point} */ { x: 0, y: 0 };
    this.min = /** @type {Point} */ { x: 0, y: 0 };
  }

  /**
   * _getItemBounds
   *
   * @param {number} currZoomLevel
   */
  update(currZoomLevel) {
    this.currZoomLevel = currZoomLevel;

    if (!this.slide.width) {
      this.reset();
    } else {
      this._updateAxis('x');
      this._updateAxis('y');
      this.slide.pswp.dispatch('calcBounds', { slide: this.slide });
    }
  }

  /**
   * _calculateItemBoundsForAxis
   *
   * @param {Axis} axis
   */
  _updateAxis(axis) {
    const { pswp } = this.slide;
    const elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;
    const paddingProp = axis === 'x' ? 'left' : 'top';
    const padding = parsePaddingOption(
      paddingProp,
      pswp.options,
      pswp.viewportSize,
      this.slide.data,
      this.slide.index
    );

    const panAreaSize = this.slide.panAreaSize[axis];

    // Default position of element.
    // By default, it is center of viewport:
    this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding;

    // maximum pan position
    this.max[axis] = (elSize > panAreaSize)
      ? Math.round(panAreaSize - elSize) + padding
      : this.center[axis];

    // minimum pan position
    this.min[axis] = (elSize > panAreaSize)
      ? padding
      : this.center[axis];
  }

  // _getZeroBounds
  reset() {
    this.center.x = 0;
    this.center.y = 0;
    this.max.x = 0;
    this.max.y = 0;
    this.min.x = 0;
    this.min.y = 0;
  }

  /**
   * Correct pan position if it's beyond the bounds
   *
   * @param {Axis} axis x or y
   * @param {number} panOffset
   * @returns {number}
   */
  correctPan(axis, panOffset) { // checkPanBounds
    return clamp(panOffset, this.max[axis], this.min[axis]);
  }
}

const MAX_IMAGE_WIDTH = 4000;

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

/**
 * Calculates zoom levels for specific slide.
 * Depends on viewport size and image size.
 */
class ZoomLevel {
  /**
   * @param {PhotoSwipeOptions} options PhotoSwipe options
   * @param {SlideData} itemData Slide data
   * @param {number} index Slide index
   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet
   */
  constructor(options, itemData, index, pswp) {
    this.pswp = pswp;
    this.options = options;
    this.itemData = itemData;
    this.index = index;
    /** @type { Point | null } */
    this.panAreaSize = null;
    /** @type { Point | null } */
    this.elementSize = null;
    this.fit = 1;
    this.fill = 1;
    this.vFill = 1;
    this.initial = 1;
    this.secondary = 1;
    this.max = 1;
    this.min = 1;
  }

  /**
   * Calculate initial, secondary and maximum zoom level for the specified slide.
   *
   * It should be called when either image or viewport size changes.
   *
   * @param {number} maxWidth
   * @param {number} maxHeight
   * @param {Point} panAreaSize
   */
  update(maxWidth, maxHeight, panAreaSize) {
    /** @type {Point} */
    const elementSize = { x: maxWidth, y: maxHeight };
    this.elementSize = elementSize;
    this.panAreaSize = panAreaSize;

    const hRatio = panAreaSize.x / elementSize.x;
    const vRatio = panAreaSize.y / elementSize.y;

    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);

    // zoom.vFill defines zoom level of the image
    // when it has 100% of viewport vertical space (height)
    this.vFill = Math.min(1, vRatio);

    this.initial = this._getInitial();
    this.secondary = this._getSecondary();
    this.max = Math.max(
      this.initial,
      this.secondary,
      this._getMax()
    );

    this.min = Math.min(
      this.fit,
      this.initial,
      this.secondary
    );

    if (this.pswp) {
      this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });
    }
  }

  /**
   * Parses user-defined zoom option.
   *
   * @private
   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
   * @returns { number | undefined }
   */
  _parseZoomLevelOption(optionPrefix) {
    const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (
      optionPrefix + 'ZoomLevel'
    );
    const optionValue = this.options[optionName];

    if (!optionValue) {
      return;
    }

    if (typeof optionValue === 'function') {
      return optionValue(this);
    }

    if (optionValue === 'fill') {
      return this.fill;
    }

    if (optionValue === 'fit') {
      return this.fit;
    }

    return Number(optionValue);
  }

  /**
   * Get zoom level to which image will be zoomed after double-tap gesture,
   * or when user clicks on zoom icon,
   * or mouse-click on image itself.
   * If you return 1 image will be zoomed to its original size.
   *
   * @private
   * @return {number}
   */
  _getSecondary() {
    let currZoomLevel = this._parseZoomLevelOption('secondary');

    if (currZoomLevel) {
      return currZoomLevel;
    }

    // 3x of "fit" state, but not larger than original
    currZoomLevel = Math.min(1, this.fit * 3);

    if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
    }

    return currZoomLevel;
  }

  /**
   * Get initial image zoom level.
   *
   * @private
   * @return {number}
   */
  _getInitial() {
    return this._parseZoomLevelOption('initial') || this.fit;
  }

  /**
   * Maximum zoom level when user zooms
   * via zoom/pinch gesture,
   * via cmd/ctrl-wheel or via trackpad.
   *
   * @private
   * @return {number}
   */
  _getMax() {
    // max zoom level is x4 from "fit state",
    // used for zoom gesture and ctrl/trackpad zoom
    return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 * Renders and allows to control a single slide
 */
class Slide {
  /**
   * @param {SlideData} data
   * @param {number} index
   * @param {PhotoSwipe} pswp
   */
  constructor(data, index, pswp) {
    this.data = data;
    this.index = index;
    this.pswp = pswp;
    this.isActive = (index === pswp.currIndex);
    this.currentResolution = 0;
    /** @type {Point} */
    this.panAreaSize = { x: 0, y: 0 };
    /** @type {Point} */
    this.pan = { x: 0, y: 0 };

    this.isFirstSlide = (this.isActive && !pswp.opener.isOpen);

    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);

    this.pswp.dispatch('gettingData', {
      slide: this,
      data: this.data,
      index
    });

    this.content = this.pswp.contentLoader.getContentBySlide(this);
    this.container = createElement('pswp__zoom-wrap', 'div');
    /** @type {HTMLElement | null} */
    this.holderElement = null;

    this.currZoomLevel = 1;
    /** @type {number} */
    this.width = this.content.width;
    /** @type {number} */
    this.height = this.content.height;
    this.heavyAppended = false;
    this.bounds = new PanBounds(this);

    this.prevDisplayedWidth = -1;
    this.prevDisplayedHeight = -1;

    this.pswp.dispatch('slideInit', { slide: this });
  }

  /**
   * If this slide is active/current/visible
   *
   * @param {boolean} isActive
   */
  setIsActive(isActive) {
    if (isActive && !this.isActive) {
      // slide just became active
      this.activate();
    } else if (!isActive && this.isActive) {
      // slide just became non-active
      this.deactivate();
    }
  }

  /**
   * Appends slide content to DOM
   *
   * @param {HTMLElement} holderElement
   */
  append(holderElement) {
    this.holderElement = holderElement;

    this.container.style.transformOrigin = '0 0';

    // Slide appended to DOM
    if (!this.data) {
      return;
    }

    this.calculateSize();

    this.load();
    this.updateContentSize();
    this.appendHeavy();

    this.holderElement.appendChild(this.container);

    this.zoomAndPanToInitial();

    this.pswp.dispatch('firstZoomPan', { slide: this });

    this.applyCurrentZoomPan();

    this.pswp.dispatch('afterSetContent', { slide: this });

    if (this.isActive) {
      this.activate();
    }
  }

  load() {
    this.content.load(false);
    this.pswp.dispatch('slideLoad', { slide: this });
  }

  /**
   * Append "heavy" DOM elements
   *
   * This may depend on a type of slide,
   * but generally these are large images.
   */
  appendHeavy() {
    const { pswp } = this;
    const appendHeavyNearby = true; // todo

    // Avoid appending heavy elements during animations
    if (this.heavyAppended
        || !pswp.opener.isOpen
        || pswp.mainScroll.isShifted()
        || (!this.isActive && !appendHeavyNearby)) {
      return;
    }

    if (this.pswp.dispatch('appendHeavy', { slide: this }).defaultPrevented) {
      return;
    }

    this.heavyAppended = true;

    this.content.append();

    this.pswp.dispatch('appendHeavyContent', { slide: this });
  }

  /**
   * Triggered when this slide is active (selected).
   *
   * If it's part of opening/closing transition -
   * activate() will trigger after the transition is ended.
   */
  activate() {
    this.isActive = true;
    this.appendHeavy();
    this.content.activate();
    this.pswp.dispatch('slideActivate', { slide: this });
  }

  /**
   * Triggered when this slide becomes inactive.
   *
   * Slide can become inactive only after it was active.
   */
  deactivate() {
    this.isActive = false;
    this.content.deactivate();

    if (this.currZoomLevel !== this.zoomLevels.initial) {
      // allow filtering
      this.calculateSize();
    }

    // reset zoom level
    this.currentResolution = 0;
    this.zoomAndPanToInitial();
    this.applyCurrentZoomPan();
    this.updateContentSize();

    this.pswp.dispatch('slideDeactivate', { slide: this });
  }

  /**
   * The slide should destroy itself, it will never be used again.
   * (unbind all events and destroy internal components)
   */
  destroy() {
    this.content.hasSlide = false;
    this.content.remove();
    this.container.remove();
    this.pswp.dispatch('slideDestroy', { slide: this });
  }

  resize() {
    if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
      // Keep initial zoom level if it was before the resize,
      // as well as when this slide is not active

      // Reset position and scale to original state
      this.calculateSize();
      this.currentResolution = 0;
      this.zoomAndPanToInitial();
      this.applyCurrentZoomPan();
      this.updateContentSize();
    } else {
      // readjust pan position if it's beyond the bounds
      this.calculateSize();
      this.bounds.update(this.currZoomLevel);
      this.panTo(this.pan.x, this.pan.y);
    }
  }


  /**
   * Apply size to current slide content,
   * based on the current resolution and scale.
   *
   * @param {boolean} [force] if size should be updated even if dimensions weren't changed
   */
  updateContentSize(force) {
    // Use initial zoom level
    // if resolution is not defined (user didn't zoom yet)
    const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;

    if (!scaleMultiplier) {
      return;
    }

    const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
    const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;

    if (!this.sizeChanged(width, height) && !force) {
      return;
    }
    this.content.setDisplayedSize(width, height);
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  sizeChanged(width, height) {
    if (width !== this.prevDisplayedWidth
        || height !== this.prevDisplayedHeight) {
      this.prevDisplayedWidth = width;
      this.prevDisplayedHeight = height;
      return true;
    }

    return false;
  }

  /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */
  getPlaceholderElement() {
    return this.content.placeholder?.element;
  }

  /**
   * Zoom current slide image to...
   *
   * @param {number} destZoomLevel Destination zoom level.
   * @param {Point} [centerPoint]
   * Transform origin center point, or false if viewport center should be used.
   * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
   * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.
   */
  zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
    const { pswp } = this;
    if (!this.isZoomable()
        || pswp.mainScroll.isShifted()) {
      return;
    }

    pswp.dispatch('beforeZoomTo', {
      destZoomLevel, centerPoint, transitionDuration
    });

    // stop all pan and zoom transitions
    pswp.animations.stopAllPan();

    // if (!centerPoint) {
    //   centerPoint = pswp.getViewportCenterPoint();
    // }

    const prevZoomLevel = this.currZoomLevel;

    if (!ignoreBounds) {
      destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
    }

    // if (transitionDuration === undefined) {
    //   transitionDuration = this.pswp.options.zoomAnimationDuration;
    // }

    this.setZoomLevel(destZoomLevel);
    this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);
    this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);
    roundPoint(this.pan);

    const finishTransition = () => {
      this._setResolution(destZoomLevel);
      this.applyCurrentZoomPan();
    };

    if (!transitionDuration) {
      finishTransition();
    } else {
      pswp.animations.startTransition({
        isPan: true,
        name: 'zoomTo',
        target: this.container,
        transform: this.getCurrentTransform(),
        onComplete: finishTransition,
        duration: transitionDuration,
        easing: pswp.options.easing
      });
    }
  }

  /**
   * @param {Point} [centerPoint]
   */
  toggleZoom(centerPoint) {
    this.zoomTo(
      this.currZoomLevel === this.zoomLevels.initial
        ? this.zoomLevels.secondary : this.zoomLevels.initial,
      centerPoint,
      this.pswp.options.zoomAnimationDuration
    );
  }

  /**
   * Updates zoom level property and recalculates new pan bounds,
   * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
   *
   * @param {number} currZoomLevel
   */
  setZoomLevel(currZoomLevel) {
    this.currZoomLevel = currZoomLevel;
    this.bounds.update(this.currZoomLevel);
  }

  /**
   * Get pan position after zoom at a given `point`.
   *
   * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
   * pan bounds according to the new zoom level.
   *
   * @param {'x' | 'y'} axis
   * @param {Point} [point]
   * point based on which zoom is performed, usually refers to the current mouse position,
   * if false - viewport center will be used.
   * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.
   * @returns {number}
   */
  calculateZoomToPanOffset(axis, point, prevZoomLevel) {
    const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
    if (totalPanDistance === 0) {
      return this.bounds.center[axis];
    }

    if (!point) {
      point = this.pswp.getViewportCenterPoint();
    }

    if (!prevZoomLevel) {
      prevZoomLevel = this.zoomLevels.initial;
    }

    const zoomFactor = this.currZoomLevel / prevZoomLevel;
    return this.bounds.correctPan(
      axis,
      (this.pan[axis] - point[axis]) * zoomFactor + point[axis]
    );
  }

  /**
   * Apply pan and keep it within bounds.
   *
   * @param {number} panX
   * @param {number} panY
   */
  panTo(panX, panY) {
    this.pan.x = this.bounds.correctPan('x', panX);
    this.pan.y = this.bounds.correctPan('y', panY);
    this.applyCurrentZoomPan();
  }

  /**
   * If the slide in the current state can be panned by the user
   * @returns {boolean}
   */
  isPannable() {
    return Boolean(this.width) && (this.currZoomLevel > this.zoomLevels.fit);
  }

  /**
   * If the slide can be zoomed
   * @returns {boolean}
   */
  isZoomable() {
    return Boolean(this.width) && this.content.isZoomable();
  }

  /**
   * Apply transform and scale based on
   * the current pan position (this.pan) and zoom level (this.currZoomLevel)
   */
  applyCurrentZoomPan() {
    this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
    if (this === this.pswp.currSlide) {
      this.pswp.dispatch('zoomPanUpdate', { slide: this });
    }
  }

  zoomAndPanToInitial() {
    this.currZoomLevel = this.zoomLevels.initial;

    // pan according to the zoom level
    this.bounds.update(this.currZoomLevel);
    equalizePoints(this.pan, this.bounds.center);
    this.pswp.dispatch('initialZoomPan', { slide: this });
  }

  /**
   * Set translate and scale based on current resolution
   *
   * @param {number} x
   * @param {number} y
   * @param {number} zoom
   * @private
   */
  _applyZoomTransform(x, y, zoom) {
    zoom /= this.currentResolution || this.zoomLevels.initial;
    setTransform(this.container, x, y, zoom);
  }

  calculateSize() {
    const { pswp } = this;

    equalizePoints(
      this.panAreaSize,
      getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index)
    );

    this.zoomLevels.update(this.width, this.height, this.panAreaSize);

    pswp.dispatch('calcSlideSize', {
      slide: this
    });
  }

  /** @returns {string} */
  getCurrentTransform() {
    const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
    return toTransformString(this.pan.x, this.pan.y, scale);
  }

  /**
   * Set resolution and re-render the image.
   *
   * For example, if the real image size is 2000x1500,
   * and resolution is 0.5 - it will be rendered as 1000x750.
   *
   * Image with zoom level 2 and resolution 0.5 is
   * the same as image with zoom level 1 and resolution 1.
   *
   * Used to optimize animations and make
   * sure that browser renders image in the highest quality.
   * Also used by responsive images to load the correct one.
   *
   * @param {number} newResolution
   */
  _setResolution(newResolution) {
    if (newResolution === this.currentResolution) {
      return;
    }

    this.currentResolution = newResolution;
    this.updateContentSize();

    this.pswp.dispatch('resolutionChanged');
  }
}

/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */

const PAN_END_FRICTION = 0.35;
const VERTICAL_DRAG_FRICTION = 0.6;

// 1 corresponds to the third of viewport height
const MIN_RATIO_TO_CLOSE = 0.4;

// Minimum speed required to navigate
// to next or previous slide
const MIN_NEXT_SLIDE_SPEED = 0.5;

/**
 * @param {number} initialVelocity
 * @param {number} decelerationRate
 * @returns {number}
 */
function project(initialVelocity, decelerationRate) {
  return initialVelocity * decelerationRate / (1 - decelerationRate);
}

/**
 * Handles single pointer dragging
 */
class DragHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
    this.pswp = gestures.pswp;
    /** @type {Point} */
    this.startPan = { x: 0, y: 0 };
  }

  start() {
    if (this.pswp.currSlide) {
      equalizePoints(this.startPan, this.pswp.currSlide.pan);
    }
    this.pswp.animations.stopAll();
  }

  change() {
    const { p1, prevP1, dragAxis } = this.gestures;
    const { currSlide } = this.pswp;

    if (dragAxis === 'y'
        && this.pswp.options.closeOnVerticalDrag
        && (currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit)
        && !this.gestures.isMultitouch) {
      // Handle vertical drag to close
      const panY = currSlide.pan.y + (p1.y - prevP1.y);
      if (!this.pswp.dispatch('verticalDrag', { panY }).defaultPrevented) {
        this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);
        const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
        this.pswp.applyBgOpacity(bgOpacity);
        currSlide.applyCurrentZoomPan();
      }
    } else {
      const mainScrollChanged = this._panOrMoveMainScroll('x');
      if (!mainScrollChanged) {
        this._panOrMoveMainScroll('y');

        if (currSlide) {
          roundPoint(currSlide.pan);
          currSlide.applyCurrentZoomPan();
        }
      }
    }
  }

  end() {
    const { velocity } = this.gestures;
    const { mainScroll, currSlide } = this.pswp;
    let indexDiff = 0;

    this.pswp.animations.stopAll();

    // Handle main scroll if it's shifted
    if (mainScroll.isShifted()) {
      // Position of the main scroll relative to the viewport
      const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX();

      // Ratio between 0 and 1:
      // 0 - slide is not visible at all,
      // 0.5 - half of the slide is visible
      // 1 - slide is fully visible
      const currentSlideVisibilityRatio = (mainScrollShiftDiff / this.pswp.viewportSize.x);

      // Go next slide.
      //
      // - if velocity and its direction is matched,
      //   and we see at least tiny part of the next slide
      //
      // - or if we see less than 50% of the current slide
      //   and velocity is close to 0
      //
      if ((velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0)
          || (velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5)) {
        // Go to next slide
        indexDiff = 1;
        velocity.x = Math.min(velocity.x, 0);
      } else if ((velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0)
          || (velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5)) {
        // Go to prev slide
        indexDiff = -1;
        velocity.x = Math.max(velocity.x, 0);
      }

      mainScroll.moveIndexBy(indexDiff, true, velocity.x);
    }

    // Restore zoom level
    if ((currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max)
        || this.gestures.isMultitouch) {
      this.gestures.zoomLevels.correctZoomPan(true);
    } else {
      // we run two animations instead of one,
      // as each axis has own pan boundaries and thus different spring function
      // (correctZoomPan does not have this functionality,
      //  it animates all properties with single timing function)
      this._finishPanGestureForAxis('x');
      this._finishPanGestureForAxis('y');
    }
  }

  /**
   * @private
   * @param {'x' | 'y'} axis
   */
  _finishPanGestureForAxis(axis) {
    const { velocity } = this.gestures;
    const { currSlide } = this.pswp;

    if (!currSlide) {
      return;
    }

    const { pan, bounds } = currSlide;
    const panPos = pan[axis];
    const restoreBgOpacity = (this.pswp.bgOpacity < 1 && axis === 'y');

    // 0.995 means - scroll view loses 0.5% of its velocity per millisecond
    // Increasing this number will reduce travel distance
    const decelerationRate = 0.995; // 0.99

    // Pan position if there is no bounds
    const projectedPosition = panPos + project(velocity[axis], decelerationRate);

    if (restoreBgOpacity) {
      const vDragRatio = this._getVerticalDragRatio(panPos);
      const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);

      // If we are above and moving upwards,
      // or if we are below and moving downwards
      if ((vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE)
          || (vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE)) {
        this.pswp.close();
        return;
      }
    }

    // Pan position with corrected bounds
    const correctedPanPosition = bounds.correctPan(axis, projectedPosition);

    // Exit if pan position should not be changed
    // or if speed it too low
    if (panPos === correctedPanPosition) {
      return;
    }

    // Overshoot if the final position is out of pan bounds
    const dampingRatio = (correctedPanPosition === projectedPosition) ? 1 : 0.82;

    const initialBgOpacity = this.pswp.bgOpacity;
    const totalPanDist = correctedPanPosition - panPos;

    this.pswp.animations.startSpring({
      name: 'panGesture' + axis,
      isPan: true,
      start: panPos,
      end: correctedPanPosition,
      velocity: velocity[axis],
      dampingRatio,
      onUpdate: (pos) => {
        // Animate opacity of background relative to Y pan position of an image
        if (restoreBgOpacity && this.pswp.bgOpacity < 1) {
          // 0 - start of animation, 1 - end of animation
          const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;

          // We clamp opacity to keep it between 0 and 1.
          // As progress ratio can be larger than 1 due to overshoot,
          // and we do not want to bounce opacity.
          this.pswp.applyBgOpacity(clamp(
            initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio,
            0,
            1
          ));
        }

        pan[axis] = Math.floor(pos);
        currSlide.applyCurrentZoomPan();
      },
    });
  }

  /**
   * Update position of the main scroll,
   * or/and update pan position of the current slide.
   *
   * Should return true if it changes (or can change) main scroll.
   *
   * @private
   * @param {'x' | 'y'} axis
   * @returns {boolean}
   */
  _panOrMoveMainScroll(axis) {
    const { p1, dragAxis, prevP1, isMultitouch } = this.gestures;
    const { currSlide, mainScroll } = this.pswp;
    const delta = (p1[axis] - prevP1[axis]);
    const newMainScrollX = mainScroll.x + delta;

    if (!delta || !currSlide) {
      return false;
    }

    // Always move main scroll if image can not be panned
    if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {
      mainScroll.moveTo(newMainScrollX, true);
      return true; // changed main scroll
    }

    const { bounds } = currSlide;
    const newPan = currSlide.pan[axis] + delta;

    if (this.pswp.options.allowPanToNext
        && dragAxis === 'x'
        && axis === 'x'
        && !isMultitouch) {
      const currSlideMainScrollX = mainScroll.getCurrSlideX();

      // Position of the main scroll relative to the viewport
      const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;

      const isLeftToRight = delta > 0;
      const isRightToLeft = !isLeftToRight;

      if (newPan > bounds.min[axis] && isLeftToRight) {
        // Panning from left to right, beyond the left edge

        // Wether the image was at minimum pan position (or less)
        // when this drag gesture started.
        // Minimum pan position refers to the left edge of the image.
        const wasAtMinPanPosition = (bounds.min[axis] <= this.startPan[axis]);

        if (wasAtMinPanPosition) {
          mainScroll.moveTo(newMainScrollX, true);
          return true;
        } else {
          this._setPanWithFriction(axis, newPan);
          //currSlide.pan[axis] = newPan;
        }
      } else if (newPan < bounds.max[axis] && isRightToLeft) {
        // Paning from right to left, beyond the right edge

        // Maximum pan position refers to the right edge of the image.
        const wasAtMaxPanPosition = (this.startPan[axis] <= bounds.max[axis]);

        if (wasAtMaxPanPosition) {
          mainScroll.moveTo(newMainScrollX, true);
          return true;
        } else {
          this._setPanWithFriction(axis, newPan);
          //currSlide.pan[axis] = newPan;
        }
      } else {
        // If main scroll is shifted
        if (mainScrollShiftDiff !== 0) {
          // If main scroll is shifted right
          if (mainScrollShiftDiff > 0 /*&& isRightToLeft*/) {
            mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
            return true;
          } else if (mainScrollShiftDiff < 0 /*&& isLeftToRight*/) {
            // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)
            mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
            return true;
          }
        } else {
          // We are within pan bounds, so just pan
          this._setPanWithFriction(axis, newPan);
        }
      }
    } else {
      if (axis === 'y') {
        // Do not pan vertically if main scroll is shifted o
        if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
          this._setPanWithFriction(axis, newPan);
        }
      } else {
        this._setPanWithFriction(axis, newPan);
      }
    }

    return false;
  }

  // If we move above - the ratio is negative
  // If we move below the ratio is positive

  /**
   * Relation between pan Y position and third of viewport height.
   *
   * When we are at initial position (center bounds) - the ratio is 0,
   * if position is shifted upwards - the ratio is negative,
   * if position is shifted downwards - the ratio is positive.
   *
   * @private
   * @param {number} panY The current pan Y position.
   * @returns {number}
   */
  _getVerticalDragRatio(panY) {
    return (panY - (this.pswp.currSlide?.bounds.center.y ?? 0)) / (this.pswp.viewportSize.y / 3);
  }

  /**
   * Set pan position of the current slide.
   * Apply friction if the position is beyond the pan bounds,
   * or if custom friction is defined.
   *
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} potentialPan
   * @param {number} [customFriction] (0.1 - 1)
   */
  _setPanWithFriction(axis, potentialPan, customFriction) {
    const { currSlide } = this.pswp;

    if (!currSlide) {
      return;
    }

    const { pan, bounds } = currSlide;
    const correctedPan = bounds.correctPan(axis, potentialPan);
    // If we are out of pan bounds
    if (correctedPan !== potentialPan || customFriction) {
      const delta = Math.round(potentialPan - pan[axis]);
      pan[axis] += delta * (customFriction || PAN_END_FRICTION);
    } else {
      pan[axis] = potentialPan;
    }
  }
}

/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */

const UPPER_ZOOM_FRICTION = 0.05;
const LOWER_ZOOM_FRICTION = 0.15;


/**
 * Get center point between two points
 *
 * @param {Point} p
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */
function getZoomPointsCenter(p, p1, p2) {
  p.x = (p1.x + p2.x) / 2;
  p.y = (p1.y + p2.y) / 2;
  return p;
}

class ZoomHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
    /**
     * @private
     * @type {Point}
     */
    this._startPan = { x: 0, y: 0 };
    /**
     * @private
     * @type {Point}
     */
    this._startZoomPoint = { x: 0, y: 0 };
    /**
     * @private
     * @type {Point}
     */
    this._zoomPoint = { x: 0, y: 0 };
    /** @private */
    this._wasOverFitZoomLevel = false;
    /** @private */
    this._startZoomLevel = 1;
  }

  start() {
    const { currSlide } = this.gestures.pswp;
    if (currSlide) {
      this._startZoomLevel = currSlide.currZoomLevel;
      equalizePoints(this._startPan, currSlide.pan);
    }

    this.gestures.pswp.animations.stopAllPan();
    this._wasOverFitZoomLevel = false;
  }

  change() {
    const { p1, startP1, p2, startP2, pswp } = this.gestures;
    const { currSlide } = pswp;

    if (!currSlide) {
      return;
    }

    const minZoomLevel = currSlide.zoomLevels.min;
    const maxZoomLevel = currSlide.zoomLevels.max;

    if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
      return;
    }

    getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
    getZoomPointsCenter(this._zoomPoint, p1, p2);

    let currZoomLevel = (1 / getDistanceBetween(startP1, startP2))
                      * getDistanceBetween(p1, p2)
                      * this._startZoomLevel;

    // slightly over the zoom.fit
    if (currZoomLevel > currSlide.zoomLevels.initial + (currSlide.zoomLevels.initial / 15)) {
      this._wasOverFitZoomLevel = true;
    }

    if (currZoomLevel < minZoomLevel) {
      if (pswp.options.pinchToClose
          && !this._wasOverFitZoomLevel
          && this._startZoomLevel <= currSlide.zoomLevels.initial) {
        // fade out background if zooming out
        const bgOpacity = 1 - ((minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2));
        if (!pswp.dispatch('pinchClose', { bgOpacity }).defaultPrevented) {
          pswp.applyBgOpacity(bgOpacity);
        }
      } else {
        // Apply the friction if zoom level is below the min
        currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
      }
    } else if (currZoomLevel > maxZoomLevel) {
      // Apply the friction if zoom level is above the max
      currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
    }

    currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);
    currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);

    currSlide.setZoomLevel(currZoomLevel);
    currSlide.applyCurrentZoomPan();
  }

  end() {
    const { pswp } = this.gestures;
    const { currSlide } = pswp;
    if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial)
        && !this._wasOverFitZoomLevel
        && pswp.options.pinchToClose) {
      pswp.close();
    } else {
      this.correctZoomPan();
    }
  }

  /**
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} currZoomLevel
   * @returns {number}
   */
  _calculatePanForZoomLevel(axis, currZoomLevel) {
    const zoomFactor = currZoomLevel / this._startZoomLevel;
    return this._zoomPoint[axis]
            - ((this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor);
  }

  /**
   * Correct currZoomLevel and pan if they are
   * beyond minimum or maximum values.
   * With animation.
   *
   * @param {boolean} [ignoreGesture]
   * Wether gesture coordinates should be ignored when calculating destination pan position.
   */
  correctZoomPan(ignoreGesture) {
    const { pswp } = this.gestures;
    const { currSlide } = pswp;

    if (!currSlide?.isZoomable()) {
      return;
    }

    if (this._zoomPoint.x === 0) {
      ignoreGesture = true;
    }

    const prevZoomLevel = currSlide.currZoomLevel;

    /** @type {number} */
    let destinationZoomLevel;
    let currZoomLevelNeedsChange = true;

    if (prevZoomLevel < currSlide.zoomLevels.initial) {
      destinationZoomLevel = currSlide.zoomLevels.initial;
      // zoom to min
    } else if (prevZoomLevel > currSlide.zoomLevels.max) {
      destinationZoomLevel = currSlide.zoomLevels.max;
      // zoom to max
    } else {
      currZoomLevelNeedsChange = false;
      destinationZoomLevel = prevZoomLevel;
    }

    const initialBgOpacity = pswp.bgOpacity;
    const restoreBgOpacity = pswp.bgOpacity < 1;

    const initialPan = equalizePoints({ x: 0, y: 0 }, currSlide.pan);
    let destinationPan = equalizePoints({ x: 0, y: 0 }, initialPan);

    if (ignoreGesture) {
      this._zoomPoint.x = 0;
      this._zoomPoint.y = 0;
      this._startZoomPoint.x = 0;
      this._startZoomPoint.y = 0;
      this._startZoomLevel = prevZoomLevel;
      equalizePoints(this._startPan, initialPan);
    }

    if (currZoomLevelNeedsChange) {
      destinationPan = {
        x: this._calculatePanForZoomLevel('x', destinationZoomLevel),
        y: this._calculatePanForZoomLevel('y', destinationZoomLevel)
      };
    }

    // set zoom level, so pan bounds are updated according to it
    currSlide.setZoomLevel(destinationZoomLevel);

    destinationPan = {
      x: currSlide.bounds.correctPan('x', destinationPan.x),
      y: currSlide.bounds.correctPan('y', destinationPan.y)
    };

    // return zoom level and its bounds to initial
    currSlide.setZoomLevel(prevZoomLevel);

    const panNeedsChange = !pointsEqual(destinationPan, initialPan);

    if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
      // update resolution after gesture
      currSlide._setResolution(destinationZoomLevel);
      currSlide.applyCurrentZoomPan();

      // nothing to animate
      return;
    }

    pswp.animations.stopAllPan();

    pswp.animations.startSpring({
      isPan: true,
      start: 0,
      end: 1000,
      velocity: 0,
      dampingRatio: 1,
      naturalFrequency: 40,
      onUpdate: (now) => {
        now /= 1000; // 0 - start, 1 - end

        if (panNeedsChange || currZoomLevelNeedsChange) {
          if (panNeedsChange) {
            currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
            currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
          }

          if (currZoomLevelNeedsChange) {
            const newZoomLevel = prevZoomLevel
                        + (destinationZoomLevel - prevZoomLevel) * now;
            currSlide.setZoomLevel(newZoomLevel);
          }

          currSlide.applyCurrentZoomPan();
        }

        // Restore background opacity
        if (restoreBgOpacity && pswp.bgOpacity < 1) {
          // We clamp opacity to keep it between 0 and 1.
          // As progress ratio can be larger than 1 due to overshoot,
          // and we do not want to bounce opacity.
          pswp.applyBgOpacity(clamp(
            initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1
          ));
        }
      },
      onComplete: () => {
        // update resolution after transition ends
        currSlide._setResolution(destinationZoomLevel);
        currSlide.applyCurrentZoomPan();
      }
    });
  }
}

/**
 * @template T, P
 * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
 */

/** @typedef {import('./gestures.js').default} Gestures */
/** @typedef {import('../photoswipe.js').Point} Point */

/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */

/**
 * Whether the tap was performed on the main slide
 * (rather than controls or caption).
 *
 * @param {PointerEvent} event
 * @returns {boolean}
 */
function didTapOnMainContent(event) {
  return !!(/** @type {HTMLElement} */ (event.target).closest('.pswp__container'));
}

/**
 * Tap, double-tap handler.
 */
class TapHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  click(point, originalEvent) {
    const targetClassList = /** @type {HTMLElement} */ (originalEvent.target).classList;
    const isImageClick = targetClassList.contains('pswp__img');
    const isBackgroundClick = targetClassList.contains('pswp__item')
                              || targetClassList.contains('pswp__zoom-wrap');

    if (isImageClick) {
      this._doClickOrTapAction('imageClick', point, originalEvent);
    } else if (isBackgroundClick) {
      this._doClickOrTapAction('bgClick', point, originalEvent);
    }
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  tap(point, originalEvent) {
    if (didTapOnMainContent(originalEvent)) {
      this._doClickOrTapAction('tap', point, originalEvent);
    }
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  doubleTap(point, originalEvent) {
    if (didTapOnMainContent(originalEvent)) {
      this._doClickOrTapAction('doubleTap', point, originalEvent);
    }
  }

  /**
   * @private
   * @param {Actions} actionName
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  _doClickOrTapAction(actionName, point, originalEvent) {
    const { pswp } = this.gestures;
    const { currSlide } = pswp;
    const actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */ (actionName + 'Action');
    const optionValue = pswp.options[actionFullName];

    if (pswp.dispatch(actionFullName, { point, originalEvent }).defaultPrevented) {
      return;
    }

    if (typeof optionValue === 'function') {
      optionValue.call(pswp, point, originalEvent);
      return;
    }

    switch (optionValue) {
      case 'close':
      case 'next':
        pswp[optionValue]();
        break;
      case 'zoom':
        currSlide?.toggleZoom(point);
        break;
      case 'zoom-or-close':
        // by default click zooms current image,
        // if it can not be zoomed - gallery will be closed
        if (currSlide?.isZoomable()
            && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
          currSlide.toggleZoom(point);
        } else if (pswp.options.clickToCloseNonZoomable) {
          pswp.close();
        }
        break;
      case 'toggle-controls':
        this.gestures.pswp.element?.classList.toggle('pswp--ui-visible');
        // if (_controlsVisible) {
        //   _ui.hideControls();
        // } else {
        //   _ui.showControls();
        // }
        break;
    }
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').Point} Point */

// How far should user should drag
// until we can determine that the gesture is swipe and its direction
const AXIS_SWIPE_HYSTERISIS = 10;
//const PAN_END_FRICTION = 0.35;

const DOUBLE_TAP_DELAY = 300; // ms
const MIN_TAP_DISTANCE = 25; // px

/**
 * Gestures class bind touch, pointer or mouse events
 * and emits drag to drag-handler and zoom events zoom-handler.
 *
 * Drag and zoom events are emited in requestAnimationFrame,
 * and only when one of pointers was actually changed.
 */
class Gestures {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;

    /** @type {'x' | 'y' | null} */
    this.dragAxis = null;

    // point objects are defined once and reused
    // PhotoSwipe keeps track only of two pointers, others are ignored
    /** @type {Point} */
    this.p1 = { x: 0, y: 0 }; // the first pressed pointer
    /** @type {Point} */
    this.p2 = { x: 0, y: 0 }; // the second pressed pointer
    /** @type {Point} */
    this.prevP1 = { x: 0, y: 0 };
    /** @type {Point} */
    this.prevP2 = { x: 0, y: 0 };
    /** @type {Point} */
    this.startP1 = { x: 0, y: 0 };
    /** @type {Point} */
    this.startP2 = { x: 0, y: 0 };
    /** @type {Point} */
    this.velocity = { x: 0, y: 0 };

    /** @type {Point}
     * @private
     */
    this._lastStartP1 = { x: 0, y: 0 };
    /** @type {Point}
     * @private
     */
    this._intervalP1 = { x: 0, y: 0 };
    /** @private */
    this._numActivePoints = 0;
    /** @type {Point[]}
     * @private
     */
    this._ongoingPointers = [];
    /** @private */
    this._touchEventEnabled = 'ontouchstart' in window;
    /** @private */
    this._pointerEventEnabled = !!(window.PointerEvent);
    this.supportsTouch = this._touchEventEnabled
                          || (this._pointerEventEnabled && navigator.maxTouchPoints > 1);
    /** @private */
    this._numActivePoints = 0;
    /** @private */
    this._intervalTime = 0;
    /** @private */
    this._velocityCalculated = false;
    this.isMultitouch = false;
    this.isDragging = false;
    this.isZooming = false;
    /** @type {number | null} */
    this.raf = null;
    /** @type {NodeJS.Timeout | null}
     * @private
     */
    this._tapTimer = null;

    if (!this.supportsTouch) {
      // disable pan to next slide for non-touch devices
      pswp.options.allowPanToNext = false;
    }

    this.drag = new DragHandler(this);
    this.zoomLevels = new ZoomHandler(this);
    this.tapHandler = new TapHandler(this);

    pswp.on('bindEvents', () => {
      pswp.events.add(
        pswp.scrollWrap,
        'click',
        /** @type EventListener */(this._onClick.bind(this))
      );

      if (this._pointerEventEnabled) {
        this._bindEvents('pointer', 'down', 'up', 'cancel');
      } else if (this._touchEventEnabled) {
        this._bindEvents('touch', 'start', 'end', 'cancel');

        // In previous versions we also bound mouse event here,
        // in case device supports both touch and mouse events,
        // but newer versions of browsers now support PointerEvent.

        // on iOS10 if you bind touchmove/end after touchstart,
        // and you don't preventDefault touchstart (which PhotoSwipe does),
        // preventDefault will have no effect on touchmove and touchend.
        // Unless you bind it previously.
        if (pswp.scrollWrap) {
          pswp.scrollWrap.ontouchmove = () => {};
          pswp.scrollWrap.ontouchend = () => {};
        }
      } else {
        this._bindEvents('mouse', 'down', 'up');
      }
    });
  }

  /**
   * @private
   * @param {'mouse' | 'touch' | 'pointer'} pref
   * @param {'down' | 'start'} down
   * @param {'up' | 'end'} up
   * @param {'cancel'} [cancel]
   */
  _bindEvents(pref, down, up, cancel) {
    const { pswp } = this;
    const { events } = pswp;

    const cancelEvent = cancel ? pref + cancel : '';

    events.add(
      pswp.scrollWrap,
      pref + down,
      /** @type EventListener */(this.onPointerDown.bind(this))
    );
    events.add(window, pref + 'move', /** @type EventListener */(this.onPointerMove.bind(this)));
    events.add(window, pref + up, /** @type EventListener */(this.onPointerUp.bind(this)));
    if (cancelEvent) {
      events.add(
        pswp.scrollWrap,
        cancelEvent,
        /** @type EventListener */(this.onPointerUp.bind(this))
      );
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerDown(e) {
    // We do not call preventDefault for touch events
    // to allow browser to show native dialog on longpress
    // (the one that allows to save image or open it in new tab).
    //
    // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,
    // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.
    const isMousePointer = e.type === 'mousedown' || e.pointerType === 'mouse';

    // Allow dragging only via left mouse button.
    // http://www.quirksmode.org/js/events_properties.html
    // https://developer.mozilla.org/en-US/docs/Web/API/event.button
    if (isMousePointer && e.button > 0) {
      return;
    }

    const { pswp } = this;

    // if PhotoSwipe is opening or closing
    if (!pswp.opener.isOpen) {
      e.preventDefault();
      return;
    }

    if (pswp.dispatch('pointerDown', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (isMousePointer) {
      pswp.mouseDetected();

      // preventDefault mouse event to prevent
      // browser image drag feature
      this._preventPointerEventBehaviour(e);
    }

    pswp.animations.stopAll();

    this._updatePoints(e, 'down');

    if (this._numActivePoints === 1) {
      this.dragAxis = null;
      // we need to store initial point to determine the main axis,
      // drag is activated only after the axis is determined
      equalizePoints(this.startP1, this.p1);
    }

    if (this._numActivePoints > 1) {
      // Tap or double tap should not trigger if more than one pointer
      this._clearTapTimer();
      this.isMultitouch = true;
    } else {
      this.isMultitouch = false;
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerMove(e) {
    e.preventDefault(); // always preventDefault move event

    if (!this._numActivePoints) {
      return;
    }

    this._updatePoints(e, 'move');

    if (this.pswp.dispatch('pointerMove', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (this._numActivePoints === 1 && !this.isDragging) {
      if (!this.dragAxis) {
        this._calculateDragDirection();
      }

      // Drag axis was detected, emit drag.start
      if (this.dragAxis && !this.isDragging) {
        if (this.isZooming) {
          this.isZooming = false;
          this.zoomLevels.end();
        }

        this.isDragging = true;
        this._clearTapTimer(); // Tap can not trigger after drag

        // Adjust starting point
        this._updateStartPoints();
        this._intervalTime = Date.now();
        //this._startTime = this._intervalTime;
        this._velocityCalculated = false;
        equalizePoints(this._intervalP1, this.p1);
        this.velocity.x = 0;
        this.velocity.y = 0;
        this.drag.start();

        this._rafStopLoop();
        this._rafRenderLoop();
      }
    } else if (this._numActivePoints > 1 && !this.isZooming) {
      this._finishDrag();

      this.isZooming = true;

      // Adjust starting points
      this._updateStartPoints();

      this.zoomLevels.start();

      this._rafStopLoop();
      this._rafRenderLoop();
    }
  }

  /**
   * @private
   */
  _finishDrag() {
    if (this.isDragging) {
      this.isDragging = false;

      // Try to calculate velocity,
      // if it wasn't calculated yet in drag.change
      if (!this._velocityCalculated) {
        this._updateVelocity(true);
      }

      this.drag.end();
      this.dragAxis = null;
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerUp(e) {
    if (!this._numActivePoints) {
      return;
    }

    this._updatePoints(e, 'up');

    if (this.pswp.dispatch('pointerUp', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (this._numActivePoints === 0) {
      this._rafStopLoop();

      if (this.isDragging) {
        this._finishDrag();
      } else if (!this.isZooming && !this.isMultitouch) {
        //this.zoomLevels.correctZoomPan();
        this._finishTap(e);
      }
    }

    if (this._numActivePoints < 2 && this.isZooming) {
      this.isZooming = false;
      this.zoomLevels.end();

      if (this._numActivePoints === 1) {
        // Since we have 1 point left, we need to reinitiate drag
        this.dragAxis = null;
        this._updateStartPoints();
      }
    }
  }

  /**
   * @private
   */
  _rafRenderLoop() {
    if (this.isDragging || this.isZooming) {
      this._updateVelocity();

      if (this.isDragging) {
        // make sure that pointer moved since the last update
        if (!pointsEqual(this.p1, this.prevP1)) {
          this.drag.change();
        }
      } else /* if (this.isZooming) */ {
        if (!pointsEqual(this.p1, this.prevP1)
            || !pointsEqual(this.p2, this.prevP2)) {
          this.zoomLevels.change();
        }
      }

      this._updatePrevPoints();
      this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
    }
  }

  /**
   * Update velocity at 50ms interval
   *
   * @private
   * @param {boolean} [force]
   */
  _updateVelocity(force) {
    const time = Date.now();
    const duration = time - this._intervalTime;

    if (duration < 50 && !force) {
      return;
    }


    this.velocity.x = this._getVelocity('x', duration);
    this.velocity.y = this._getVelocity('y', duration);

    this._intervalTime = time;
    equalizePoints(this._intervalP1, this.p1);
    this._velocityCalculated = true;
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _finishTap(e) {
    const { mainScroll } = this.pswp;

    // Do not trigger tap events if main scroll is shifted
    if (mainScroll.isShifted()) {
      // restore main scroll position
      // (usually happens if stopped in the middle of animation)
      mainScroll.moveIndexBy(0, true);
      return;
    }

    // Do not trigger tap for touchcancel or pointercancel
    if (e.type.indexOf('cancel') > 0) {
      return;
    }

    // Trigger click instead of tap for mouse events
    if (e.type === 'mouseup' || e.pointerType === 'mouse') {
      this.tapHandler.click(this.startP1, e);
      return;
    }

    // Disable delay if there is no doubleTapAction
    const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0;

    // If tapTimer is defined - we tapped recently,
    // check if the current tap is close to the previous one,
    // if yes - trigger double tap
    if (this._tapTimer) {
      this._clearTapTimer();
      // Check if two taps were more or less on the same place
      if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
        this.tapHandler.doubleTap(this.startP1, e);
      }
    } else {
      equalizePoints(this._lastStartP1, this.startP1);
      this._tapTimer = setTimeout(() => {
        this.tapHandler.tap(this.startP1, e);
        this._clearTapTimer();
      }, tapDelay);
    }
  }

  /**
   * @private
   */
  _clearTapTimer() {
    if (this._tapTimer) {
      clearTimeout(this._tapTimer);
      this._tapTimer = null;
    }
  }

  /**
   * Get velocity for axis
   *
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} duration
   * @returns {number}
   */
  _getVelocity(axis, duration) {
    // displacement is like distance, but can be negative.
    const displacement = this.p1[axis] - this._intervalP1[axis];

    if (Math.abs(displacement) > 1 && duration > 5) {
      return displacement / duration;
    }

    return 0;
  }

  /**
   * @private
   */
  _rafStopLoop() {
    if (this.raf) {
      cancelAnimationFrame(this.raf);
      this.raf = null;
    }
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _preventPointerEventBehaviour(e) {
    // TODO find a way to disable e.preventDefault on some elements
    //      via event or some class or something
    e.preventDefault();
  }

  /**
   * Parses and normalizes points from the touch, mouse or pointer event.
   * Updates p1 and p2.
   *
   * @private
   * @param {PointerEvent | TouchEvent} e
   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
   */
  _updatePoints(e, pointerType) {
    if (this._pointerEventEnabled) {
      const pointerEvent = /** @type {PointerEvent} */ (e);
      // Try to find the current pointer in ongoing pointers by its ID
      const pointerIndex = this._ongoingPointers.findIndex((ongoingPointer) => {
        return ongoingPointer.id === pointerEvent.pointerId;
      });

      if (pointerType === 'up' && pointerIndex > -1) {
        // release the pointer - remove it from ongoing
        this._ongoingPointers.splice(pointerIndex, 1);
      } else if (pointerType === 'down' && pointerIndex === -1) {
        // add new pointer
        this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, { x: 0, y: 0 }));
      } else if (pointerIndex > -1) {
        // update existing pointer
        this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
      }

      this._numActivePoints = this._ongoingPointers.length;

      // update points that PhotoSwipe uses
      // to calculate position and scale
      if (this._numActivePoints > 0) {
        equalizePoints(this.p1, this._ongoingPointers[0]);
      }

      if (this._numActivePoints > 1) {
        equalizePoints(this.p2, this._ongoingPointers[1]);
      }
    } else {
      const touchEvent = /** @type {TouchEvent} */ (e);

      this._numActivePoints = 0;
      if (touchEvent.type.indexOf('touch') > -1) {
        // Touch Event
        // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
        if (touchEvent.touches && touchEvent.touches.length > 0) {
          this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
          this._numActivePoints++;
          if (touchEvent.touches.length > 1) {
            this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
            this._numActivePoints++;
          }
        }
      } else {
        // Mouse Event
        this._convertEventPosToPoint(/** @type {PointerEvent} */ (e), this.p1);
        if (pointerType === 'up') {
          // clear all points on mouseup
          this._numActivePoints = 0;
        } else {
          this._numActivePoints++;
        }
      }
    }
  }

  /** update points that were used during previous rAF tick
   * @private
   */
  _updatePrevPoints() {
    equalizePoints(this.prevP1, this.p1);
    equalizePoints(this.prevP2, this.p2);
  }

  /** update points at the start of gesture
   * @private
   */
  _updateStartPoints() {
    equalizePoints(this.startP1, this.p1);
    equalizePoints(this.startP2, this.p2);
    this._updatePrevPoints();
  }

  /** @private */
  _calculateDragDirection() {
    if (this.pswp.mainScroll.isShifted()) {
      // if main scroll position is shifted – direction is always horizontal
      this.dragAxis = 'x';
    } else {
      // calculate delta of the last touchmove tick
      const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);

      if (diff !== 0) {
        // check if pointer was shifted horizontally or vertically
        const axisToCheck = diff > 0 ? 'x' : 'y';

        if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
          this.dragAxis = axisToCheck;
        }
      }
    }
  }

  /**
   * Converts touch, pointer or mouse event
   * to PhotoSwipe point.
   *
   * @private
   * @param {Touch | PointerEvent} e
   * @param {Point} p
   * @returns {Point}
   */
  _convertEventPosToPoint(e, p) {
    p.x = e.pageX - this.pswp.offset.x;
    p.y = e.pageY - this.pswp.offset.y;

    if ('pointerId' in e) {
      p.id = e.pointerId;
    } else if (e.identifier !== undefined) {
      p.id = e.identifier;
    }

    return p;
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _onClick(e) {
    // Do not allow click event to pass through after drag
    if (this.pswp.mainScroll.isShifted()) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/slide.js').default} Slide */

/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */

const MAIN_SCROLL_END_FRICTION = 0.35;


// const MIN_SWIPE_TRANSITION_DURATION = 250;
// const MAX_SWIPE_TRABSITION_DURATION = 500;
// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;

/**
 * Handles movement of the main scrolling container
 * (for example, it repositions when user swipes left or right).
 *
 * Also stores its state.
 */
class MainScroll {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    this.x = 0;
    this.slideWidth = 0;
    /** @private */
    this._currPositionIndex = 0;
    /** @private */
    this._prevPositionIndex = 0;
    /** @private */
    this._containerShiftIndex = -1;

    /** @type {ItemHolder[]} */
    this.itemHolders = [];
  }

  /**
   * Position the scroller and slide containers
   * according to viewport size.
   *
   * @param {boolean} [resizeSlides] Whether slides content should resized
   */
  resize(resizeSlides) {
    const { pswp } = this;
    const newSlideWidth = Math.round(
      pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing
    );
    // Mobile browsers might trigger a resize event during a gesture.
    // (due to toolbar appearing or hiding).
    // Avoid re-adjusting main scroll position if width wasn't changed
    const slideWidthChanged = (newSlideWidth !== this.slideWidth);

    if (slideWidthChanged) {
      this.slideWidth = newSlideWidth;
      this.moveTo(this.getCurrSlideX());
    }

    this.itemHolders.forEach((itemHolder, index) => {
      if (slideWidthChanged) {
        setTransform(itemHolder.el, (index + this._containerShiftIndex)
                                    * this.slideWidth);
      }

      if (resizeSlides && itemHolder.slide) {
        itemHolder.slide.resize();
      }
    });
  }

  /**
   * Reset X position of the main scroller to zero
   */
  resetPosition() {
    // Position on the main scroller (offset)
    // it is independent from slide index
    this._currPositionIndex = 0;
    this._prevPositionIndex = 0;

    // This will force recalculation of size on next resize()
    this.slideWidth = 0;

    // _containerShiftIndex*viewportSize will give you amount of transform of the current slide
    this._containerShiftIndex = -1;
  }

  /**
   * Create and append array of three items
   * that hold data about slides in DOM
   */
  appendHolders() {
    this.itemHolders = [];

    // append our three slide holders -
    // previous, current, and next
    for (let i = 0; i < 3; i++) {
      const el = createElement('pswp__item', 'div', this.pswp.container);
      el.setAttribute('role', 'group');
      el.setAttribute('aria-roledescription', 'slide');
      el.setAttribute('aria-hidden', 'true');

      // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
      el.style.display = (i === 1) ? 'block' : 'none';

      this.itemHolders.push({
        el,
        //index: -1
      });
    }
  }

  /**
   * Whether the main scroll can be horizontally swiped to the next or previous slide.
   * @returns {boolean}
   */
  canBeSwiped() {
    return this.pswp.getNumItems() > 1;
  }

  /**
   * Move main scroll by X amount of slides.
   * For example:
   *   `-1` will move to the previous slide,
   *    `0` will reset the scroll position of the current slide,
   *    `3` will move three slides forward
   *
   * If loop option is enabled - index will be automatically looped too,
   * (for example `-1` will move to the last slide of the gallery).
   *
   * @param {number} diff
   * @param {boolean} [animate]
   * @param {number} [velocityX]
   * @returns {boolean} whether index was changed or not
   */
  moveIndexBy(diff, animate, velocityX) {
    const { pswp } = this;
    let newIndex = pswp.potentialIndex + diff;
    const numSlides = pswp.getNumItems();

    if (pswp.canLoop()) {
      newIndex = pswp.getLoopedIndex(newIndex);
      const distance = (diff + numSlides) % numSlides;
      if (distance <= numSlides / 2) {
        // go forward
        diff = distance;
      } else {
        // go backwards
        diff = distance - numSlides;
      }
    } else {
      if (newIndex < 0) {
        newIndex = 0;
      } else if (newIndex >= numSlides) {
        newIndex = numSlides - 1;
      }
      diff = newIndex - pswp.potentialIndex;
    }

    pswp.potentialIndex = newIndex;
    this._currPositionIndex -= diff;

    pswp.animations.stopMainScroll();

    const destinationX = this.getCurrSlideX();
    if (!animate) {
      this.moveTo(destinationX);
      this.updateCurrItem();
    } else {
      pswp.animations.startSpring({
        isMainScroll: true,
        start: this.x,
        end: destinationX,
        velocity: velocityX || 0,
        naturalFrequency: 30,
        dampingRatio: 1, //0.7,
        onUpdate: (x) => {
          this.moveTo(x);
        },
        onComplete: () => {
          this.updateCurrItem();
          pswp.appendHeavy();
        }
      });

      let currDiff = pswp.potentialIndex - pswp.currIndex;
      if (pswp.canLoop()) {
        const currDistance = (currDiff + numSlides) % numSlides;
        if (currDistance <= numSlides / 2) {
          // go forward
          currDiff = currDistance;
        } else {
          // go backwards
          currDiff = currDistance - numSlides;
        }
      }

      // Force-append new slides during transition
      // if difference between slides is more than 1
      if (Math.abs(currDiff) > 1) {
        this.updateCurrItem();
      }
    }

    return Boolean(diff);
  }

  /**
   * X position of the main scroll for the current slide
   * (ignores position during dragging)
   * @returns {number}
   */
  getCurrSlideX() {
    return this.slideWidth * this._currPositionIndex;
  }

  /**
   * Whether scroll position is shifted.
   * For example, it will return true if the scroll is being dragged or animated.
   * @returns {boolean}
   */
  isShifted() {
    return this.x !== this.getCurrSlideX();
  }

  /**
   * Update slides X positions and set their content
   */
  updateCurrItem() {
    const { pswp } = this;
    const positionDifference = this._prevPositionIndex - this._currPositionIndex;

    if (!positionDifference) {
      return;
    }

    this._prevPositionIndex = this._currPositionIndex;

    pswp.currIndex = pswp.potentialIndex;

    let diffAbs = Math.abs(positionDifference);
    /** @type {ItemHolder | undefined} */
    let tempHolder;

    if (diffAbs >= 3) {
      this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
      diffAbs = 3;
    }

    for (let i = 0; i < diffAbs; i++) {
      if (positionDifference > 0) {
        tempHolder = this.itemHolders.shift();
        if (tempHolder) {
          this.itemHolders[2] = tempHolder; // move first to last

          this._containerShiftIndex++;

          setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);

          pswp.setContent(tempHolder, (pswp.currIndex - diffAbs) + i + 2);
        }
      } else {
        tempHolder = this.itemHolders.pop();
        if (tempHolder) {
          this.itemHolders.unshift(tempHolder); // move last to first

          this._containerShiftIndex--;

          setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);

          pswp.setContent(tempHolder, (pswp.currIndex + diffAbs) - i - 2);
        }
      }
    }

    // Reset transfrom every 50ish navigations in one direction.
    //
    // Otherwise transform will keep growing indefinitely,
    // which might cause issues as browsers have a maximum transform limit.
    // I wasn't able to reach it, but just to be safe.
    // This should not cause noticable lag.
    if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
      this.resetPosition();
      this.resize();
    }

    // Pan transition might be running (and consntantly updating pan position)
    pswp.animations.stopAllPan();

    this.itemHolders.forEach((itemHolder, i) => {
      if (itemHolder.slide) {
        // Slide in the 2nd holder is always active
        itemHolder.slide.setIsActive(i === 1);
      }
    });

    pswp.currSlide = this.itemHolders[1]?.slide;
    pswp.contentLoader.updateLazy(positionDifference);

    if (pswp.currSlide) {
      pswp.currSlide.applyCurrentZoomPan();
    }

    pswp.dispatch('change');
  }

  /**
   * Move the X position of the main scroll container
   *
   * @param {number} x
   * @param {boolean} [dragging]
   */
  moveTo(x, dragging) {
    if (!this.pswp.canLoop() && dragging) {
      // Apply friction
      let newSlideIndexOffset = ((this.slideWidth * this._currPositionIndex) - x) / this.slideWidth;
      newSlideIndexOffset += this.pswp.currIndex;
      const delta = Math.round(x - this.x);

      if ((newSlideIndexOffset < 0 && delta > 0)
          || (newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0)) {
        x = this.x + (delta * MAIN_SCROLL_END_FRICTION);
      }
    }

    this.x = x;

    if (this.pswp.container) {
      setTransform(this.pswp.container, x);
    }

    this.pswp.dispatch('moveMainScroll', { x, dragging: dragging ?? false });
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */

/**
 * @template T
 * @typedef {import('./types.js').Methods<T>} Methods<T>
 */

const KeyboardKeyCodesMap = {
  Escape: 27,
  z: 90,
  ArrowLeft: 37,
  ArrowUp: 38,
  ArrowRight: 39,
  ArrowDown: 40,
  Tab: 9,
};

/**
 * @template {keyof KeyboardKeyCodesMap} T
 * @param {T} key
 * @param {boolean} isKeySupported
 * @returns {T | number | undefined}
 */
const getKeyboardEventKey = (key, isKeySupported) => {
  return isKeySupported ? key : KeyboardKeyCodesMap[key];
};

/**
 * - Manages keyboard shortcuts.
 * - Helps trap focus within photoswipe.
 */
class Keyboard {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    /** @private */
    this._wasFocused = false;

    pswp.on('bindEvents', () => {
      // Dialog was likely opened by keyboard if initial point is not defined
      if (!pswp.options.initialPointerPos) {
        // focus causes layout,
        // which causes lag during the animation,
        // that's why we delay it until the opener transition ends
        this._focusRoot();
      }

      pswp.events.add(document, 'focusin', /** @type EventListener */(this._onFocusIn.bind(this)));
      pswp.events.add(document, 'keydown', /** @type EventListener */(this._onKeyDown.bind(this)));
    });

    const lastActiveElement = /** @type {HTMLElement} */ (document.activeElement);
    pswp.on('destroy', () => {
      if (pswp.options.returnFocus
          && lastActiveElement
          && this._wasFocused) {
        lastActiveElement.focus();
      }
    });
  }

  /** @private */
  _focusRoot() {
    if (!this._wasFocused && this.pswp.element) {
      this.pswp.element.focus();
      this._wasFocused = true;
    }
  }

  /**
   * @private
   * @param {KeyboardEvent} e
   */
  _onKeyDown(e) {
    const { pswp } = this;

    if (pswp.dispatch('keydown', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (specialKeyUsed(e)) {
      // don't do anything if special key pressed
      // to prevent from overriding default browser actions
      // for example, in Chrome on Mac cmd+arrow-left returns to previous page
      return;
    }

    /** @type {Methods<PhotoSwipe> | undefined} */
    let keydownAction;
    /** @type {'x' | 'y' | undefined} */
    let axis;
    let isForward = false;
    const isKeySupported = 'key' in e;

    switch (isKeySupported ? e.key : e.keyCode) {
      case getKeyboardEventKey('Escape', isKeySupported):
        if (pswp.options.escKey) {
          keydownAction = 'close';
        }
        break;
      case getKeyboardEventKey('z', isKeySupported):
        keydownAction = 'toggleZoom';
        break;
      case getKeyboardEventKey('ArrowLeft', isKeySupported):
        axis = 'x';
        break;
      case getKeyboardEventKey('ArrowUp', isKeySupported):
        axis = 'y';
        break;
      case getKeyboardEventKey('ArrowRight', isKeySupported):
        axis = 'x';
        isForward = true;
        break;
      case getKeyboardEventKey('ArrowDown', isKeySupported):
        isForward = true;
        axis = 'y';
        break;
      case getKeyboardEventKey('Tab', isKeySupported):
        this._focusRoot();
        break;
    }

    // if left/right/top/bottom key
    if (axis) {
      // prevent page scroll
      e.preventDefault();

      const { currSlide } = pswp;

      if (pswp.options.arrowKeys
          && axis === 'x'
          && pswp.getNumItems() > 1) {
        keydownAction = isForward ? 'next' : 'prev';
      } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
        // up/down arrow keys pan the image vertically
        // left/right arrow keys pan horizontally.
        // Unless there is only one image,
        // or arrowKeys option is disabled
        currSlide.pan[axis] += isForward ? -80 : 80;
        currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
      }
    }

    if (keydownAction) {
      e.preventDefault();
      // @ts-ignore
      pswp[keydownAction]();
    }
  }

  /**
   * Trap focus inside photoswipe
   *
   * @private
   * @param {FocusEvent} e
   */
  _onFocusIn(e) {
    const { template } = this.pswp;
    if (template
        && document !== e.target
        && template !== e.target
        && !template.contains(/** @type {Node} */ (e.target))) {
      // focus root element
      template.focus();
    }
  }
}

const DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';

/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */

/** @typedef {Object} DefaultCssAnimationProps
 *
 * @prop {HTMLElement} target
 * @prop {number} [duration]
 * @prop {string} [easing]
 * @prop {string} [transform]
 * @prop {string} [opacity]
 * */

/** @typedef {SharedAnimationProps & DefaultCssAnimationProps} CssAnimationProps */

/**
 * Runs CSS transition.
 */
class CSSAnimation {
  /**
   * onComplete can be unpredictable, be careful about current state
   *
   * @param {CssAnimationProps} props
   */
  constructor(props) {
    this.props = props;
    const {
      target,
      onComplete,
      transform,
      onFinish = () => {},
      duration = 333,
      easing = DEFAULT_EASING,
    } = props;

    this.onFinish = onFinish;

    // support only transform and opacity
    const prop = transform ? 'transform' : 'opacity';
    const propValue = props[prop] ?? '';

    /** @private */
    this._target = target;
    /** @private */
    this._onComplete = onComplete;
    /** @private */
    this._finished = false;

    /** @private */
    this._onTransitionEnd = this._onTransitionEnd.bind(this);

    // Using timeout hack to make sure that animation
    // starts even if the animated property was changed recently,
    // otherwise transitionend might not fire or transition won't start.
    // https://drafts.csswg.org/css-transitions/#starting
    //
    // ¯\_(ツ)_/¯
    /** @private */
    this._helperTimeout = setTimeout(() => {
      setTransitionStyle(target, prop, duration, easing);
      this._helperTimeout = setTimeout(() => {
        target.addEventListener('transitionend', this._onTransitionEnd, false);
        target.addEventListener('transitioncancel', this._onTransitionEnd, false);

        // Safari occasionally does not emit transitionend event
        // if element property was modified during the transition,
        // which may be caused by resize or third party component,
        // using timeout as a safety fallback
        this._helperTimeout = setTimeout(() => {
          this._finalizeAnimation();
        }, duration + 500);
        target.style[prop] = propValue;
      }, 30); // Do not reduce this number
    }, 0);
  }

  /**
   * @private
   * @param {TransitionEvent} e
   */
  _onTransitionEnd(e) {
    if (e.target === this._target) {
      this._finalizeAnimation();
    }
  }

  /**
   * @private
   */
  _finalizeAnimation() {
    if (!this._finished) {
      this._finished = true;
      this.onFinish();
      if (this._onComplete) {
        this._onComplete();
      }
    }
  }

  // Destroy is called automatically onFinish
  destroy() {
    if (this._helperTimeout) {
      clearTimeout(this._helperTimeout);
    }
    removeTransitionStyle(this._target);
    this._target.removeEventListener('transitionend', this._onTransitionEnd, false);
    this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);
    if (!this._finished) {
      this._finalizeAnimation();
    }
  }
}

const DEFAULT_NATURAL_FREQUENCY = 12;
const DEFAULT_DAMPING_RATIO = 0.75;

/**
 * Spring easing helper
 */
class SpringEaser {
  /**
   * @param {number} initialVelocity Initial velocity, px per ms.
   *
   * @param {number} [dampingRatio]
   * Determines how bouncy animation will be.
   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
   * "overshoot" refers to part of animation that
   * goes beyond the final value.
   *
   * @param {number} [naturalFrequency]
   * Determines how fast animation will slow down.
   * The higher value - the stiffer the transition will be,
   * and the faster it will slow down.
   * Recommended value from 10 to 50
   */
  constructor(initialVelocity, dampingRatio, naturalFrequency) {
    this.velocity = initialVelocity * 1000; // convert to "pixels per second"

    // https://en.wikipedia.org/wiki/Damping_ratio
    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO;

    // https://en.wikipedia.org/wiki/Natural_frequency
    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;

    this._dampedFrequency = this._naturalFrequency;

    if (this._dampingRatio < 1) {
      this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
    }
  }

  /**
   * @param {number} deltaPosition Difference between current and end position of the animation
   * @param {number} deltaTime Frame duration in milliseconds
   *
   * @returns {number} Displacement, relative to the end position.
   */
  easeFrame(deltaPosition, deltaTime) {
    // Inspired by Apple Webkit and Android spring function implementation
    // https://en.wikipedia.org/wiki/Oscillation
    // https://en.wikipedia.org/wiki/Damping_ratio
    // we ignore mass (assume that it's 1kg)

    let displacement = 0;
    let coeff;

    deltaTime /= 1000;

    const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);

    if (this._dampingRatio === 1) {
      coeff = this.velocity + this._naturalFrequency * deltaPosition;

      displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;

      this.velocity = displacement
                        * (-this._naturalFrequency) + coeff
                        * naturalDumpingPow;
    } else if (this._dampingRatio < 1) {
      coeff = (1 / this._dampedFrequency)
                * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);

      const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
      const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);

      displacement = naturalDumpingPow
                       * (deltaPosition * dumpedFCos + coeff * dumpedFSin);

      this.velocity = displacement
                        * (-this._naturalFrequency)
                        * this._dampingRatio
                        + naturalDumpingPow
                        * (-this._dampedFrequency * deltaPosition * dumpedFSin
                        + this._dampedFrequency * coeff * dumpedFCos);
    }

    // Overdamped (>1) damping ratio is not supported

    return displacement;
  }
}

/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */

/**
 * @typedef {Object} DefaultSpringAnimationProps
 *
 * @prop {number} start
 * @prop {number} end
 * @prop {number} velocity
 * @prop {number} [dampingRatio]
 * @prop {number} [naturalFrequency]
 * @prop {(end: number) => void} onUpdate
 */

/** @typedef {SharedAnimationProps & DefaultSpringAnimationProps} SpringAnimationProps */

class SpringAnimation {
  /**
   * @param {SpringAnimationProps} props
   */
  constructor(props) {
    this.props = props;
    this._raf = 0;

    const {
      start,
      end,
      velocity,
      onUpdate,
      onComplete,
      onFinish = () => {},
      dampingRatio,
      naturalFrequency
    } = props;

    this.onFinish = onFinish;

    const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
    let prevTime = Date.now();
    let deltaPosition = start - end;

    const animationLoop = () => {
      if (this._raf) {
        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime);

        // Stop the animation if velocity is low and position is close to end
        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
          // Finalize the animation
          onUpdate(end);
          if (onComplete) {
            onComplete();
          }
          this.onFinish();
        } else {
          prevTime = Date.now();
          onUpdate(deltaPosition + end);
          this._raf = requestAnimationFrame(animationLoop);
        }
      }
    };

    this._raf = requestAnimationFrame(animationLoop);
  }

  // Destroy is called automatically onFinish
  destroy() {
    if (this._raf >= 0) {
      cancelAnimationFrame(this._raf);
    }
    this._raf = 0;
  }
}

/** @typedef {import('./css-animation.js').CssAnimationProps} CssAnimationProps */
/** @typedef {import('./spring-animation.js').SpringAnimationProps} SpringAnimationProps */

/** @typedef {Object} SharedAnimationProps
 * @prop {string} [name]
 * @prop {boolean} [isPan]
 * @prop {boolean} [isMainScroll]
 * @prop {VoidFunction} [onComplete]
 * @prop {VoidFunction} [onFinish]
 */

/** @typedef {SpringAnimation | CSSAnimation} Animation */
/** @typedef {SpringAnimationProps | CssAnimationProps} AnimationProps */

/**
 * Manages animations
 */
class Animations {
  constructor() {
    /** @type {Animation[]} */
    this.activeAnimations = [];
  }

  /**
   * @param {SpringAnimationProps} props
   */
  startSpring(props) {
    this._start(props, true);
  }

  /**
   * @param {CssAnimationProps} props
   */
  startTransition(props) {
    this._start(props);
  }

  /**
   * @private
   * @param {AnimationProps} props
   * @param {boolean} [isSpring]
   * @returns {Animation}
   */
  _start(props, isSpring) {
    const animation = isSpring
      ? new SpringAnimation(/** @type SpringAnimationProps */ (props))
      : new CSSAnimation(/** @type CssAnimationProps */ (props));

    this.activeAnimations.push(animation);
    animation.onFinish = () => this.stop(animation);

    return animation;
  }

  /**
   * @param {Animation} animation
   */
  stop(animation) {
    animation.destroy();
    const index = this.activeAnimations.indexOf(animation);
    if (index > -1) {
      this.activeAnimations.splice(index, 1);
    }
  }

  stopAll() { // _stopAllAnimations
    this.activeAnimations.forEach((animation) => {
      animation.destroy();
    });
    this.activeAnimations = [];
  }

  /**
   * Stop all pan or zoom transitions
   */
  stopAllPan() {
    this.activeAnimations = this.activeAnimations.filter((animation) => {
      if (animation.props.isPan) {
        animation.destroy();
        return false;
      }

      return true;
    });
  }

  stopMainScroll() {
    this.activeAnimations = this.activeAnimations.filter((animation) => {
      if (animation.props.isMainScroll) {
        animation.destroy();
        return false;
      }

      return true;
    });
  }

  /**
   * Returns true if main scroll transition is running
   */
  // isMainScrollRunning() {
  //   return this.activeAnimations.some((animation) => {
  //     return animation.props.isMainScroll;
  //   });
  // }

  /**
   * Returns true if any pan or zoom transition is running
   */
  isPanRunning() {
    return this.activeAnimations.some((animation) => {
      return animation.props.isPan;
    });
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */

/**
 * Handles scroll wheel.
 * Can pan and zoom current slide image.
 */
class ScrollWheel {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    pswp.events.add(pswp.element, 'wheel', /** @type EventListener */(this._onWheel.bind(this)));
  }

  /**
   * @private
   * @param {WheelEvent} e
   */
  _onWheel(e) {
    e.preventDefault();
    const { currSlide } = this.pswp;
    let { deltaX, deltaY } = e;

    if (!currSlide) {
      return;
    }

    if (this.pswp.dispatch('wheel', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (e.ctrlKey || this.pswp.options.wheelToZoom) {
      // zoom
      if (currSlide.isZoomable()) {
        let zoomFactor = -deltaY;
        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
          zoomFactor *= 0.05;
        } else {
          zoomFactor *= e.deltaMode ? 1 : 0.002;
        }
        zoomFactor = 2 ** zoomFactor;

        const destZoomLevel = currSlide.currZoomLevel * zoomFactor;
        currSlide.zoomTo(destZoomLevel, {
          x: e.clientX,
          y: e.clientY
        });
      }
    } else {
      // pan
      if (currSlide.isPannable()) {
        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
          // 18 - average line height
          deltaX *= 18;
          deltaY *= 18;
        }

        currSlide.panTo(
          currSlide.pan.x - deltaX,
          currSlide.pan.y - deltaY
        );
      }
    }
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 * @template T
 * @typedef {import('../types.js').Methods<T>} Methods<T>
 */

/**
 * @typedef {Object} UIElementMarkupProps
 * @prop {boolean} [isCustomSVG]
 * @prop {string} inner
 * @prop {string} [outlineID]
 * @prop {number | string} [size]
 */

/**
 * @typedef {Object} UIElementData
 * @prop {DefaultUIElements | string} [name]
 * @prop {string} [className]
 * @prop {UIElementMarkup} [html]
 * @prop {boolean} [isButton]
 * @prop {keyof HTMLElementTagNameMap} [tagName]
 * @prop {string} [title]
 * @prop {string} [ariaLabel]
 * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
 * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
 * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
 * @prop {number} [order]
 */

/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */

/** @typedef {string | UIElementMarkupProps} UIElementMarkup */

/**
 * @param {UIElementMarkup} [htmlData]
 * @returns {string}
 */
function addElementHTML(htmlData) {
  if (typeof htmlData === 'string') {
    // Allow developers to provide full svg,
    // For example:
    // <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">
    //   <path d="..." />
    //   <circle ... />
    // </svg>
    // Can also be any HTML string.
    return htmlData;
  }

  if (!htmlData || !htmlData.isCustomSVG) {
    return '';
  }

  const svgData = htmlData;
  let out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
  // replace all %d with size
  out = out.split('%d').join(/** @type {string} */ (svgData.size || 32));

  // Icons may contain outline/shadow,
  // to make it we "clone" base icon shape and add border to it.
  // Icon itself and border are styled via CSS.
  //
  // Property shadowID defines ID of element that should be cloned.
  if (svgData.outlineID) {
    out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
  }

  out += svgData.inner;

  out += '</svg>';

  return out;
}

class UIElement {
  /**
   * @param {PhotoSwipe} pswp
   * @param {UIElementData} data
   */
  constructor(pswp, data) {
    const name = data.name || data.className;
    let elementHTML = data.html;

    // @ts-expect-error lookup only by `data.name` maybe?
    if (pswp.options[name] === false) {
      // exit if element is disabled from options
      return;
    }

    // Allow to override SVG icons from options
    // @ts-expect-error lookup only by `data.name` maybe?
    if (typeof pswp.options[name + 'SVG'] === 'string') {
      // arrowPrevSVG
      // arrowNextSVG
      // closeSVG
      // zoomSVG
      // @ts-expect-error lookup only by `data.name` maybe?
      elementHTML = pswp.options[name + 'SVG'];
    }

    pswp.dispatch('uiElementCreate', { data });

    let className = '';
    if (data.isButton) {
      className += 'pswp__button ';
      className += (data.className || `pswp__button--${data.name}`);
    } else {
      className += (data.className || `pswp__${data.name}`);
    }

    let tagName = data.isButton ? (data.tagName || 'button') : (data.tagName || 'div');
    tagName = /** @type {keyof HTMLElementTagNameMap} */ (tagName.toLowerCase());
    /** @type {HTMLElement} */
    const element = createElement(className, tagName);

    if (data.isButton) {
      if (tagName === 'button') {
        /** @type {HTMLButtonElement} */ (element).type = 'button';
      }

      let { title } = data;
      const { ariaLabel } = data;

      // @ts-expect-error lookup only by `data.name` maybe?
      if (typeof pswp.options[name + 'Title'] === 'string') {
        // @ts-expect-error lookup only by `data.name` maybe?
        title = pswp.options[name + 'Title'];
      }

      if (title) {
        element.title = title;
      }

      const ariaText = ariaLabel || title;
      if (ariaText) {
        element.setAttribute('aria-label', ariaText);
      }
    }

    element.innerHTML = addElementHTML(elementHTML);

    if (data.onInit) {
      data.onInit(element, pswp);
    }

    if (data.onClick) {
      element.onclick = (e) => {
        if (typeof data.onClick === 'string') {
          // @ts-ignore
          pswp[data.onClick]();
        } else if (typeof data.onClick === 'function') {
          data.onClick(e, element, pswp);
        }
      };
    }

    // Top bar is default position
    const appendTo = data.appendTo || 'bar';
    /** @type {HTMLElement | undefined} root element by default */
    let container = pswp.element;
    if (appendTo === 'bar') {
      if (!pswp.topBar) {
        pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);
      }
      container = pswp.topBar;
    } else {
      // element outside of top bar gets a secondary class
      // that makes element fade out on close
      element.classList.add('pswp__hide-on-close');

      if (appendTo === 'wrapper') {
        container = pswp.scrollWrap;
      }
    }

    container?.appendChild(pswp.applyFilters('uiElement', element, data));
  }
}

/*
  Backward and forward arrow buttons
 */

/** @typedef {import('./ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 *
 * @param {HTMLElement} element
 * @param {PhotoSwipe} pswp
 * @param {boolean} [isNextButton]
 */
function initArrowButton(element, pswp, isNextButton) {
  element.classList.add('pswp__button--arrow');
  // TODO: this should point to a unique id for this instance
  element.setAttribute('aria-controls', 'pswp__items');
  pswp.on('change', () => {
    if (!pswp.options.loop) {
      if (isNextButton) {
        /** @type {HTMLButtonElement} */
        (element).disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
      } else {
        /** @type {HTMLButtonElement} */
        (element).disabled = !(pswp.currIndex > 0);
      }
    }
  });
}

/** @type {UIElementData} */
const arrowPrev = {
  name: 'arrowPrev',
  className: 'pswp__button--arrow--prev',
  title: 'Previous',
  order: 10,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'prev',
  onInit: initArrowButton
};

/** @type {UIElementData} */
const arrowNext = {
  name: 'arrowNext',
  className: 'pswp__button--arrow--next',
  title: 'Next',
  order: 11,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<use xlink:href="#pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'next',
  onInit: (el, pswp) => {
    initArrowButton(el, pswp, true);
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const closeButton = {
  name: 'close',
  title: 'Close',
  order: 20,
  isButton: true,
  html: {
    isCustomSVG: true,
    inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
    outlineID: 'pswp__icn-close'
  },
  onClick: 'close'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const zoomButton = {
  name: 'zoom',
  title: 'Zoom',
  order: 10,
  isButton: true,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/>'
          + '<path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/>'
          + '<path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
    outlineID: 'pswp__icn-zoom'
  },
  onClick: 'toggleZoom'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const loadingIndicator = {
  name: 'preloader',
  appendTo: 'bar',
  order: 7,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
    outlineID: 'pswp__icn-loading'
  },
  onInit: (indicatorElement, pswp) => {
    /** @type {boolean | undefined} */
    let isVisible;
    /** @type {NodeJS.Timeout | null} */
    let delayTimeout = null;

    /**
     * @param {string} className
     * @param {boolean} add
     */
    const toggleIndicatorClass = (className, add) => {
      indicatorElement.classList.toggle('pswp__preloader--' + className, add);
    };

    /**
     * @param {boolean} visible
     */
    const setIndicatorVisibility = (visible) => {
      if (isVisible !== visible) {
        isVisible = visible;
        toggleIndicatorClass('active', visible);
      }
    };

    const updatePreloaderVisibility = () => {
      if (!pswp.currSlide?.content.isLoading()) {
        setIndicatorVisibility(false);
        if (delayTimeout) {
          clearTimeout(delayTimeout);
          delayTimeout = null;
        }
        return;
      }

      if (!delayTimeout) {
        // display loading indicator with delay
        delayTimeout = setTimeout(() => {
          setIndicatorVisibility(Boolean(pswp.currSlide?.content.isLoading()));
          delayTimeout = null;
        }, pswp.options.preloaderDelay);
      }
    };

    pswp.on('change', updatePreloaderVisibility);

    pswp.on('loadComplete', (e) => {
      if (pswp.currSlide === e.slide) {
        updatePreloaderVisibility();
      }
    });

    // expose the method
    if (pswp.ui) {
      pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
    }
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const counterIndicator = {
  name: 'counter',
  order: 5,
  onInit: (counterElement, pswp) => {
    pswp.on('change', () => {
      counterElement.innerText = (pswp.currIndex + 1)
                                  + pswp.options.indexIndicatorSep
                                  + pswp.getNumItems();
    });
  }
};

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./ui-element.js').UIElementData} UIElementData */

/**
 * Set special class on element when image is zoomed.
 *
 * By default, it is used to adjust
 * zoom icon and zoom cursor via CSS.
 *
 * @param {HTMLElement} el
 * @param {boolean} isZoomedIn
 */
function setZoomedIn(el, isZoomedIn) {
  el.classList.toggle('pswp--zoomed-in', isZoomedIn);
}

class UI {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    this.isRegistered = false;
    /** @type {UIElementData[]} */
    this.uiElementsData = [];
    /** @type {(UIElement | UIElementData)[]} */
    this.items = [];
    /** @type {() => void} */
    this.updatePreloaderVisibility = () => {};

    /**
     * @private
     * @type {number | undefined}
     */
    this._lastUpdatedZoomLevel = undefined;
  }

  init() {
    const { pswp } = this;
    this.isRegistered = false;
    this.uiElementsData = [
      closeButton,
      arrowPrev,
      arrowNext,
      zoomButton,
      loadingIndicator,
      counterIndicator
    ];

    pswp.dispatch('uiRegister');

    // sort by order
    this.uiElementsData.sort((a, b) => {
      // default order is 0
      return (a.order || 0) - (b.order || 0);
    });

    this.items = [];

    this.isRegistered = true;
    this.uiElementsData.forEach((uiElementData) => {
      this.registerElement(uiElementData);
    });

    pswp.on('change', () => {
      pswp.element?.classList.toggle('pswp--one-slide', pswp.getNumItems() === 1);
    });

    pswp.on('zoomPanUpdate', () => this._onZoomPanUpdate());
  }

  /**
   * @param {UIElementData} elementData
   */
  registerElement(elementData) {
    if (this.isRegistered) {
      this.items.push(
        new UIElement(this.pswp, elementData)
      );
    } else {
      this.uiElementsData.push(elementData);
    }
  }

  /**
   * Fired each time zoom or pan position is changed.
   * Update classes that control visibility of zoom button and cursor icon.
   *
   * @private
   */
  _onZoomPanUpdate() {
    const { template, currSlide, options } = this.pswp;

    if (this.pswp.opener.isClosing || !template || !currSlide) {
      return;
    }

    let { currZoomLevel } = currSlide;

    // if not open yet - check against initial zoom level
    if (!this.pswp.opener.isOpen) {
      currZoomLevel = currSlide.zoomLevels.initial;
    }

    if (currZoomLevel === this._lastUpdatedZoomLevel) {
      return;
    }
    this._lastUpdatedZoomLevel = currZoomLevel;

    const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;

    // Initial and secondary zoom levels are almost equal
    if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
      // disable zoom
      setZoomedIn(template, false);
      template.classList.remove('pswp--zoom-allowed');
      return;
    }

    template.classList.add('pswp--zoom-allowed');

    const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial
      ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;

    setZoomedIn(template, potentialZoomLevel <= currZoomLevel);

    if (options.imageClickAction === 'zoom'
        || options.imageClickAction === 'zoom-or-close') {
      template.classList.add('pswp--click-to-zoom');
    }
  }
}

/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */

/**
 * @param {HTMLElement} el
 * @returns Bounds
 */
function getBoundsByElement(el) {
  const thumbAreaRect = el.getBoundingClientRect();
  return {
    x: thumbAreaRect.left,
    y: thumbAreaRect.top,
    w: thumbAreaRect.width
  };
}

/**
 * @param {HTMLElement} el
 * @param {number} imageWidth
 * @param {number} imageHeight
 * @returns Bounds
 */
function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
  const thumbAreaRect = el.getBoundingClientRect();

  // fill image into the area
  // (do they same as object-fit:cover does to retrieve coordinates)
  const hRatio = thumbAreaRect.width / imageWidth;
  const vRatio = thumbAreaRect.height / imageHeight;
  const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;

  const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
  const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;

  /**
   * Coordinates of the image,
   * as if it was not cropped,
   * height is calculated automatically
   *
   * @type {Bounds}
   */
  const bounds = {
    x: thumbAreaRect.left + offsetX,
    y: thumbAreaRect.top + offsetY,
    w: imageWidth * fillZoomLevel
  };

  // Coordinates of inner crop area
  // relative to the image
  bounds.innerRect = {
    w: thumbAreaRect.width,
    h: thumbAreaRect.height,
    x: offsetX,
    y: offsetY
  };

  return bounds;
}

/**
 * Get dimensions of thumbnail image
 * (click on which opens photoswipe or closes photoswipe to)
 *
 * @param {number} index
 * @param {SlideData} itemData
 * @param {PhotoSwipe} instance PhotoSwipe instance
 * @returns {Bounds | undefined}
 */
function getThumbBounds(index, itemData, instance) {
  // legacy event, before filters were introduced
  const event = instance.dispatch('thumbBounds', {
    index,
    itemData,
    instance
  });
  // @ts-expect-error
  if (event.thumbBounds) {
    // @ts-expect-error
    return event.thumbBounds;
  }

  const { element } = itemData;
  /** @type {Bounds | undefined} */
  let thumbBounds;
  /** @type {HTMLElement | null | undefined} */
  let thumbnail;

  if (element && instance.options.thumbSelector !== false) {
    const thumbSelector = instance.options.thumbSelector || 'img';
    thumbnail = element.matches(thumbSelector)
      ? element : /** @type {HTMLElement | null} */ (element.querySelector(thumbSelector));
  }

  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);

  if (thumbnail) {
    if (!itemData.thumbCropped) {
      thumbBounds = getBoundsByElement(thumbnail);
    } else {
      thumbBounds = getCroppedBoundsByElement(
        thumbnail,
        itemData.width || itemData.w || 0,
        itemData.height || itemData.h || 0
      );
    }
  }

  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);
}

/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../photoswipe.js').DataSource} DataSource */
/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../slide/content.js').default} ContentDefault */
/** @typedef {import('../slide/slide.js').default} Slide */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */
/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */
/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

/**
 * Allow adding an arbitrary props to the Content
 * https://photoswipe.com/custom-content/#using-webp-image-format
 * @typedef {ContentDefault & Record<string, any>} Content
 */
/** @typedef {{ x?: number; y?: number }} Point */

/**
 * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
 *
 *
 * https://photoswipe.com/adding-ui-elements/
 *
 * @prop {undefined} uiRegister
 * @prop {{ data: UIElementData }} uiElementCreate
 *
 *
 * https://photoswipe.com/events/#initialization-events
 *
 * @prop {undefined} beforeOpen
 * @prop {undefined} firstUpdate
 * @prop {undefined} initialLayout
 * @prop {undefined} change
 * @prop {undefined} afterInit
 * @prop {undefined} bindEvents
 *
 *
 * https://photoswipe.com/events/#opening-or-closing-transition-events
 *
 * @prop {undefined} openingAnimationStart
 * @prop {undefined} openingAnimationEnd
 * @prop {undefined} closingAnimationStart
 * @prop {undefined} closingAnimationEnd
 *
 *
 * https://photoswipe.com/events/#closing-events
 *
 * @prop {undefined} close
 * @prop {undefined} destroy
 *
 *
 * https://photoswipe.com/events/#pointer-and-gesture-events
 *
 * @prop {{ originalEvent: PointerEvent }} pointerDown
 * @prop {{ originalEvent: PointerEvent }} pointerMove
 * @prop {{ originalEvent: PointerEvent }} pointerUp
 * @prop {{ bgOpacity: number }} pinchClose can be default prevented
 * @prop {{ panY: number }} verticalDrag can be default prevented
 *
 *
 * https://photoswipe.com/events/#slide-content-events
 *
 * @prop {{ content: Content }} contentInit
 * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
 * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
 * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
 * @prop {{ content: Content; slide: Slide }} loadError
 * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
 * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
 * @prop {{ content: Content }} contentLazyLoad can be default prevented
 * @prop {{ content: Content }} contentAppend can be default prevented
 * @prop {{ content: Content }} contentActivate can be default prevented
 * @prop {{ content: Content }} contentDeactivate can be default prevented
 * @prop {{ content: Content }} contentRemove can be default prevented
 * @prop {{ content: Content }} contentDestroy can be default prevented
 *
 *
 * undocumented
 *
 * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
 *
 * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
 * @prop {{ x: number; dragging: boolean }} moveMainScroll
 * @prop {{ slide: Slide }} firstZoomPan
 * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData
 * @prop {undefined} beforeResize
 * @prop {undefined} resize
 * @prop {undefined} viewportSize
 * @prop {undefined} updateScrollOffset
 * @prop {{ slide: Slide }} slideInit
 * @prop {{ slide: Slide }} afterSetContent
 * @prop {{ slide: Slide }} slideLoad
 * @prop {{ slide: Slide }} appendHeavy can be default prevented
 * @prop {{ slide: Slide }} appendHeavyContent
 * @prop {{ slide: Slide }} slideActivate
 * @prop {{ slide: Slide }} slideDeactivate
 * @prop {{ slide: Slide }} slideDestroy
 * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo
 * @prop {{ slide: Slide }} zoomPanUpdate
 * @prop {{ slide: Slide }} initialZoomPan
 * @prop {{ slide: Slide }} calcSlideSize
 * @prop {undefined} resolutionChanged
 * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
 * @prop {{ content: Content }} contentAppendImage can be default prevented
 * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
 * @prop {undefined} lazyLoad
 * @prop {{ slide: Slide }} calcBounds
 * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
 *
 *
 * legacy
 *
 * @prop {undefined} init
 * @prop {undefined} initialZoomIn
 * @prop {undefined} initialZoomOut
 * @prop {undefined} initialZoomInEnd
 * @prop {undefined} initialZoomOutEnd
 * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems
 * @prop {{ itemData: SlideData; index: number }} itemData
 * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
 */

/**
 * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
 *
 * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems
 * Modify the total amount of slides. Example on Data sources page.
 * https://photoswipe.com/filters/#numitems
 *
 * @prop {(itemData: SlideData, index: number) => SlideData} itemData
 * Modify slide item data. Example on Data sources page.
 * https://photoswipe.com/filters/#itemdata
 *
 * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
 * Modify item data when it's parsed from DOM element. Example on Data sources page.
 * https://photoswipe.com/filters/#domitemdata
 *
 * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
 * Modify clicked gallery item index.
 * https://photoswipe.com/filters/#clickedindex
 *
 * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
 * Modify placeholder image source.
 * https://photoswipe.com/filters/#placeholdersrc
 *
 * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
 * Modify if the content is currently loading.
 * https://photoswipe.com/filters/#iscontentloading
 *
 * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
 * Modify if the content can be zoomed.
 * https://photoswipe.com/filters/#iscontentzoomable
 *
 * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
 * Modify if the placeholder should be used for the content.
 * https://photoswipe.com/filters/#usecontentplaceholder
 *
 * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
 * Modify if the placeholder should be kept after the content is loaded.
 * https://photoswipe.com/filters/#iskeepingplaceholder
 *
 *
 * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
 * Modify an element when the content has error state (for example, if image cannot be loaded).
 * https://photoswipe.com/filters/#contenterrorelement
 *
 * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
 * Modify a UI element that's being created.
 * https://photoswipe.com/filters/#uielement
 *
 * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl
 * Modify the thubmnail element from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbel
 *
 * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds
 * Modify the thubmnail bounds from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbbounds
 *
 * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
 *
 */

/**
 * @template {keyof PhotoSwipeFiltersMap} T
 * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {(event: AugmentedEvent<T>) => void} EventCallback
 */

/**
 * Base PhotoSwipe event object
 *
 * @template {keyof PhotoSwipeEventsMap} T
 */
class PhotoSwipeEvent {
  /**
   * @param {T} type
   * @param {PhotoSwipeEventsMap[T]} [details]
   */
  constructor(type, details) {
    this.type = type;
    this.defaultPrevented = false;
    if (details) {
      Object.assign(this, details);
    }
  }

  preventDefault() {
    this.defaultPrevented = true;
  }
}

/**
 * PhotoSwipe base class that can listen and dispatch for events.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
 */
class Eventable {
  constructor() {
    /**
     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
     */
    this._listeners = {};

    /**
     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
     */
    this._filters = {};

    /** @type {PhotoSwipe | undefined} */
    this.pswp = undefined;

    /** @type {PhotoSwipeOptions | undefined} */
    this.options = undefined;
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   * @param {number} priority
   */
  addFilter(name, fn, priority = 100) {
    if (!this._filters[name]) {
      this._filters[name] = [];
    }

    this._filters[name]?.push({ fn, priority });
    this._filters[name]?.sort((f1, f2) => f1.priority - f2.priority);

    this.pswp?.addFilter(name, fn, priority);
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   */
  removeFilter(name, fn) {
    if (this._filters[name]) {
      // @ts-expect-error
      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));
    }

    if (this.pswp) {
      this.pswp.removeFilter(name, fn);
    }
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
   */
  applyFilters(name, ...args) {
    this._filters[name]?.forEach((filter) => {
      // @ts-expect-error
      args[0] = filter.fn.apply(this, args);
    });
    return args[0];
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {EventCallback<T>} fn
   */
  on(name, fn) {
    if (!this._listeners[name]) {
      this._listeners[name] = [];
    }
    this._listeners[name]?.push(fn);

    // When binding events to lightbox,
    // also bind events to PhotoSwipe Core,
    // if it's open.
    this.pswp?.on(name, fn);
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {EventCallback<T>} fn
   */
  off(name, fn) {
    if (this._listeners[name]) {
      // @ts-expect-error
      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));
    }

    this.pswp?.off(name, fn);
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {PhotoSwipeEventsMap[T]} [details]
   * @returns {AugmentedEvent<T>}
   */
  dispatch(name, details) {
    if (this.pswp) {
      return this.pswp.dispatch(name, details);
    }

    const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));

    this._listeners[name]?.forEach((listener) => {
      listener.call(this, event);
    });

    return event;
  }
}

class Placeholder {
  /**
   * @param {string | false} imageSrc
   * @param {HTMLElement} container
   */
  constructor(imageSrc, container) {
    // Create placeholder
    // (stretched thumbnail or simple div behind the main image)
    /** @type {HTMLImageElement | HTMLDivElement | null} */
    this.element = createElement(
      'pswp__img pswp__img--placeholder',
      imageSrc ? 'img' : 'div',
      container
    );

    if (imageSrc) {
      const imgEl = /** @type {HTMLImageElement} */ (this.element);
      imgEl.decoding = 'async';
      imgEl.alt = '';
      imgEl.src = imageSrc;
      imgEl.setAttribute('role', 'presentation');
    }

    this.element.setAttribute('aria-hidden', 'true');
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  setDisplayedSize(width, height) {
    if (!this.element) {
      return;
    }

    if (this.element.tagName === 'IMG') {
      // Use transform scale() to modify img placeholder size
      // (instead of changing width/height directly).
      // This helps with performance, specifically in iOS15 Safari.
      setWidthHeight(this.element, 250, 'auto');
      this.element.style.transformOrigin = '0 0';
      this.element.style.transform = toTransformString(0, 0, width / 250);
    } else {
      setWidthHeight(this.element, width, height);
    }
  }

  destroy() {
    if (this.element?.parentNode) {
      this.element.remove();
    }
    this.element = null;
  }
}

/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../util/util.js').LoadState} LoadState */

class Content {
  /**
   * @param {SlideData} itemData Slide data
   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
   * @param {number} index
   */
  constructor(itemData, instance, index) {
    this.instance = instance;
    this.data = itemData;
    this.index = index;

    /** @type {HTMLImageElement | HTMLDivElement | undefined} */
    this.element = undefined;
    /** @type {Placeholder | undefined} */
    this.placeholder = undefined;
    /** @type {Slide | undefined} */
    this.slide = undefined;

    this.displayedImageWidth = 0;
    this.displayedImageHeight = 0;

    this.width = Number(this.data.w) || Number(this.data.width) || 0;
    this.height = Number(this.data.h) || Number(this.data.height) || 0;

    this.isAttached = false;
    this.hasSlide = false;
    this.isDecoding = false;
    /** @type {LoadState} */
    this.state = LOAD_STATE.IDLE;

    if (this.data.type) {
      this.type = this.data.type;
    } else if (this.data.src) {
      this.type = 'image';
    } else {
      this.type = 'html';
    }

    this.instance.dispatch('contentInit', { content: this });
  }

  removePlaceholder() {
    if (this.placeholder && !this.keepPlaceholder()) {
      // With delay, as image might be loaded, but not rendered
      setTimeout(() => {
        if (this.placeholder) {
          this.placeholder.destroy();
          this.placeholder = undefined;
        }
      }, 1000);
    }
  }

  /**
   * Preload content
   *
   * @param {boolean} isLazy
   * @param {boolean} [reload]
   */
  load(isLazy, reload) {
    if (this.slide && this.usePlaceholder()) {
      if (!this.placeholder) {
        const placeholderSrc = this.instance.applyFilters(
          'placeholderSrc',
          // use  image-based placeholder only for the first slide,
          // as rendering (even small stretched thumbnail) is an expensive operation
          (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,
          this
        );
        this.placeholder = new Placeholder(
          placeholderSrc,
          this.slide.container
        );
      } else {
        const placeholderEl = this.placeholder.element;
        // Add placeholder to DOM if it was already created
        if (placeholderEl && !placeholderEl.parentElement) {
          this.slide.container.prepend(placeholderEl);
        }
      }
    }

    if (this.element && !reload) {
      return;
    }

    if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {
      return;
    }

    if (this.isImageContent()) {
      this.element = createElement('pswp__img', 'img');
      // Start loading only after width is defined, as sizes might depend on it.
      // Due to Safari feature, we must define sizes before srcset.
      if (this.displayedImageWidth) {
        this.loadImage(isLazy);
      }
    } else {
      this.element = createElement('pswp__content', 'div');
      this.element.innerHTML = this.data.html || '';
    }

    if (reload && this.slide) {
      this.slide.updateContentSize(true);
    }
  }

  /**
   * Preload image
   *
   * @param {boolean} isLazy
   */
  loadImage(isLazy) {
    if (!this.isImageContent()
      || !this.element
      || this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {
      return;
    }

    const imageElement = /** @type HTMLImageElement */ (this.element);

    this.updateSrcsetSizes();

    if (this.data.srcset) {
      imageElement.srcset = this.data.srcset;
    }

    imageElement.src = this.data.src ?? '';
    imageElement.alt = this.data.alt ?? '';

    this.state = LOAD_STATE.LOADING;

    if (imageElement.complete) {
      this.onLoaded();
    } else {
      imageElement.onload = () => {
        this.onLoaded();
      };

      imageElement.onerror = () => {
        this.onError();
      };
    }
  }

  /**
   * Assign slide to content
   *
   * @param {Slide} slide
   */
  setSlide(slide) {
    this.slide = slide;
    this.hasSlide = true;
    this.instance = slide.pswp;

    // todo: do we need to unset slide?
  }

  /**
   * Content load success handler
   */
  onLoaded() {
    this.state = LOAD_STATE.LOADED;

    if (this.slide && this.element) {
      this.instance.dispatch('loadComplete', { slide: this.slide, content: this });

      // if content is reloaded
      if (this.slide.isActive
          && this.slide.heavyAppended
          && !this.element.parentNode) {
        this.append();
        this.slide.updateContentSize(true);
      }

      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
        this.removePlaceholder();
      }
    }
  }

  /**
   * Content load error handler
   */
  onError() {
    this.state = LOAD_STATE.ERROR;

    if (this.slide) {
      this.displayError();
      this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });
      this.instance.dispatch('loadError', { slide: this.slide, content: this });
    }
  }

  /**
   * @returns {Boolean} If the content is currently loading
   */
  isLoading() {
    return this.instance.applyFilters(
      'isContentLoading',
      this.state === LOAD_STATE.LOADING,
      this
    );
  }

  /**
   * @returns {Boolean} If the content is in error state
   */
  isError() {
    return this.state === LOAD_STATE.ERROR;
  }

  /**
   * @returns {boolean} If the content is image
   */
  isImageContent() {
    return this.type === 'image';
  }

  /**
   * Update content size
   *
   * @param {Number} width
   * @param {Number} height
   */
  setDisplayedSize(width, height) {
    if (!this.element) {
      return;
    }

    if (this.placeholder) {
      this.placeholder.setDisplayedSize(width, height);
    }

    if (this.instance.dispatch(
      'contentResize',
      { content: this, width, height }).defaultPrevented
    ) {
      return;
    }

    setWidthHeight(this.element, width, height);

    if (this.isImageContent() && !this.isError()) {
      const isInitialSizeUpdate = (!this.displayedImageWidth && width);

      this.displayedImageWidth = width;
      this.displayedImageHeight = height;

      if (isInitialSizeUpdate) {
        this.loadImage(false);
      } else {
        this.updateSrcsetSizes();
      }

      if (this.slide) {
        this.instance.dispatch(
          'imageSizeChange',
          { slide: this.slide, width, height, content: this }
        );
      }
    }
  }

  /**
   * @returns {boolean} If the content can be zoomed
   */
  isZoomable() {
    return this.instance.applyFilters(
      'isContentZoomable',
      this.isImageContent() && (this.state !== LOAD_STATE.ERROR),
      this
    );
  }

  /**
   * Update image srcset sizes attribute based on width and height
   */
  updateSrcsetSizes() {
    // Handle srcset sizes attribute.
    //
    // Never lower quality, if it was increased previously.
    // Chrome does this automatically, Firefox and Safari do not,
    // so we store largest used size in dataset.
    if (!this.isImageContent() || !this.element || !this.data.srcset) {
      return;
    }

    const image = /** @type HTMLImageElement */ (this.element);
    const sizesWidth = this.instance.applyFilters(
      'srcsetSizesWidth',
      this.displayedImageWidth,
      this
    );

    if (
      !image.dataset.largestUsedSize
      || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)
    ) {
      image.sizes = sizesWidth + 'px';
      image.dataset.largestUsedSize = String(sizesWidth);
    }
  }

  /**
   * @returns {boolean} If content should use a placeholder (from msrc by default)
   */
  usePlaceholder() {
    return this.instance.applyFilters(
      'useContentPlaceholder',
      this.isImageContent(),
      this
    );
  }

  /**
   * Preload content with lazy-loading param
   */
  lazyLoad() {
    if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {
      return;
    }

    this.load(true);
  }

  /**
   * @returns {boolean} If placeholder should be kept after content is loaded
   */
  keepPlaceholder() {
    return this.instance.applyFilters(
      'isKeepingPlaceholder',
      this.isLoading(),
      this
    );
  }

  /**
   * Destroy the content
   */
  destroy() {
    this.hasSlide = false;
    this.slide = undefined;

    if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {
      return;
    }

    this.remove();

    if (this.placeholder) {
      this.placeholder.destroy();
      this.placeholder = undefined;
    }

    if (this.isImageContent() && this.element) {
      this.element.onload = null;
      this.element.onerror = null;
      this.element = undefined;
    }
  }

  /**
   * Display error message
   */
  displayError() {
    if (this.slide) {
      let errorMsgEl = createElement('pswp__error-msg', 'div');
      errorMsgEl.innerText = this.instance.options?.errorMsg ?? '';
      errorMsgEl = /** @type {HTMLDivElement} */ (this.instance.applyFilters(
        'contentErrorElement',
        errorMsgEl,
        this
      ));
      this.element = createElement('pswp__content pswp__error-msg-container', 'div');
      this.element.appendChild(errorMsgEl);
      this.slide.container.innerText = '';
      this.slide.container.appendChild(this.element);
      this.slide.updateContentSize(true);
      this.removePlaceholder();
    }
  }

  /**
   * Append the content
   */
  append() {
    if (this.isAttached || !this.element) {
      return;
    }

    this.isAttached = true;

    if (this.state === LOAD_STATE.ERROR) {
      this.displayError();
      return;
    }

    if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {
      return;
    }

    const supportsDecode = ('decode' in this.element);

    if (this.isImageContent()) {
      // Use decode() on nearby slides
      //
      // Nearby slide images are in DOM and not hidden via display:none.
      // However, they are placed offscreen (to the left and right side).
      //
      // Some browsers do not composite the image until it's actually visible,
      // using decode() helps.
      //
      // You might ask "why dont you just decode() and then append all images",
      // that's because I want to show image before it's fully loaded,
      // as browser can render parts of image while it is loading.
      // We do not do this in Safari due to partial loading bug.
      if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
        this.isDecoding = true;
        // purposefully using finally instead of then,
        // as if srcset sizes changes dynamically - it may cause decode error
        /** @type {HTMLImageElement} */
        (this.element).decode().catch(() => {}).finally(() => {
          this.isDecoding = false;
          this.appendImage();
        });
      } else {
        this.appendImage();
      }
    } else if (this.slide && !this.element.parentNode) {
      this.slide.container.appendChild(this.element);
    }
  }

  /**
   * Activate the slide,
   * active slide is generally the current one,
   * meaning the user can see it.
   */
  activate() {
    if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented
      || !this.slide) {
      return;
    }

    if (this.isImageContent() && this.isDecoding && !isSafari()) {
      // add image to slide when it becomes active,
      // even if it's not finished decoding
      this.appendImage();
    } else if (this.isError()) {
      this.load(false, true); // try to reload
    }

    if (this.slide.holderElement) {
      this.slide.holderElement.setAttribute('aria-hidden', 'false');
    }
  }

  /**
   * Deactivate the content
   */
  deactivate() {
    this.instance.dispatch('contentDeactivate', { content: this });
    if (this.slide && this.slide.holderElement) {
      this.slide.holderElement.setAttribute('aria-hidden', 'true');
    }
  }


  /**
   * Remove the content from DOM
   */
  remove() {
    this.isAttached = false;

    if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {
      return;
    }

    if (this.element && this.element.parentNode) {
      this.element.remove();
    }

    if (this.placeholder && this.placeholder.element) {
      this.placeholder.element.remove();
    }
  }

  /**
   * Append the image content to slide container
   */
  appendImage() {
    if (!this.isAttached) {
      return;
    }

    if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {
      return;
    }

    // ensure that element exists and is not already appended
    if (this.slide && this.element && !this.element.parentNode) {
      this.slide.container.appendChild(this.element);
    }

    if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
      this.removePlaceholder();
    }
  }
}

/** @typedef {import('./content.js').default} Content */
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

const MIN_SLIDES_TO_CACHE = 5;

/**
 * Lazy-load an image
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * @param {SlideData} itemData Data about the slide
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
 * @param {number} index
 * @returns {Content} Image that is being decoded or false.
 */
function lazyLoadData(itemData, instance, index) {
  const content = instance.createContentFromData(itemData, index);
  /** @type {ZoomLevel | undefined} */
  let zoomLevel;

  const { options } = instance;

  // We need to know dimensions of the image to preload it,
  // as it might use srcset, and we need to define sizes
  if (options) {
    zoomLevel = new ZoomLevel(options, itemData, -1);

    let viewportSize;
    if (instance.pswp) {
      viewportSize = instance.pswp.viewportSize;
    } else {
      viewportSize = getViewportSize(options, instance);
    }

    const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);
    zoomLevel.update(content.width, content.height, panAreaSize);
  }

  content.lazyLoad();

  if (zoomLevel) {
    content.setDisplayedSize(
      Math.ceil(content.width * zoomLevel.initial),
      Math.ceil(content.height * zoomLevel.initial)
    );
  }

  return content;
}


/**
 * Lazy-loads specific slide.
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * By default, it loads image based on viewport size and initial zoom level.
 *
 * @param {number} index Slide index
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
 * @returns {Content | undefined}
 */
function lazyLoadSlide(index, instance) {
  const itemData = instance.getItemData(index);

  if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {
    return;
  }

  return lazyLoadData(itemData, instance, index);
}

class ContentLoader {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    // Total amount of cached images
    this.limit = Math.max(
      pswp.options.preload[0] + pswp.options.preload[1] + 1,
      MIN_SLIDES_TO_CACHE
    );
    /** @type {Content[]} */
    this._cachedItems = [];
  }

  /**
   * Lazy load nearby slides based on `preload` option.
   *
   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.
   */
  updateLazy(diff) {
    const { pswp } = this;

    if (pswp.dispatch('lazyLoad').defaultPrevented) {
      return;
    }

    const { preload } = pswp.options;
    const isForward = diff === undefined ? true : (diff >= 0);
    let i;

    // preload[1] - num items to preload in forward direction
    for (i = 0; i <= preload[1]; i++) {
      this.loadSlideByIndex(pswp.currIndex + (isForward ? i : (-i)));
    }

    // preload[0] - num items to preload in backward direction
    for (i = 1; i <= preload[0]; i++) {
      this.loadSlideByIndex(pswp.currIndex + (isForward ? (-i) : i));
    }
  }

  /**
   * @param {number} initialIndex
   */
  loadSlideByIndex(initialIndex) {
    const index = this.pswp.getLoopedIndex(initialIndex);
    // try to get cached content
    let content = this.getContentByIndex(index);
    if (!content) {
      // no cached content, so try to load from scratch:
      content = lazyLoadSlide(index, this.pswp);
      // if content can be loaded, add it to cache:
      if (content) {
        this.addToCache(content);
      }
    }
  }

  /**
   * @param {Slide} slide
   * @returns {Content}
   */
  getContentBySlide(slide) {
    let content = this.getContentByIndex(slide.index);
    if (!content) {
      // create content if not found in cache
      content = this.pswp.createContentFromData(slide.data, slide.index);
      this.addToCache(content);
    }

    // assign slide to content
    content.setSlide(slide);

    return content;
  }

  /**
   * @param {Content} content
   */
  addToCache(content) {
    // move to the end of array
    this.removeByIndex(content.index);
    this._cachedItems.push(content);

    if (this._cachedItems.length > this.limit) {
      // Destroy the first content that's not attached
      const indexToRemove = this._cachedItems.findIndex((item) => {
        return !item.isAttached && !item.hasSlide;
      });
      if (indexToRemove !== -1) {
        const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
        removedItem.destroy();
      }
    }
  }

  /**
   * Removes an image from cache, does not destroy() it, just removes.
   *
   * @param {number} index
   */
  removeByIndex(index) {
    const indexToRemove = this._cachedItems.findIndex(item => item.index === index);
    if (indexToRemove !== -1) {
      this._cachedItems.splice(indexToRemove, 1);
    }
  }

  /**
   * @param {number} index
   * @returns {Content | undefined}
   */
  getContentByIndex(index) {
    return this._cachedItems.find(content => content.index === index);
  }

  destroy() {
    this._cachedItems.forEach(content => content.destroy());
    this._cachedItems = [];
  }
}

/** @typedef {import("../photoswipe.js").default} PhotoSwipe */
/** @typedef {import("../slide/slide.js").SlideData} SlideData */

/**
 * PhotoSwipe base class that can retrieve data about every slide.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
 */
class PhotoSwipeBase extends Eventable {
  /**
   * Get total number of slides
   *
   * @returns {number}
   */
  getNumItems() {
    let numItems = 0;
    const dataSource = this.options?.dataSource;

    if (dataSource && 'length' in dataSource) {
      // may be an array or just object with length property
      numItems = dataSource.length;
    } else if (dataSource && 'gallery' in dataSource) {
      // query DOM elements
      if (!dataSource.items) {
        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
      }

      if (dataSource.items) {
        numItems = dataSource.items.length;
      }
    }

    // legacy event, before filters were introduced
    const event = this.dispatch('numItems', {
      dataSource,
      numItems
    });
    return this.applyFilters('numItems', event.numItems, dataSource);
  }

  /**
   * @param {SlideData} slideData
   * @param {number} index
   * @returns {Content}
   */
  createContentFromData(slideData, index) {
    return new Content(slideData, this, index);
  }

  /**
   * Get item data by index.
   *
   * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
   * For example, it may contain properties like
   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
   *
   * @param {number} index
   * @returns {SlideData}
   */
  getItemData(index) {
    const dataSource = this.options?.dataSource;
    /** @type {SlideData | HTMLElement} */
    let dataSourceItem = {};
    if (Array.isArray(dataSource)) {
      // Datasource is an array of elements
      dataSourceItem = dataSource[index];
    } else if (dataSource && 'gallery' in dataSource) {
      // dataSource has gallery property,
      // thus it was created by Lightbox, based on
      // gallery and children options

      // query DOM elements
      if (!dataSource.items) {
        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
      }

      dataSourceItem = dataSource.items[index];
    }

    let itemData = dataSourceItem;

    if (itemData instanceof Element) {
      itemData = this._domElementToItemData(itemData);
    }

    // Dispatching the itemData event,
    // it's a legacy verion before filters were introduced
    const event = this.dispatch('itemData', {
      itemData: itemData || {},
      index
    });

    return this.applyFilters('itemData', event.itemData, index);
  }

  /**
   * Get array of gallery DOM elements,
   * based on childSelector and gallery element.
   *
   * @param {HTMLElement} galleryElement
   * @returns {HTMLElement[]}
   */
  _getGalleryDOMElements(galleryElement) {
    if (this.options?.children || this.options?.childSelector) {
      return getElementsFromOption(
        this.options.children,
        this.options.childSelector,
        galleryElement
      ) || [];
    }

    return [galleryElement];
  }

  /**
   * Converts DOM element to item data object.
   *
   * @param {HTMLElement} element DOM element
   * @returns {SlideData}
   */
  _domElementToItemData(element) {
    /** @type {SlideData} */
    const itemData = {
      element
    };

    const linkEl = /** @type {HTMLAnchorElement} */ (
      element.tagName === 'A'
        ? element
        : element.querySelector('a')
    );

    if (linkEl) {
      // src comes from data-pswp-src attribute,
      // if it's empty link href is used
      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;

      if (linkEl.dataset.pswpSrcset) {
        itemData.srcset = linkEl.dataset.pswpSrcset;
      }

      itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;
      itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0;

      // support legacy w & h properties
      itemData.w = itemData.width;
      itemData.h = itemData.height;

      if (linkEl.dataset.pswpType) {
        itemData.type = linkEl.dataset.pswpType;
      }

      const thumbnailEl = element.querySelector('img');

      if (thumbnailEl) {
        // msrc is URL to placeholder image that's displayed before large image is loaded
        // by default it's displayed only for the first slide
        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
        itemData.alt = thumbnailEl.getAttribute('alt') ?? '';
      }

      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
        itemData.thumbCropped = true;
      }
    }

    return this.applyFilters('domItemData', itemData, element, linkEl);
  }

  /**
   * Lazy-load by slide data
   *
   * @param {SlideData} itemData Data about the slide
   * @param {number} index
   * @returns {Content} Image that is being decoded or false.
   */
  lazyLoadData(itemData, index) {
    return lazyLoadData(itemData, this, index);
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */
/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */

// some browsers do not paint
// elements which opacity is set to 0,
// since we need to pre-render elements for the animation -
// we set it to the minimum amount
const MIN_OPACITY = 0.003;

/**
 * Manages opening and closing transitions of the PhotoSwipe.
 *
 * It can perform zoom, fade or no transition.
 */
class Opener {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    this.isClosed = true;
    this.isOpen = false;
    this.isClosing = false;
    this.isOpening = false;
    /**
     * @private
     * @type {number | false | undefined}
     */
    this._duration = undefined;
    /** @private */
    this._useAnimation = false;
    /** @private */
    this._croppedZoom = false;
    /** @private */
    this._animateRootOpacity = false;
    /** @private */
    this._animateBgOpacity = false;
    /**
     * @private
     * @type { HTMLDivElement | HTMLImageElement | null | undefined }
     */
    this._placeholder = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */
    this._opacityElement = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */
    this._cropContainer1 = undefined;
    /**
     * @private
     * @type { HTMLElement | null | undefined }
     */
    this._cropContainer2 = undefined;

    /**
     * @private
     * @type {Bounds | undefined}
     */
    this._thumbBounds = undefined;


    this._prepareOpen = this._prepareOpen.bind(this);

    // Override initial zoom and pan position
    pswp.on('firstZoomPan', this._prepareOpen);
  }

  open() {
    this._prepareOpen();
    this._start();
  }

  close() {
    if (this.isClosed || this.isClosing || this.isOpening) {
      // if we close during opening animation
      // for now do nothing,
      // browsers aren't good at changing the direction of the CSS transition
      return;
    }

    const slide = this.pswp.currSlide;

    this.isOpen = false;
    this.isOpening = false;
    this.isClosing = true;
    this._duration = this.pswp.options.hideAnimationDuration;

    if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
      this._duration = 0;
    }

    this._applyStartProps();
    setTimeout(() => {
      this._start();
    }, this._croppedZoom ? 30 : 0);
  }

  /** @private */
  _prepareOpen() {
    this.pswp.off('firstZoomPan', this._prepareOpen);
    if (!this.isOpening) {
      const slide = this.pswp.currSlide;
      this.isOpening = true;
      this.isClosing = false;
      this._duration = this.pswp.options.showAnimationDuration;
      if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
        this._duration = 0;
      }
      this._applyStartProps();
    }
  }

  /** @private */
  _applyStartProps() {
    const { pswp } = this;
    const slide = this.pswp.currSlide;
    const { options } = pswp;

    if (options.showHideAnimationType === 'fade') {
      options.showHideOpacity = true;
      this._thumbBounds = undefined;
    } else if (options.showHideAnimationType === 'none') {
      options.showHideOpacity = false;
      this._duration = 0;
      this._thumbBounds = undefined;
    } else if (this.isOpening && pswp._initialThumbBounds) {
      // Use initial bounds if defined
      this._thumbBounds = pswp._initialThumbBounds;
    } else {
      this._thumbBounds = this.pswp.getThumbBounds();
    }

    this._placeholder = slide?.getPlaceholderElement();

    pswp.animations.stopAll();

    // Discard animations when duration is less than 50ms
    this._useAnimation = Boolean(this._duration && this._duration > 50);
    this._animateZoom = Boolean(this._thumbBounds)
                        && slide?.content.usePlaceholder()
                        && (!this.isClosing || !pswp.mainScroll.isShifted());
    if (!this._animateZoom) {
      this._animateRootOpacity = true;

      if (this.isOpening && slide) {
        slide.zoomAndPanToInitial();
        slide.applyCurrentZoomPan();
      }
    } else {
      this._animateRootOpacity = options.showHideOpacity ?? false;
    }
    this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
    this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;

    if (!this._useAnimation) {
      this._duration = 0;
      this._animateZoom = false;
      this._animateBgOpacity = false;
      this._animateRootOpacity = true;
      if (this.isOpening) {
        if (pswp.element) {
          pswp.element.style.opacity = String(MIN_OPACITY);
        }
        pswp.applyBgOpacity(1);
      }
      return;
    }

    if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
      // Properties are used when animation from cropped thumbnail
      this._croppedZoom = true;
      this._cropContainer1 = this.pswp.container;
      this._cropContainer2 = this.pswp.currSlide?.holderElement;

      if (pswp.container) {
        pswp.container.style.overflow = 'hidden';
        pswp.container.style.width = pswp.viewportSize.x + 'px';
      }
    } else {
      this._croppedZoom = false;
    }

    if (this.isOpening) {
      // Apply styles before opening transition
      if (this._animateRootOpacity) {
        if (pswp.element) {
          pswp.element.style.opacity = String(MIN_OPACITY);
        }
        pswp.applyBgOpacity(1);
      } else {
        if (this._animateBgOpacity && pswp.bg) {
          pswp.bg.style.opacity = String(MIN_OPACITY);
        }
        if (pswp.element) {
          pswp.element.style.opacity = '1';
        }
      }

      if (this._animateZoom) {
        this._setClosedStateZoomPan();
        if (this._placeholder) {
          // tell browser that we plan to animate the placeholder
          this._placeholder.style.willChange = 'transform';

          // hide placeholder to allow hiding of
          // elements that overlap it (such as icons over the thumbnail)
          this._placeholder.style.opacity = String(MIN_OPACITY);
        }
      }
    } else if (this.isClosing) {
      // hide nearby slides to make sure that
      // they are not painted during the transition
      if (pswp.mainScroll.itemHolders[0]) {
        pswp.mainScroll.itemHolders[0].el.style.display = 'none';
      }
      if (pswp.mainScroll.itemHolders[2]) {
        pswp.mainScroll.itemHolders[2].el.style.display = 'none';
      }

      if (this._croppedZoom) {
        if (pswp.mainScroll.x !== 0) {
          // shift the main scroller to zero position
          pswp.mainScroll.resetPosition();
          pswp.mainScroll.resize();
        }
      }
    }
  }

  /** @private */
  _start() {
    if (this.isOpening
        && this._useAnimation
        && this._placeholder
        && this._placeholder.tagName === 'IMG') {
      // To ensure smooth animation
      // we wait till the current slide image placeholder is decoded,
      // but no longer than 250ms,
      // and no shorter than 50ms
      // (just using requestanimationframe is not enough in Firefox,
      // for some reason)
      new Promise((resolve) => {
        let decoded = false;
        let isDelaying = true;
        decodeImage(/** @type {HTMLImageElement} */ (this._placeholder)).finally(() => {
          decoded = true;
          if (!isDelaying) {
            resolve(true);
          }
        });
        setTimeout(() => {
          isDelaying = false;
          if (decoded) {
            resolve(true);
          }
        }, 50);
        setTimeout(resolve, 250);
      }).finally(() => this._initiate());
    } else {
      this._initiate();
    }
  }

  /** @private */
  _initiate() {
    this.pswp.element?.style.setProperty('--pswp-transition-duration', this._duration + 'ms');

    this.pswp.dispatch(
      this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'
    );

    // legacy event
    this.pswp.dispatch(
      /** @type {'initialZoomIn' | 'initialZoomOut'} */
      ('initialZoom' + (this.isOpening ? 'In' : 'Out'))
    );

    this.pswp.element?.classList.toggle('pswp--ui-visible', this.isOpening);

    if (this.isOpening) {
      if (this._placeholder) {
        // unhide the placeholder
        this._placeholder.style.opacity = '1';
      }
      this._animateToOpenState();
    } else if (this.isClosing) {
      this._animateToClosedState();
    }

    if (!this._useAnimation) {
      this._onAnimationComplete();
    }
  }

  /** @private */
  _onAnimationComplete() {
    const { pswp } = this;
    this.isOpen = this.isOpening;
    this.isClosed = this.isClosing;
    this.isOpening = false;
    this.isClosing = false;

    pswp.dispatch(
      this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'
    );

    // legacy event
    pswp.dispatch(
      /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
      ('initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'))
    );

    if (this.isClosed) {
      pswp.destroy();
    } else if (this.isOpen) {
      if (this._animateZoom && pswp.container) {
        pswp.container.style.overflow = 'visible';
        pswp.container.style.width = '100%';
      }
      pswp.currSlide?.applyCurrentZoomPan();
    }
  }

  /** @private */
  _animateToOpenState() {
    const { pswp } = this;
    if (this._animateZoom) {
      if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {
        this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');
        this._animateTo(this._cropContainer2, 'transform', 'none');
      }

      if (pswp.currSlide) {
        pswp.currSlide.zoomAndPanToInitial();
        this._animateTo(
          pswp.currSlide.container,
          'transform',
          pswp.currSlide.getCurrentTransform()
        );
      }
    }

    if (this._animateBgOpacity && pswp.bg) {
      this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));
    }

    if (this._animateRootOpacity && pswp.element) {
      this._animateTo(pswp.element, 'opacity', '1');
    }
  }

  /** @private */
  _animateToClosedState() {
    const { pswp } = this;

    if (this._animateZoom) {
      this._setClosedStateZoomPan(true);
    }

    // do not animate opacity if it's already at 0
    if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {
      this._animateTo(pswp.bg, 'opacity', '0');
    }

    if (this._animateRootOpacity && pswp.element) {
      this._animateTo(pswp.element, 'opacity', '0');
    }
  }

  /**
   * @private
   * @param {boolean} [animate]
   */
  _setClosedStateZoomPan(animate) {
    if (!this._thumbBounds) return;

    const { pswp } = this;
    const { innerRect } = this._thumbBounds;
    const { currSlide, viewportSize } = pswp;

    if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {
      const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
      const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
      const containerTwoPanX = viewportSize.x - innerRect.w;
      const containerTwoPanY = viewportSize.y - innerRect.h;


      if (animate) {
        this._animateTo(
          this._cropContainer1,
          'transform',
          toTransformString(containerOnePanX, containerOnePanY)
        );

        this._animateTo(
          this._cropContainer2,
          'transform',
          toTransformString(containerTwoPanX, containerTwoPanY)
        );
      } else {
        setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
        setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
      }
    }

    if (currSlide) {
      equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
      currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;
      if (animate) {
        this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());
      } else {
        currSlide.applyCurrentZoomPan();
      }
    }
  }

  /**
   * @private
   * @param {HTMLElement} target
   * @param {'transform' | 'opacity'} prop
   * @param {string} propValue
   */
  _animateTo(target, prop, propValue) {
    if (!this._duration) {
      target.style[prop] = propValue;
      return;
    }

    const { animations } = this.pswp;
    /** @type {AnimationProps} */
    const animProps = {
      duration: this._duration,
      easing: this.pswp.options.easing,
      onComplete: () => {
        if (!animations.activeAnimations.length) {
          this._onAnimationComplete();
        }
      },
      target,
    };
    animProps[prop] = propValue;
    animations.startTransition(animProps);
  }
}

/**
 * @template T
 * @typedef {import('./types.js').Type<T>} Type<T>
 */

/** @typedef {import('./slide/slide.js').SlideData} SlideData */
/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */
/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */
/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */
/** @typedef {import('./slide/get-thumb-bounds').Bounds} Bounds */
/**
 * @template T
 * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>
 */
/**
 * @template T
 * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>
 */

/** @typedef {{ x: number; y: number; id?: string | number }} Point */
/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */
/** @typedef {SlideData[]} DataSourceArray */
/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */
/** @typedef {DataSourceArray | DataSourceObject} DataSource */
/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */
/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */
/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */
/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */

/**
 * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider
 */

/** @typedef {Partial<PreparedPhotoSwipeOptions>} PhotoSwipeOptions https://photoswipe.com/options/ */
/**
 * @typedef {Object} PreparedPhotoSwipeOptions
 *
 * @prop {DataSource} [dataSource]
 * Pass an array of any items via dataSource option. Its length will determine amount of slides
 * (which may be modified further from numItems event).
 *
 * Each item should contain data that you need to generate slide
 * (for image slide it would be src (image URL), width (image width), height, srcset, alt).
 *
 * If these properties are not present in your initial array, you may "pre-parse" each item from itemData filter.
 *
 * @prop {number} bgOpacity
 * Background backdrop opacity, always define it via this option and not via CSS rgba color.
 *
 * @prop {number} spacing
 * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).
 *
 * @prop {boolean} allowPanToNext
 * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.
 *
 * @prop {boolean} loop
 * If set to true you'll be able to swipe from the last to the first image.
 * Option is always false when there are less than 3 slides.
 *
 * @prop {boolean} [wheelToZoom]
 * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.
 *
 * @prop {boolean} pinchToClose
 * Pinch touch gesture to close the gallery.
 *
 * @prop {boolean} closeOnVerticalDrag
 * Vertical drag gesture to close the PhotoSwipe.
 *
 * @prop {Padding} [padding]
 * Slide area padding (in pixels).
 *
 * @prop {(viewportSize: Point, itemData: SlideData, index: number) => Padding} [paddingFn]
 * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:
 *
 * @prop {number | false} hideAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} showAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} zoomAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {string} easing
 * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.
 *
 * @prop {boolean} escKey
 * Esc key to close.
 *
 * @prop {boolean} arrowKeys
 * Left/right arrow keys for navigation.
 *
 * @prop {boolean} returnFocus
 * Restore focus the last active element after PhotoSwipe is closed.
 *
 * @prop {boolean} clickToCloseNonZoomable
 * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.
 *
 * @prop {ActionType | ActionFn | false} imageClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} bgClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} tapAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} doubleTapAction
 * Refer to click and tap actions page.
 *
 * @prop {number} preloaderDelay
 * Delay before the loading indicator will be displayed,
 * if image is loaded during it - the indicator will not be displayed at all. Can be zero.
 *
 * @prop {string} indexIndicatorSep
 * Used for slide count indicator ("1 of 10 ").
 *
 * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipeBase) => Point} [getViewportSizeFn]
 * A function that should return slide viewport width and height, in format {x: 100, y: 100}.
 *
 * @prop {string} errorMsg
 * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.
 *
 * @prop {[number, number]} preload
 * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,
 * first one - number of items to preload before the current image, second one - after the current image.
 * Two nearby images are always loaded.
 *
 * @prop {string} [mainClass]
 * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.
 * Example on Styling page.
 *
 * @prop {HTMLElement} [appendToEl]
 * Element to which PhotoSwipe dialog will be appended when it opens.
 *
 * @prop {number} maxWidthToAnimate
 * Maximum width of image to animate, if initial rendered image width
 * is larger than this value - the opening/closing transition will be automatically disabled.
 *
 * @prop {string} [closeTitle]
 * Translating
 *
 * @prop {string} [zoomTitle]
 * Translating
 *
 * @prop {string} [arrowPrevTitle]
 * Translating
 *
 * @prop {string} [arrowNextTitle]
 * Translating
 *
 * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]
 * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).
 * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.
 *
 * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.
 *
 * @prop {number} index
 * Defines start slide index.
 *
 * @prop {(e: MouseEvent) => number} [getClickedIndexFn]
 *
 * @prop {boolean} [arrowPrev]
 * @prop {boolean} [arrowNext]
 * @prop {boolean} [zoom]
 * @prop {boolean} [close]
 * @prop {boolean} [counter]
 *
 * @prop {string} [arrowPrevSVG]
 * @prop {string} [arrowNextSVG]
 * @prop {string} [zoomSVG]
 * @prop {string} [closeSVG]
 * @prop {string} [counterSVG]
 *
 * @prop {string} [arrowPrevTitle]
 * @prop {string} [arrowNextTitle]
 * @prop {string} [zoomTitle]
 * @prop {string} [closeTitle]
 * @prop {string} [counterTitle]
 *
 * @prop {ZoomLevelOption} [initialZoomLevel]
 * @prop {ZoomLevelOption} [secondaryZoomLevel]
 * @prop {ZoomLevelOption} [maxZoomLevel]
 *
 * @prop {boolean} [mouseMovePan]
 * @prop {Point | null} [initialPointerPos]
 * @prop {boolean} [showHideOpacity]
 *
 * @prop {PhotoSwipeModuleOption} [pswpModule]
 * @prop {() => Promise<any>} [openPromise]
 * @prop {boolean} [preloadFirstSlide]
 * @prop {ElementProvider} [gallery]
 * @prop {string} [gallerySelector]
 * @prop {ElementProvider} [children]
 * @prop {string} [childSelector]
 * @prop {string | false} [thumbSelector]
 */

/** @type {PreparedPhotoSwipeOptions} */
const defaultOptions = {
  allowPanToNext: true,
  spacing: 0.1,
  loop: true,
  pinchToClose: true,
  closeOnVerticalDrag: true,
  hideAnimationDuration: 333,
  showAnimationDuration: 333,
  zoomAnimationDuration: 333,
  escKey: true,
  arrowKeys: true,
  returnFocus: true,
  maxWidthToAnimate: 4000,
  clickToCloseNonZoomable: true,
  imageClickAction: 'zoom-or-close',
  bgClickAction: 'close',
  tapAction: 'toggle-controls',
  doubleTapAction: 'zoom',
  indexIndicatorSep: ' / ',
  preloaderDelay: 2000,
  bgOpacity: 0.8,

  index: 0,
  errorMsg: 'The image cannot be loaded',
  preload: [1, 2],
  easing: 'cubic-bezier(.4,0,.22,1)'
};

/**
 * PhotoSwipe Core
 */
class PhotoSwipe extends PhotoSwipeBase {
  /**
   * @param {PhotoSwipeOptions} [options]
   */
  constructor(options) {
    super();

    this.options = this._prepareOptions(options || {});

    /**
     * offset of viewport relative to document
     *
     * @type {Point}
     */
    this.offset = { x: 0, y: 0 };

    /**
     * @type {Point}
     * @private
     */
    this._prevViewportSize = { x: 0, y: 0 };

    /**
     * Size of scrollable PhotoSwipe viewport
     *
     * @type {Point}
     */
    this.viewportSize = { x: 0, y: 0 };

    /**
     * background (backdrop) opacity
     */
    this.bgOpacity = 1;
    this.currIndex = 0;
    this.potentialIndex = 0;
    this.isOpen = false;
    this.isDestroying = false;
    this.hasMouse = false;

    /**
     * @private
     * @type {SlideData}
     */
    this._initialItemData = {};
    /** @type {Bounds | undefined} */
    this._initialThumbBounds = undefined;

    /** @type {HTMLDivElement | undefined} */
    this.topBar = undefined;
    /** @type {HTMLDivElement | undefined} */
    this.element = undefined;
    /** @type {HTMLDivElement | undefined} */
    this.template = undefined;
    /** @type {HTMLDivElement | undefined} */
    this.container = undefined;
    /** @type {HTMLElement | undefined} */
    this.scrollWrap = undefined;
    /** @type {Slide | undefined} */
    this.currSlide = undefined;

    this.events = new DOMEvents();
    this.animations = new Animations();
    this.mainScroll = new MainScroll(this);
    this.gestures = new Gestures(this);
    this.opener = new Opener(this);
    this.keyboard = new Keyboard(this);
    this.contentLoader = new ContentLoader(this);
  }

  /** @returns {boolean} */
  init() {
    if (this.isOpen || this.isDestroying) {
      return false;
    }

    this.isOpen = true;
    this.dispatch('init'); // legacy
    this.dispatch('beforeOpen');

    this._createMainStructure();

    // add classes to the root element of PhotoSwipe
    let rootClasses = 'pswp--open';
    if (this.gestures.supportsTouch) {
      rootClasses += ' pswp--touch';
    }
    if (this.options.mainClass) {
      rootClasses += ' ' + this.options.mainClass;
    }
    if (this.element) {
      this.element.className += ' ' + rootClasses;
    }

    this.currIndex = this.options.index || 0;
    this.potentialIndex = this.currIndex;
    this.dispatch('firstUpdate'); // starting index can be modified here

    // initialize scroll wheel handler to block the scroll
    this.scrollWheel = new ScrollWheel(this);

    // sanitize index
    if (Number.isNaN(this.currIndex)
        || this.currIndex < 0
        || this.currIndex >= this.getNumItems()) {
      this.currIndex = 0;
    }

    if (!this.gestures.supportsTouch) {
      // enable mouse features if no touch support detected
      this.mouseDetected();
    }

    // causes forced synchronous layout
    this.updateSize();

    this.offset.y = window.pageYOffset;

    this._initialItemData = this.getItemData(this.currIndex);
    this.dispatch('gettingData', {
      index: this.currIndex,
      data: this._initialItemData,
      slide: undefined
    });

    // *Layout* - calculate size and position of elements here
    this._initialThumbBounds = this.getThumbBounds();
    this.dispatch('initialLayout');

    this.on('openingAnimationEnd', () => {
      const { itemHolders } = this.mainScroll;

      // Add content to the previous and next slide
      if (itemHolders[0]) {
        itemHolders[0].el.style.display = 'block';
        this.setContent(itemHolders[0], this.currIndex - 1);
      }
      if (itemHolders[2]) {
        itemHolders[2].el.style.display = 'block';
        this.setContent(itemHolders[2], this.currIndex + 1);
      }

      this.appendHeavy();

      this.contentLoader.updateLazy();

      this.events.add(window, 'resize', this._handlePageResize.bind(this));
      this.events.add(window, 'scroll', this._updatePageScrollOffset.bind(this));
      this.dispatch('bindEvents');
    });

    // set content for center slide (first time)
    if (this.mainScroll.itemHolders[1]) {
      this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
    }
    this.dispatch('change');

    this.opener.open();

    this.dispatch('afterInit');

    return true;
  }

  /**
   * Get looped slide index
   * (for example, -1 will return the last slide)
   *
   * @param {number} index
   * @returns {number}
   */
  getLoopedIndex(index) {
    const numSlides = this.getNumItems();

    if (this.options.loop) {
      if (index > numSlides - 1) {
        index -= numSlides;
      }

      if (index < 0) {
        index += numSlides;
      }
    }

    return clamp(index, 0, numSlides - 1);
  }

  appendHeavy() {
    this.mainScroll.itemHolders.forEach((itemHolder) => {
      itemHolder.slide?.appendHeavy();
    });
  }

  /**
   * Change the slide
   * @param {number} index New index
   */
  goTo(index) {
    this.mainScroll.moveIndexBy(
      this.getLoopedIndex(index) - this.potentialIndex
    );
  }

  /**
   * Go to the next slide.
   */
  next() {
    this.goTo(this.potentialIndex + 1);
  }

  /**
   * Go to the previous slide.
   */
  prev() {
    this.goTo(this.potentialIndex - 1);
  }

  /**
   * @see slide/slide.js zoomTo
   *
   * @param {Parameters<Slide['zoomTo']>} args
   */
  zoomTo(...args) {
    this.currSlide?.zoomTo(...args);
  }

  /**
   * @see slide/slide.js toggleZoom
   */
  toggleZoom() {
    this.currSlide?.toggleZoom();
  }

  /**
   * Close the gallery.
   * After closing transition ends - destroy it
   */
  close() {
    if (!this.opener.isOpen || this.isDestroying) {
      return;
    }

    this.isDestroying = true;

    this.dispatch('close');

    this.events.removeAll();
    this.opener.close();
  }

  /**
   * Destroys the gallery:
   * - instantly closes the gallery
   * - unbinds events,
   * - cleans intervals and timeouts
   * - removes elements from DOM
   */
  destroy() {
    if (!this.isDestroying) {
      this.options.showHideAnimationType = 'none';
      this.close();
      return;
    }

    this.dispatch('destroy');

    this._listeners = {};

    if (this.scrollWrap) {
      this.scrollWrap.ontouchmove = null;
      this.scrollWrap.ontouchend = null;
    }

    this.element?.remove();

    this.mainScroll.itemHolders.forEach((itemHolder) => {
      itemHolder.slide?.destroy();
    });

    this.contentLoader.destroy();
    this.events.removeAll();
  }

  /**
   * Refresh/reload content of a slide by its index
   *
   * @param {number} slideIndex
   */
  refreshSlideContent(slideIndex) {
    this.contentLoader.removeByIndex(slideIndex);
    this.mainScroll.itemHolders.forEach((itemHolder, i) => {
      let potentialHolderIndex = (this.currSlide?.index ?? 0) - 1 + i;
      if (this.canLoop()) {
        potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);
      }
      if (potentialHolderIndex === slideIndex) {
        // set the new slide content
        this.setContent(itemHolder, slideIndex, true);

        // activate the new slide if it's current
        if (i === 1) {
          this.currSlide = itemHolder.slide;
          itemHolder.slide?.setIsActive(true);
        }
      }
    });

    this.dispatch('change');
  }


  /**
   * Set slide content
   *
   * @param {ItemHolder} holder mainScroll.itemHolders array item
   * @param {number} index Slide index
   * @param {boolean} [force] If content should be set even if index wasn't changed
   */
  setContent(holder, index, force) {
    if (this.canLoop()) {
      index = this.getLoopedIndex(index);
    }

    if (holder.slide) {
      if (holder.slide.index === index && !force) {
        // exit if holder already contains this slide
        // this could be common when just three slides are used
        return;
      }

      // destroy previous slide
      holder.slide.destroy();
      holder.slide = undefined;
    }

    // exit if no loop and index is out of bounds
    if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
      return;
    }

    const itemData = this.getItemData(index);
    holder.slide = new Slide(itemData, index, this);

    // set current slide
    if (index === this.currIndex) {
      this.currSlide = holder.slide;
    }

    holder.slide.append(holder.el);
  }

  /** @returns {Point} */
  getViewportCenterPoint() {
    return {
      x: this.viewportSize.x / 2,
      y: this.viewportSize.y / 2
    };
  }

  /**
   * Update size of all elements.
   * Executed on init and on page resize.
   *
   * @param {boolean} [force] Update size even if size of viewport was not changed.
   */
  updateSize(force) {
    // let item;
    // let itemIndex;

    if (this.isDestroying) {
      // exit if PhotoSwipe is closed or closing
      // (to avoid errors, as resize event might be delayed)
      return;
    }

    //const newWidth = this.scrollWrap.clientWidth;
    //const newHeight = this.scrollWrap.clientHeight;

    const newViewportSize = getViewportSize(this.options, this);

    if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
      // Exit if dimensions were not changed
      return;
    }

    //this._prevViewportSize.x = newWidth;
    //this._prevViewportSize.y = newHeight;
    equalizePoints(this._prevViewportSize, newViewportSize);

    this.dispatch('beforeResize');

    equalizePoints(this.viewportSize, this._prevViewportSize);

    this._updatePageScrollOffset();

    this.dispatch('viewportSize');

    // Resize slides only after opener animation is finished
    // and don't re-calculate size on inital size update
    this.mainScroll.resize(this.opener.isOpen);

    if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {
      this.mouseDetected();
    }

    this.dispatch('resize');
  }

  /**
   * @param {number} opacity
   */
  applyBgOpacity(opacity) {
    this.bgOpacity = Math.max(opacity, 0);
    if (this.bg) {
      this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
    }
  }

  /**
   * Whether mouse is detected
   */
  mouseDetected() {
    if (!this.hasMouse) {
      this.hasMouse = true;
      this.element?.classList.add('pswp--has_mouse');
    }
  }

  /**
   * Page resize event handler
   *
   * @private
   */
  _handlePageResize() {
    this.updateSize();

    // In iOS webview, if element size depends on document size,
    // it'll be measured incorrectly in resize event
    //
    // https://bugs.webkit.org/show_bug.cgi?id=170595
    // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d
    if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
      setTimeout(() => {
        this.updateSize();
      }, 500);
    }
  }

  /**
   * Page scroll offset is used
   * to get correct coordinates
   * relative to PhotoSwipe viewport.
   *
   * @private
   */
  _updatePageScrollOffset() {
    this.setScrollOffset(0, window.pageYOffset);
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  setScrollOffset(x, y) {
    this.offset.x = x;
    this.offset.y = y;
    this.dispatch('updateScrollOffset');
  }

  /**
   * Create main HTML structure of PhotoSwipe,
   * and add it to DOM
   *
   * @private
   */
  _createMainStructure() {
    // root DOM element of PhotoSwipe (.pswp)
    this.element = createElement('pswp', 'div');
    this.element.setAttribute('tabindex', '-1');
    this.element.setAttribute('role', 'dialog');

    // template is legacy prop
    this.template = this.element;

    // Background is added as a separate element,
    // as animating opacity is faster than animating rgba()
    this.bg = createElement('pswp__bg', 'div', this.element);
    this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);
    this.container = createElement('pswp__container', 'div', this.scrollWrap);

    // aria pattern: carousel
    this.scrollWrap.setAttribute('aria-roledescription', 'carousel');
    this.container.setAttribute('aria-live', 'off');
    this.container.setAttribute('id', 'pswp__items');

    this.mainScroll.appendHolders();

    this.ui = new UI(this);
    this.ui.init();

    // append to DOM
    (this.options.appendToEl || document.body).appendChild(this.element);
  }


  /**
   * Get position and dimensions of small thumbnail
   *   {x:,y:,w:}
   *
   * Height is optional (calculated based on the large image)
   *
   * @returns {Bounds | undefined}
   */
  getThumbBounds() {
    return getThumbBounds(
      this.currIndex,
      this.currSlide ? this.currSlide.data : this._initialItemData,
      this
    );
  }

  /**
   * If the PhotoSwipe can have continuous loop
   * @returns Boolean
   */
  canLoop() {
    return (this.options.loop && this.getNumItems() > 2);
  }

  /**
   * @private
   * @param {PhotoSwipeOptions} options
   * @returns {PreparedPhotoSwipeOptions}
   */
  _prepareOptions(options) {
    if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {
      options.showHideAnimationType = 'none';
      options.zoomAnimationDuration = 0;
    }

    /** @type {PreparedPhotoSwipeOptions} */
    return {
      ...defaultOptions,
      ...options
    };
  }
}


//# sourceMappingURL=photoswipe.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcGhvdG9zd2lwZV9kaXN0X3Bob3Rvc3dpcGVfZXNtX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLEtBQUssT0FBTztBQUMvQztBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sR0FBRyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bob3Rvc3dpcGUvZGlzdC9waG90b3N3aXBlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBQaG90b1N3aXBlIDUuMy42IC0gaHR0cHM6Ly9waG90b3N3aXBlLmNvbVxuICAqIChjKSAyMDIzIERteXRybyBTZW1lbm92XG4gICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xyXG5cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBUXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcclxuICogQHBhcmFtIHtUfSB0YWdOYW1lXHJcbiAqIEBwYXJhbSB7Tm9kZX0gW2FwcGVuZFRvRWxdXHJcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbVF19XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgdGFnTmFtZSwgYXBwZW5kVG9FbCkge1xyXG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgfVxyXG4gIGlmIChhcHBlbmRUb0VsKSB7XHJcbiAgICBhcHBlbmRUb0VsLmFwcGVuZENoaWxkKGVsKTtcclxuICB9XHJcbiAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICogQHJldHVybnMge1BvaW50fVxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxpemVQb2ludHMocDEsIHAyKSB7XHJcbiAgcDEueCA9IHAyLng7XHJcbiAgcDEueSA9IHAyLnk7XHJcbiAgaWYgKHAyLmlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHAxLmlkID0gcDIuaWQ7XHJcbiAgfVxyXG4gIHJldHVybiBwMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBcclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kUG9pbnQocCkge1xyXG4gIHAueCA9IE1hdGgucm91bmQocC54KTtcclxuICBwLnkgPSBNYXRoLnJvdW5kKHAueSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cclxuICpcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlQmV0d2VlbihwMSwgcDIpIHtcclxuICBjb25zdCB4ID0gTWF0aC5hYnMocDEueCAtIHAyLngpO1xyXG4gIGNvbnN0IHkgPSBNYXRoLmFicyhwMS55IC0gcDIueSk7XHJcbiAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIFggYW5kIFkgcG9zaXRpb25zIG9mIHBvaW50cyBhcmUgZXF1YWxcclxuICpcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2ludHNFcXVhbChwMSwgcDIpIHtcclxuICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGZsb2F0IHJlc3VsdCBiZXR3ZWVuIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcclxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0cmFuc2Zvcm0gc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZV1cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtU3RyaW5nKHgsIHksIHNjYWxlKSB7XHJcbiAgbGV0IHByb3BWYWx1ZSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsJHt5IHx8IDB9cHgsMClgO1xyXG5cclxuICBpZiAoc2NhbGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcHJvcFZhbHVlICs9IGAgc2NhbGUzZCgke3NjYWxlfSwke3NjYWxlfSwxKWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHJvcFZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHkgdHJhbnNmb3JtOnRyYW5zbGF0ZSh4LCB5KSBzY2FsZShzY2FsZSkgdG8gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVdXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIHgsIHksIHNjYWxlKSB7XHJcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2Zvcm1TdHJpbmcoeCwgeSwgc2NhbGUpO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0Q1NTRWFzaW5nID0gJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSc7XHJcblxyXG4vKipcclxuICogQXBwbHkgQ1NTIHRyYW5zaXRpb24gdG8gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BdIENTUyBwcm9wZXJ0eSB0byBhbmltYXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIGluIG1zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzZV0gQ1NTIGVhc2luZyBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvblN0eWxlKGVsLCBwcm9wLCBkdXJhdGlvbiwgZWFzZSkge1xyXG4gIC8vIGluT3V0OiAnY3ViaWMtYmV6aWVyKC40LCAwLCAuMjIsIDEpJywgLy8gZm9yIFwidG9nZ2xlIHN0YXRlXCIgdHJhbnNpdGlvbnNcclxuICAvLyBvdXQ6ICdjdWJpYy1iZXppZXIoMCwgMCwgLjIyLCAxKScsIC8vIGZvciBcInNob3dcIiB0cmFuc2l0aW9uc1xyXG4gIC8vIGluOiAnY3ViaWMtYmV6aWVyKC40LCAwLCAxLCAxKScvLyBmb3IgXCJoaWRlXCIgdHJhbnNpdGlvbnNcclxuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gcHJvcFxyXG4gICAgPyBgJHtwcm9wfSAke2R1cmF0aW9ufW1zICR7ZWFzZSB8fCBkZWZhdWx0Q1NTRWFzaW5nfWBcclxuICAgIDogJ25vbmUnO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHkgd2lkdGggYW5kIGhlaWdodCBDU1MgcHJvcGVydGllcyB0byBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB3XHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBoXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRXaWR0aEhlaWdodChlbCwgdywgaCkge1xyXG4gIGVsLnN0eWxlLndpZHRoID0gKHR5cGVvZiB3ID09PSAnbnVtYmVyJykgPyBgJHt3fXB4YCA6IHc7XHJcbiAgZWwuc3R5bGUuaGVpZ2h0ID0gKHR5cGVvZiBoID09PSAnbnVtYmVyJykgPyBgJHtofXB4YCA6IGg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvblN0eWxlKGVsKSB7XHJcbiAgc2V0VHJhbnNpdGlvblN0eWxlKGVsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQgfCB2b2lkPn1cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZUltYWdlKGltZykge1xyXG4gIGlmICgnZGVjb2RlJyBpbiBpbWcpIHtcclxuICAgIHJldHVybiBpbWcuZGVjb2RlKCkuY2F0Y2goKCkgPT4ge30pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbWcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XHJcbiAgICBpbWcub25lcnJvciA9IHJlamVjdDtcclxuICB9KTtcclxufVxyXG5cclxuLyoqIEB0eXBlZGVmIHtMT0FEX1NUQVRFW2tleW9mIExPQURfU1RBVEVdfSBMb2FkU3RhdGUgKi9cclxuLyoqIEB0eXBlIHt7IElETEU6ICdpZGxlJzsgTE9BRElORzogJ2xvYWRpbmcnOyBMT0FERUQ6ICdsb2FkZWQnOyBFUlJPUjogJ2Vycm9yJyB9fSAqL1xyXG5jb25zdCBMT0FEX1NUQVRFID0ge1xyXG4gIElETEU6ICdpZGxlJyxcclxuICBMT0FESU5HOiAnbG9hZGluZycsXHJcbiAgTE9BREVEOiAnbG9hZGVkJyxcclxuICBFUlJPUjogJ2Vycm9yJyxcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgY2xpY2sgb3Iga2V5ZG93biBldmVudCB3YXMgZGlzcGF0Y2hlZFxyXG4gKiB3aXRoIGEgc3BlY2lhbCBrZXkgb3IgdmlhIG1vdXNlIHdoZWVsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge01vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50fSBlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gc3BlY2lhbEtleVVzZWQoZSkge1xyXG4gIHJldHVybiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiA9PT0gMSkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLnNoaWZ0S2V5O1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYGdhbGxlcnlgIG9yIGBjaGlsZHJlbmAgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5FbGVtZW50UHJvdmlkZXJ9IFtvcHRpb25dXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGVnYWN5U2VsZWN0b3JdXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBEb2N1bWVudH0gW3BhcmVudF1cclxuICogQHJldHVybnMgSFRNTEVsZW1lbnRbXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RWxlbWVudHNGcm9tT3B0aW9uKG9wdGlvbiwgbGVnYWN5U2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50KSB7XHJcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xyXG4gIGxldCBlbGVtZW50cyA9IFtdO1xyXG5cclxuICBpZiAob3B0aW9uIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgZWxlbWVudHMgPSBbb3B0aW9uXTtcclxuICB9IGVsc2UgaWYgKG9wdGlvbiBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IEFycmF5LmlzQXJyYXkob3B0aW9uKSkge1xyXG4gICAgZWxlbWVudHMgPSBBcnJheS5mcm9tKG9wdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgPyBvcHRpb24gOiBsZWdhY3lTZWxlY3RvcjtcclxuICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICBlbGVtZW50cyA9IEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGJyb3dzZXIgaXMgU2FmYXJpXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgcmV0dXJuICEhKG5hdmlnYXRvci52ZW5kb3IgJiYgbmF2aWdhdG9yLnZlbmRvci5tYXRjaCgvYXBwbGUvaSkpO1xyXG59XG5cbi8vIERldGVjdCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnRcclxubGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG50cnkge1xyXG4gIC8qIEB0cy1pZ25vcmUgKi9cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcbiAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9KSk7XHJcbn0gY2F0Y2ggKGUpIHt9XHJcbi8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb29sSXRlbVxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnQgfCBXaW5kb3cgfCBEb2N1bWVudCB8IHVuZGVmaW5lZCB8IG51bGx9IHRhcmdldFxyXG4gKiBAcHJvcCB7c3RyaW5nfSB0eXBlXHJcbiAqIEBwcm9wIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBsaXN0ZW5lclxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW3Bhc3NpdmVdXHJcbiAqL1xyXG5cclxuY2xhc3MgRE9NRXZlbnRzIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1Bvb2xJdGVtW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wb29sID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsndGFyZ2V0J119IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3R5cGUnXX0gdHlwZSBDYW4gYmUgbXVsdGlwbGUsIHNlcGFyYXRlZCBieSBzcGFjZS5cclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWydsaXN0ZW5lciddfSBsaXN0ZW5lclxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3Bhc3NpdmUnXX0gW3Bhc3NpdmVdXHJcbiAgICovXHJcbiAgYWRkKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcclxuICAgIHRoaXMuX3RvZ2dsZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3RhcmdldCddfSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWyd0eXBlJ119IHR5cGVcclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWydsaXN0ZW5lciddfSBsaXN0ZW5lclxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3Bhc3NpdmUnXX0gW3Bhc3NpdmVdXHJcbiAgICovXHJcbiAgcmVtb3ZlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcclxuICAgIHRoaXMuX3RvZ2dsZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgYm91bmQgZXZlbnRzXHJcbiAgICovXHJcbiAgcmVtb3ZlQWxsKCkge1xyXG4gICAgdGhpcy5fcG9vbC5mb3JFYWNoKChwb29sSXRlbSkgPT4ge1xyXG4gICAgICB0aGlzLl90b2dnbGVMaXN0ZW5lcihcclxuICAgICAgICBwb29sSXRlbS50YXJnZXQsXHJcbiAgICAgICAgcG9vbEl0ZW0udHlwZSxcclxuICAgICAgICBwb29sSXRlbS5saXN0ZW5lcixcclxuICAgICAgICBwb29sSXRlbS5wYXNzaXZlLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgICAgdHJ1ZVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9wb29sID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG9yIHJlbW92ZXMgZXZlbnRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsndGFyZ2V0J119IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3R5cGUnXX0gdHlwZVxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ2xpc3RlbmVyJ119IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsncGFzc2l2ZSddfSBbcGFzc2l2ZV1cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bmJpbmRdIFdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFBvb2xdIFdoZXRoZXIgZXZlbnRzIHBvb2wgc2hvdWxkIGJlIHNraXBwZWRcclxuICAgKi9cclxuICBfdG9nZ2xlTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcGFzc2l2ZSwgdW5iaW5kLCBza2lwUG9vbCkge1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldGhvZE5hbWUgPSB1bmJpbmQgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnYWRkRXZlbnRMaXN0ZW5lcic7XHJcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcclxuICAgIHR5cGVzLmZvckVhY2goKGVUeXBlKSA9PiB7XHJcbiAgICAgIGlmIChlVHlwZSkge1xyXG4gICAgICAgIC8vIEV2ZW50cyBwb29sIGlzIHVzZWQgdG8gZWFzaWx5IHVuYmluZCBhbGwgZXZlbnRzIHdoZW4gUGhvdG9Td2lwZSBpcyBjbG9zZWQsXHJcbiAgICAgICAgLy8gc28gZGV2ZWxvcGVyIGRvZXNuJ3QgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XHJcbiAgICAgICAgaWYgKCFza2lwUG9vbCkge1xyXG4gICAgICAgICAgaWYgKHVuYmluZCkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgZXZlbnRzIHBvb2xcclxuICAgICAgICAgICAgdGhpcy5fcG9vbCA9IHRoaXMuX3Bvb2wuZmlsdGVyKChwb29sSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgIHJldHVybiBwb29sSXRlbS50eXBlICE9PSBlVHlwZVxyXG4gICAgICAgICAgICAgICAgfHwgcG9vbEl0ZW0ubGlzdGVuZXIgIT09IGxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICB8fCBwb29sSXRlbS50YXJnZXQgIT09IHRhcmdldDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGV2ZW50cyBwb29sXHJcbiAgICAgICAgICAgIHRoaXMuX3Bvb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgIHR5cGU6IGVUeXBlLFxyXG4gICAgICAgICAgICAgIGxpc3RlbmVyLFxyXG4gICAgICAgICAgICAgIHBhc3NpdmVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtb3N0IFBob3RvU3dpcGUgZXZlbnRzIGNhbGwgcHJldmVudERlZmF1bHQsXHJcbiAgICAgICAgLy8gYW5kIHdlIGRvIG5vdCBuZWVkIGJyb3dzZXIgdG8gc2Nyb2xsIHRoZSBwYWdlXHJcbiAgICAgICAgY29uc3QgZXZlbnRPcHRpb25zID0gc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiAocGFzc2l2ZSB8fCBmYWxzZSkgfSA6IGZhbHNlO1xyXG5cclxuICAgICAgICB0YXJnZXRbbWV0aG9kTmFtZV0oXHJcbiAgICAgICAgICBlVHlwZSxcclxuICAgICAgICAgIGxpc3RlbmVyLFxyXG4gICAgICAgICAgZXZlbnRPcHRpb25zXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUGhvdG9Td2lwZU9wdGlvbnN9IFBob3RvU3dpcGVPcHRpb25zICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL2Jhc2UuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlQmFzZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7UGhvdG9Td2lwZU9wdGlvbnN9IG9wdGlvbnNcclxuICogQHBhcmFtIHtQaG90b1N3aXBlQmFzZX0gcHN3cFxyXG4gKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUob3B0aW9ucywgcHN3cCkge1xyXG4gIGlmIChvcHRpb25zLmdldFZpZXdwb3J0U2l6ZUZuKSB7XHJcbiAgICBjb25zdCBuZXdWaWV3cG9ydFNpemUgPSBvcHRpb25zLmdldFZpZXdwb3J0U2l6ZUZuKG9wdGlvbnMsIHBzd3ApO1xyXG4gICAgaWYgKG5ld1ZpZXdwb3J0U2l6ZSkge1xyXG4gICAgICByZXR1cm4gbmV3Vmlld3BvcnRTaXplO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcclxuXHJcbiAgICAvLyBUT0RPOiBoZWlnaHQgb24gbW9iaWxlIGlzIHZlcnkgaW5jb3Npc3RlbnQgZHVlIHRvIHRvb2xiYXJcclxuICAgIC8vIGZpbmQgYSB3YXkgdG8gaW1wcm92ZSB0aGlzXHJcbiAgICAvL1xyXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIHdlbGxcclxuICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgcGFkZGluZyBvcHRpb24uXHJcbiAqIFN1cHBvcnRlZCBmb3JtYXRzOlxyXG4gKlxyXG4gKiAvLyBPYmplY3RcclxuICogcGFkZGluZzoge1xyXG4gKiAgdG9wOiAwLFxyXG4gKiAgYm90dG9tOiAwLFxyXG4gKiAgbGVmdDogMCxcclxuICogIHJpZ2h0OiAwXHJcbiAqIH1cclxuICpcclxuICogLy8gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9iamVjdFxyXG4gKiBwYWRkaW5nRm46ICh2aWV3cG9ydFNpemUsIGl0ZW1EYXRhLCBpbmRleCkgPT4ge1xyXG4gKiAgcmV0dXJuIHtcclxuICogICAgdG9wOiAwLFxyXG4gKiAgICBib3R0b206IDAsXHJcbiAqICAgIGxlZnQ6IDAsXHJcbiAqICAgIHJpZ2h0OiAwXHJcbiAqICB9O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIExlZ2FjeSB2YXJpYW50XHJcbiAqIHBhZGRpbmdMZWZ0OiAwLFxyXG4gKiBwYWRkaW5nUmlnaHQ6IDAsXHJcbiAqIHBhZGRpbmdUb3A6IDAsXHJcbiAqIHBhZGRpbmdCb3R0b206IDAsXHJcbiAqXHJcbiAqIEBwYXJhbSB7J2xlZnQnIHwgJ3RvcCcgfCAnYm90dG9tJyB8ICdyaWdodCd9IHByb3BcclxuICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9ucyBQaG90b1N3aXBlIG9wdGlvbnNcclxuICogQHBhcmFtIHtQb2ludH0gdmlld3BvcnRTaXplIFBob3RvU3dpcGUgdmlld3BvcnQgc2l6ZSwgZm9yIGV4YW1wbGU6IHsgeDo4MDAsIHk6NjAwIH1cclxuICogQHBhcmFtIHtTbGlkZURhdGF9IGl0ZW1EYXRhIERhdGEgYWJvdXQgdGhlIHNsaWRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBTbGlkZSBpbmRleFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VQYWRkaW5nT3B0aW9uKHByb3AsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSB7XHJcbiAgbGV0IHBhZGRpbmdWYWx1ZSA9IDA7XHJcblxyXG4gIGlmIChvcHRpb25zLnBhZGRpbmdGbikge1xyXG4gICAgcGFkZGluZ1ZhbHVlID0gb3B0aW9ucy5wYWRkaW5nRm4odmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpW3Byb3BdO1xyXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XHJcbiAgICBwYWRkaW5nVmFsdWUgPSBvcHRpb25zLnBhZGRpbmdbcHJvcF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGxlZ2FjeVByb3BOYW1lID0gJ3BhZGRpbmcnICsgcHJvcFswXS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGlmIChvcHRpb25zW2xlZ2FjeVByb3BOYW1lXSkge1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgIHBhZGRpbmdWYWx1ZSA9IG9wdGlvbnNbbGVnYWN5UHJvcE5hbWVdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE51bWJlcihwYWRkaW5nVmFsdWUpIHx8IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHZpZXdwb3J0U2l6ZVxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGFcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqIEByZXR1cm5zIHtQb2ludH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhbkFyZWFTaXplKG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHZpZXdwb3J0U2l6ZS54XHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdsZWZ0Jywgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpXHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdyaWdodCcsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSxcclxuICAgIHk6IHZpZXdwb3J0U2l6ZS55XHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCd0b3AnLCBvcHRpb25zLCB2aWV3cG9ydFNpemUsIGl0ZW1EYXRhLCBpbmRleClcclxuICAgICAgLSBwYXJzZVBhZGRpbmdPcHRpb24oJ2JvdHRvbScsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KVxyXG4gIH07XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge1JlY29yZDxBeGlzLCBudW1iZXI+fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYgeyd4JyB8ICd5J30gQXhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgbWluaW11bSwgbWF4aW11bSBhbmQgaW5pdGlhbCAoY2VudGVyKSBib3VuZHMgb2YgYSBzbGlkZVxyXG4gKi9cclxuY2xhc3MgUGFuQm91bmRzIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlfSBzbGlkZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHNsaWRlKSB7XHJcbiAgICB0aGlzLnNsaWRlID0gc2xpZGU7XHJcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSAxO1xyXG4gICAgdGhpcy5jZW50ZXIgPSAvKiogQHR5cGUge1BvaW50fSAqLyB7IHg6IDAsIHk6IDAgfTtcclxuICAgIHRoaXMubWF4ID0gLyoqIEB0eXBlIHtQb2ludH0gKi8geyB4OiAwLCB5OiAwIH07XHJcbiAgICB0aGlzLm1pbiA9IC8qKiBAdHlwZSB7UG9pbnR9ICovIHsgeDogMCwgeTogMCB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogX2dldEl0ZW1Cb3VuZHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyWm9vbUxldmVsXHJcbiAgICovXHJcbiAgdXBkYXRlKGN1cnJab29tTGV2ZWwpIHtcclxuICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9IGN1cnJab29tTGV2ZWw7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNsaWRlLndpZHRoKSB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUF4aXMoJ3gnKTtcclxuICAgICAgdGhpcy5fdXBkYXRlQXhpcygneScpO1xyXG4gICAgICB0aGlzLnNsaWRlLnBzd3AuZGlzcGF0Y2goJ2NhbGNCb3VuZHMnLCB7IHNsaWRlOiB0aGlzLnNsaWRlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogX2NhbGN1bGF0ZUl0ZW1Cb3VuZHNGb3JBeGlzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0F4aXN9IGF4aXNcclxuICAgKi9cclxuICBfdXBkYXRlQXhpcyhheGlzKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXMuc2xpZGU7XHJcbiAgICBjb25zdCBlbFNpemUgPSB0aGlzLnNsaWRlW2F4aXMgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gKiB0aGlzLmN1cnJab29tTGV2ZWw7XHJcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IGF4aXMgPT09ICd4JyA/ICdsZWZ0JyA6ICd0b3AnO1xyXG4gICAgY29uc3QgcGFkZGluZyA9IHBhcnNlUGFkZGluZ09wdGlvbihcclxuICAgICAgcGFkZGluZ1Byb3AsXHJcbiAgICAgIHBzd3Aub3B0aW9ucyxcclxuICAgICAgcHN3cC52aWV3cG9ydFNpemUsXHJcbiAgICAgIHRoaXMuc2xpZGUuZGF0YSxcclxuICAgICAgdGhpcy5zbGlkZS5pbmRleFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwYW5BcmVhU2l6ZSA9IHRoaXMuc2xpZGUucGFuQXJlYVNpemVbYXhpc107XHJcblxyXG4gICAgLy8gRGVmYXVsdCBwb3NpdGlvbiBvZiBlbGVtZW50LlxyXG4gICAgLy8gQnkgZGVmYXVsdCwgaXQgaXMgY2VudGVyIG9mIHZpZXdwb3J0OlxyXG4gICAgdGhpcy5jZW50ZXJbYXhpc10gPSBNYXRoLnJvdW5kKChwYW5BcmVhU2l6ZSAtIGVsU2l6ZSkgLyAyKSArIHBhZGRpbmc7XHJcblxyXG4gICAgLy8gbWF4aW11bSBwYW4gcG9zaXRpb25cclxuICAgIHRoaXMubWF4W2F4aXNdID0gKGVsU2l6ZSA+IHBhbkFyZWFTaXplKVxyXG4gICAgICA/IE1hdGgucm91bmQocGFuQXJlYVNpemUgLSBlbFNpemUpICsgcGFkZGluZ1xyXG4gICAgICA6IHRoaXMuY2VudGVyW2F4aXNdO1xyXG5cclxuICAgIC8vIG1pbmltdW0gcGFuIHBvc2l0aW9uXHJcbiAgICB0aGlzLm1pbltheGlzXSA9IChlbFNpemUgPiBwYW5BcmVhU2l6ZSlcclxuICAgICAgPyBwYWRkaW5nXHJcbiAgICAgIDogdGhpcy5jZW50ZXJbYXhpc107XHJcbiAgfVxyXG5cclxuICAvLyBfZ2V0WmVyb0JvdW5kc1xyXG4gIHJlc2V0KCkge1xyXG4gICAgdGhpcy5jZW50ZXIueCA9IDA7XHJcbiAgICB0aGlzLmNlbnRlci55ID0gMDtcclxuICAgIHRoaXMubWF4LnggPSAwO1xyXG4gICAgdGhpcy5tYXgueSA9IDA7XHJcbiAgICB0aGlzLm1pbi54ID0gMDtcclxuICAgIHRoaXMubWluLnkgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29ycmVjdCBwYW4gcG9zaXRpb24gaWYgaXQncyBiZXlvbmQgdGhlIGJvdW5kc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBeGlzfSBheGlzIHggb3IgeVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYW5PZmZzZXRcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGNvcnJlY3RQYW4oYXhpcywgcGFuT2Zmc2V0KSB7IC8vIGNoZWNrUGFuQm91bmRzXHJcbiAgICByZXR1cm4gY2xhbXAocGFuT2Zmc2V0LCB0aGlzLm1heFtheGlzXSwgdGhpcy5taW5bYXhpc10pO1xyXG4gIH1cclxufVxuXG5jb25zdCBNQVhfSU1BR0VfV0lEVEggPSA0MDAwO1xyXG5cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUGhvdG9Td2lwZU9wdGlvbnN9IFBob3RvU3dpcGVPcHRpb25zICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUG9pbnR9IFBvaW50ICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcblxyXG4vKiogQHR5cGVkZWYgeydmaXQnIHwgJ2ZpbGwnIHwgbnVtYmVyIHwgKCh6b29tTGV2ZWxPYmplY3Q6IFpvb21MZXZlbCkgPT4gbnVtYmVyKX0gWm9vbUxldmVsT3B0aW9uICovXHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB6b29tIGxldmVscyBmb3Igc3BlY2lmaWMgc2xpZGUuXHJcbiAqIERlcGVuZHMgb24gdmlld3BvcnQgc2l6ZSBhbmQgaW1hZ2Ugc2l6ZS5cclxuICovXHJcbmNsYXNzIFpvb21MZXZlbCB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9ucyBQaG90b1N3aXBlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgU2xpZGUgZGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBTbGlkZSBpbmRleFxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gW3Bzd3BdIFBob3RvU3dpcGUgaW5zdGFuY2UsIGNhbiBiZSB1bmRlZmluZWQgaWYgbm90IGluaXRpYWxpemVkIHlldFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGl0ZW1EYXRhLCBpbmRleCwgcHN3cCkge1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLml0ZW1EYXRhID0gaXRlbURhdGE7XHJcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAvKiogQHR5cGUgeyBQb2ludCB8IG51bGwgfSAqL1xyXG4gICAgdGhpcy5wYW5BcmVhU2l6ZSA9IG51bGw7XHJcbiAgICAvKiogQHR5cGUgeyBQb2ludCB8IG51bGwgfSAqL1xyXG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IG51bGw7XHJcbiAgICB0aGlzLmZpdCA9IDE7XHJcbiAgICB0aGlzLmZpbGwgPSAxO1xyXG4gICAgdGhpcy52RmlsbCA9IDE7XHJcbiAgICB0aGlzLmluaXRpYWwgPSAxO1xyXG4gICAgdGhpcy5zZWNvbmRhcnkgPSAxO1xyXG4gICAgdGhpcy5tYXggPSAxO1xyXG4gICAgdGhpcy5taW4gPSAxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGluaXRpYWwsIHNlY29uZGFyeSBhbmQgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgc3BlY2lmaWVkIHNsaWRlLlxyXG4gICAqXHJcbiAgICogSXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGVpdGhlciBpbWFnZSBvciB2aWV3cG9ydCBzaXplIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0XHJcbiAgICogQHBhcmFtIHtQb2ludH0gcGFuQXJlYVNpemVcclxuICAgKi9cclxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgcGFuQXJlYVNpemUpIHtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHsgeDogbWF4V2lkdGgsIHk6IG1heEhlaWdodCB9O1xyXG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xyXG4gICAgdGhpcy5wYW5BcmVhU2l6ZSA9IHBhbkFyZWFTaXplO1xyXG5cclxuICAgIGNvbnN0IGhSYXRpbyA9IHBhbkFyZWFTaXplLnggLyBlbGVtZW50U2l6ZS54O1xyXG4gICAgY29uc3QgdlJhdGlvID0gcGFuQXJlYVNpemUueSAvIGVsZW1lbnRTaXplLnk7XHJcblxyXG4gICAgdGhpcy5maXQgPSBNYXRoLm1pbigxLCBoUmF0aW8gPCB2UmF0aW8gPyBoUmF0aW8gOiB2UmF0aW8pO1xyXG4gICAgdGhpcy5maWxsID0gTWF0aC5taW4oMSwgaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvKTtcclxuXHJcbiAgICAvLyB6b29tLnZGaWxsIGRlZmluZXMgem9vbSBsZXZlbCBvZiB0aGUgaW1hZ2VcclxuICAgIC8vIHdoZW4gaXQgaGFzIDEwMCUgb2Ygdmlld3BvcnQgdmVydGljYWwgc3BhY2UgKGhlaWdodClcclxuICAgIHRoaXMudkZpbGwgPSBNYXRoLm1pbigxLCB2UmF0aW8pO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbCA9IHRoaXMuX2dldEluaXRpYWwoKTtcclxuICAgIHRoaXMuc2Vjb25kYXJ5ID0gdGhpcy5fZ2V0U2Vjb25kYXJ5KCk7XHJcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KFxyXG4gICAgICB0aGlzLmluaXRpYWwsXHJcbiAgICAgIHRoaXMuc2Vjb25kYXJ5LFxyXG4gICAgICB0aGlzLl9nZXRNYXgoKVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKFxyXG4gICAgICB0aGlzLmZpdCxcclxuICAgICAgdGhpcy5pbml0aWFsLFxyXG4gICAgICB0aGlzLnNlY29uZGFyeVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodGhpcy5wc3dwKSB7XHJcbiAgICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnem9vbUxldmVsc1VwZGF0ZScsIHsgem9vbUxldmVsczogdGhpcywgc2xpZGVEYXRhOiB0aGlzLml0ZW1EYXRhIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIHVzZXItZGVmaW5lZCB6b29tIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHsnaW5pdGlhbCcgfCAnc2Vjb25kYXJ5JyB8ICdtYXgnfSBvcHRpb25QcmVmaXggWm9vbSBsZXZlbCBvcHRpb24gcHJlZml4IChpbml0aWFsLCBzZWNvbmRhcnksIG1heClcclxuICAgKiBAcmV0dXJucyB7IG51bWJlciB8IHVuZGVmaW5lZCB9XHJcbiAgICovXHJcbiAgX3BhcnNlWm9vbUxldmVsT3B0aW9uKG9wdGlvblByZWZpeCkge1xyXG4gICAgY29uc3Qgb3B0aW9uTmFtZSA9IC8qKiBAdHlwZSB7J2luaXRpYWxab29tTGV2ZWwnIHwgJ3NlY29uZGFyeVpvb21MZXZlbCcgfCAnbWF4Wm9vbUxldmVsJ30gKi8gKFxyXG4gICAgICBvcHRpb25QcmVmaXggKyAnWm9vbUxldmVsJ1xyXG4gICAgKTtcclxuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gdGhpcy5vcHRpb25zW29wdGlvbk5hbWVdO1xyXG5cclxuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIG9wdGlvblZhbHVlKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gJ2ZpbGwnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSAnZml0Jykge1xyXG4gICAgICByZXR1cm4gdGhpcy5maXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE51bWJlcihvcHRpb25WYWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgem9vbSBsZXZlbCB0byB3aGljaCBpbWFnZSB3aWxsIGJlIHpvb21lZCBhZnRlciBkb3VibGUtdGFwIGdlc3R1cmUsXHJcbiAgICogb3Igd2hlbiB1c2VyIGNsaWNrcyBvbiB6b29tIGljb24sXHJcbiAgICogb3IgbW91c2UtY2xpY2sgb24gaW1hZ2UgaXRzZWxmLlxyXG4gICAqIElmIHlvdSByZXR1cm4gMSBpbWFnZSB3aWxsIGJlIHpvb21lZCB0byBpdHMgb3JpZ2luYWwgc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIF9nZXRTZWNvbmRhcnkoKSB7XHJcbiAgICBsZXQgY3Vyclpvb21MZXZlbCA9IHRoaXMuX3BhcnNlWm9vbUxldmVsT3B0aW9uKCdzZWNvbmRhcnknKTtcclxuXHJcbiAgICBpZiAoY3Vyclpvb21MZXZlbCkge1xyXG4gICAgICByZXR1cm4gY3Vyclpvb21MZXZlbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAzeCBvZiBcImZpdFwiIHN0YXRlLCBidXQgbm90IGxhcmdlciB0aGFuIG9yaWdpbmFsXHJcbiAgICBjdXJyWm9vbUxldmVsID0gTWF0aC5taW4oMSwgdGhpcy5maXQgKiAzKTtcclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50U2l6ZSAmJiBjdXJyWm9vbUxldmVsICogdGhpcy5lbGVtZW50U2l6ZS54ID4gTUFYX0lNQUdFX1dJRFRIKSB7XHJcbiAgICAgIGN1cnJab29tTGV2ZWwgPSBNQVhfSU1BR0VfV0lEVEggLyB0aGlzLmVsZW1lbnRTaXplLng7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnJab29tTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgaW5pdGlhbCBpbWFnZSB6b29tIGxldmVsLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldEluaXRpYWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyc2Vab29tTGV2ZWxPcHRpb24oJ2luaXRpYWwnKSB8fCB0aGlzLmZpdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1heGltdW0gem9vbSBsZXZlbCB3aGVuIHVzZXIgem9vbXNcclxuICAgKiB2aWEgem9vbS9waW5jaCBnZXN0dXJlLFxyXG4gICAqIHZpYSBjbWQvY3RybC13aGVlbCBvciB2aWEgdHJhY2twYWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0TWF4KCkge1xyXG4gICAgLy8gbWF4IHpvb20gbGV2ZWwgaXMgeDQgZnJvbSBcImZpdCBzdGF0ZVwiLFxyXG4gICAgLy8gdXNlZCBmb3Igem9vbSBnZXN0dXJlIGFuZCBjdHJsL3RyYWNrcGFkIHpvb21cclxuICAgIHJldHVybiB0aGlzLl9wYXJzZVpvb21MZXZlbE9wdGlvbignbWF4JykgfHwgTWF0aC5tYXgoMSwgdGhpcy5maXQgKiA0KTtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcblxyXG4vKipcclxuICogUmVuZGVycyBhbmQgYWxsb3dzIHRvIGNvbnRyb2wgYSBzaW5nbGUgc2xpZGVcclxuICovXHJcbmNsYXNzIFNsaWRlIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gZGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGluZGV4LCBwc3dwKSB7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuICAgIHRoaXMuaXNBY3RpdmUgPSAoaW5kZXggPT09IHBzd3AuY3VyckluZGV4KTtcclxuICAgIHRoaXMuY3VycmVudFJlc29sdXRpb24gPSAwO1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMucGFuQXJlYVNpemUgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnBhbiA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIHRoaXMuaXNGaXJzdFNsaWRlID0gKHRoaXMuaXNBY3RpdmUgJiYgIXBzd3Aub3BlbmVyLmlzT3Blbik7XHJcblxyXG4gICAgdGhpcy56b29tTGV2ZWxzID0gbmV3IFpvb21MZXZlbChwc3dwLm9wdGlvbnMsIGRhdGEsIGluZGV4LCBwc3dwKTtcclxuXHJcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ2dldHRpbmdEYXRhJywge1xyXG4gICAgICBzbGlkZTogdGhpcyxcclxuICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgICBpbmRleFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50ID0gdGhpcy5wc3dwLmNvbnRlbnRMb2FkZXIuZ2V0Q29udGVudEJ5U2xpZGUodGhpcyk7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX3pvb20td3JhcCcsICdkaXYnKTtcclxuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xyXG4gICAgdGhpcy5ob2xkZXJFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSAxO1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jb250ZW50LndpZHRoO1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGVudC5oZWlnaHQ7XHJcbiAgICB0aGlzLmhlYXZ5QXBwZW5kZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuYm91bmRzID0gbmV3IFBhbkJvdW5kcyh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnByZXZEaXNwbGF5ZWRXaWR0aCA9IC0xO1xyXG4gICAgdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0ID0gLTE7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZUluaXQnLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhpcyBzbGlkZSBpcyBhY3RpdmUvY3VycmVudC92aXNpYmxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWN0aXZlXHJcbiAgICovXHJcbiAgc2V0SXNBY3RpdmUoaXNBY3RpdmUpIHtcclxuICAgIGlmIChpc0FjdGl2ZSAmJiAhdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAvLyBzbGlkZSBqdXN0IGJlY2FtZSBhY3RpdmVcclxuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgfSBlbHNlIGlmICghaXNBY3RpdmUgJiYgdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAvLyBzbGlkZSBqdXN0IGJlY2FtZSBub24tYWN0aXZlXHJcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kcyBzbGlkZSBjb250ZW50IHRvIERPTVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaG9sZGVyRWxlbWVudFxyXG4gICAqL1xyXG4gIGFwcGVuZChob2xkZXJFbGVtZW50KSB7XHJcbiAgICB0aGlzLmhvbGRlckVsZW1lbnQgPSBob2xkZXJFbGVtZW50O1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG5cclxuICAgIC8vIFNsaWRlIGFwcGVuZGVkIHRvIERPTVxyXG4gICAgaWYgKCF0aGlzLmRhdGEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xyXG5cclxuICAgIHRoaXMubG9hZCgpO1xyXG4gICAgdGhpcy51cGRhdGVDb250ZW50U2l6ZSgpO1xyXG4gICAgdGhpcy5hcHBlbmRIZWF2eSgpO1xyXG5cclxuICAgIHRoaXMuaG9sZGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy56b29tQW5kUGFuVG9Jbml0aWFsKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdmaXJzdFpvb21QYW4nLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG5cclxuICAgIHRoaXMuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnYWZ0ZXJTZXRDb250ZW50JywgeyBzbGlkZTogdGhpcyB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkKCkge1xyXG4gICAgdGhpcy5jb250ZW50LmxvYWQoZmFsc2UpO1xyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZUxvYWQnLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kIFwiaGVhdnlcIiBET00gZWxlbWVudHNcclxuICAgKlxyXG4gICAqIFRoaXMgbWF5IGRlcGVuZCBvbiBhIHR5cGUgb2Ygc2xpZGUsXHJcbiAgICogYnV0IGdlbmVyYWxseSB0aGVzZSBhcmUgbGFyZ2UgaW1hZ2VzLlxyXG4gICAqL1xyXG4gIGFwcGVuZEhlYXZ5KCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgYXBwZW5kSGVhdnlOZWFyYnkgPSB0cnVlOyAvLyB0b2RvXHJcblxyXG4gICAgLy8gQXZvaWQgYXBwZW5kaW5nIGhlYXZ5IGVsZW1lbnRzIGR1cmluZyBhbmltYXRpb25zXHJcbiAgICBpZiAodGhpcy5oZWF2eUFwcGVuZGVkXHJcbiAgICAgICAgfHwgIXBzd3Aub3BlbmVyLmlzT3BlblxyXG4gICAgICAgIHx8IHBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKVxyXG4gICAgICAgIHx8ICghdGhpcy5pc0FjdGl2ZSAmJiAhYXBwZW5kSGVhdnlOZWFyYnkpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wc3dwLmRpc3BhdGNoKCdhcHBlbmRIZWF2eScsIHsgc2xpZGU6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5oZWF2eUFwcGVuZGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnQuYXBwZW5kKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdhcHBlbmRIZWF2eUNvbnRlbnQnLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyBzbGlkZSBpcyBhY3RpdmUgKHNlbGVjdGVkKS5cclxuICAgKlxyXG4gICAqIElmIGl0J3MgcGFydCBvZiBvcGVuaW5nL2Nsb3NpbmcgdHJhbnNpdGlvbiAtXHJcbiAgICogYWN0aXZhdGUoKSB3aWxsIHRyaWdnZXIgYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgZW5kZWQuXHJcbiAgICovXHJcbiAgYWN0aXZhdGUoKSB7XHJcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgIHRoaXMuYXBwZW5kSGVhdnkoKTtcclxuICAgIHRoaXMuY29udGVudC5hY3RpdmF0ZSgpO1xyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZUFjdGl2YXRlJywgeyBzbGlkZTogdGhpcyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoaXMgc2xpZGUgYmVjb21lcyBpbmFjdGl2ZS5cclxuICAgKlxyXG4gICAqIFNsaWRlIGNhbiBiZWNvbWUgaW5hY3RpdmUgb25seSBhZnRlciBpdCB3YXMgYWN0aXZlLlxyXG4gICAqL1xyXG4gIGRlYWN0aXZhdGUoKSB7XHJcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB0aGlzLmNvbnRlbnQuZGVhY3RpdmF0ZSgpO1xyXG5cclxuICAgIGlmICh0aGlzLmN1cnJab29tTGV2ZWwgIT09IHRoaXMuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgIC8vIGFsbG93IGZpbHRlcmluZ1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXNldCB6b29tIGxldmVsXHJcbiAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gMDtcclxuICAgIHRoaXMuem9vbUFuZFBhblRvSW5pdGlhbCgpO1xyXG4gICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZURlYWN0aXZhdGUnLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNsaWRlIHNob3VsZCBkZXN0cm95IGl0c2VsZiwgaXQgd2lsbCBuZXZlciBiZSB1c2VkIGFnYWluLlxyXG4gICAqICh1bmJpbmQgYWxsIGV2ZW50cyBhbmQgZGVzdHJveSBpbnRlcm5hbCBjb21wb25lbnRzKVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmNvbnRlbnQuaGFzU2xpZGUgPSBmYWxzZTtcclxuICAgIHRoaXMuY29udGVudC5yZW1vdmUoKTtcclxuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZURlc3Ryb3knLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVzaXplKCkge1xyXG4gICAgaWYgKHRoaXMuY3Vyclpvb21MZXZlbCA9PT0gdGhpcy56b29tTGV2ZWxzLmluaXRpYWwgfHwgIXRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgLy8gS2VlcCBpbml0aWFsIHpvb20gbGV2ZWwgaWYgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLFxyXG4gICAgICAvLyBhcyB3ZWxsIGFzIHdoZW4gdGhpcyBzbGlkZSBpcyBub3QgYWN0aXZlXHJcblxyXG4gICAgICAvLyBSZXNldCBwb3NpdGlvbiBhbmQgc2NhbGUgdG8gb3JpZ2luYWwgc3RhdGVcclxuICAgICAgdGhpcy5jYWxjdWxhdGVTaXplKCk7XHJcbiAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb24gPSAwO1xyXG4gICAgICB0aGlzLnpvb21BbmRQYW5Ub0luaXRpYWwoKTtcclxuICAgICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29udGVudFNpemUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHJlYWRqdXN0IHBhbiBwb3NpdGlvbiBpZiBpdCdzIGJleW9uZCB0aGUgYm91bmRzXHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xyXG4gICAgICB0aGlzLmJvdW5kcy51cGRhdGUodGhpcy5jdXJyWm9vbUxldmVsKTtcclxuICAgICAgdGhpcy5wYW5Ubyh0aGlzLnBhbi54LCB0aGlzLnBhbi55KTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBBcHBseSBzaXplIHRvIGN1cnJlbnQgc2xpZGUgY29udGVudCxcclxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCByZXNvbHV0aW9uIGFuZCBzY2FsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBpZiBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGV2ZW4gaWYgZGltZW5zaW9ucyB3ZXJlbid0IGNoYW5nZWRcclxuICAgKi9cclxuICB1cGRhdGVDb250ZW50U2l6ZShmb3JjZSkge1xyXG4gICAgLy8gVXNlIGluaXRpYWwgem9vbSBsZXZlbFxyXG4gICAgLy8gaWYgcmVzb2x1dGlvbiBpcyBub3QgZGVmaW5lZCAodXNlciBkaWRuJ3Qgem9vbSB5ZXQpXHJcbiAgICBjb25zdCBzY2FsZU11bHRpcGxpZXIgPSB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uIHx8IHRoaXMuem9vbUxldmVscy5pbml0aWFsO1xyXG5cclxuICAgIGlmICghc2NhbGVNdWx0aXBsaWVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHNjYWxlTXVsdGlwbGllcikgfHwgdGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHNjYWxlTXVsdGlwbGllcikgfHwgdGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS55O1xyXG5cclxuICAgIGlmICghdGhpcy5zaXplQ2hhbmdlZCh3aWR0aCwgaGVpZ2h0KSAmJiAhZm9yY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jb250ZW50LnNldERpc3BsYXllZFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICovXHJcbiAgc2l6ZUNoYW5nZWQod2lkdGgsIGhlaWdodCkge1xyXG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLnByZXZEaXNwbGF5ZWRXaWR0aFxyXG4gICAgICAgIHx8IGhlaWdodCAhPT0gdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMucHJldkRpc3BsYXllZFdpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRoaXMucHJldkRpc3BsYXllZEhlaWdodCA9IGhlaWdodDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTERpdkVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xyXG4gIGdldFBsYWNlaG9sZGVyRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQucGxhY2Vob2xkZXI/LmVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBab29tIGN1cnJlbnQgc2xpZGUgaW1hZ2UgdG8uLi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0Wm9vbUxldmVsIERlc3RpbmF0aW9uIHpvb20gbGV2ZWwuXHJcbiAgICogQHBhcmFtIHtQb2ludH0gW2NlbnRlclBvaW50XVxyXG4gICAqIFRyYW5zZm9ybSBvcmlnaW4gY2VudGVyIHBvaW50LCBvciBmYWxzZSBpZiB2aWV3cG9ydCBjZW50ZXIgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBmYWxzZX0gW3RyYW5zaXRpb25EdXJhdGlvbl0gVHJhbnNpdGlvbiBkdXJhdGlvbiwgbWF5IGJlIHNldCB0byAwLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZUJvdW5kc10gTWluaW11bSBhbmQgbWF4aW11bSB6b29tIGxldmVscyB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICovXHJcbiAgem9vbVRvKGRlc3Rab29tTGV2ZWwsIGNlbnRlclBvaW50LCB0cmFuc2l0aW9uRHVyYXRpb24sIGlnbm9yZUJvdW5kcykge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgaWYgKCF0aGlzLmlzWm9vbWFibGUoKVxyXG4gICAgICAgIHx8IHBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaCgnYmVmb3JlWm9vbVRvJywge1xyXG4gICAgICBkZXN0Wm9vbUxldmVsLCBjZW50ZXJQb2ludCwgdHJhbnNpdGlvbkR1cmF0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzdG9wIGFsbCBwYW4gYW5kIHpvb20gdHJhbnNpdGlvbnNcclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsUGFuKCk7XHJcblxyXG4gICAgLy8gaWYgKCFjZW50ZXJQb2ludCkge1xyXG4gICAgLy8gICBjZW50ZXJQb2ludCA9IHBzd3AuZ2V0Vmlld3BvcnRDZW50ZXJQb2ludCgpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGNvbnN0IHByZXZab29tTGV2ZWwgPSB0aGlzLmN1cnJab29tTGV2ZWw7XHJcblxyXG4gICAgaWYgKCFpZ25vcmVCb3VuZHMpIHtcclxuICAgICAgZGVzdFpvb21MZXZlbCA9IGNsYW1wKGRlc3Rab29tTGV2ZWwsIHRoaXMuem9vbUxldmVscy5taW4sIHRoaXMuem9vbUxldmVscy5tYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmICh0cmFuc2l0aW9uRHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLnBzd3Aub3B0aW9ucy56b29tQW5pbWF0aW9uRHVyYXRpb247XHJcbiAgICAvLyB9XHJcblxyXG4gICAgdGhpcy5zZXRab29tTGV2ZWwoZGVzdFpvb21MZXZlbCk7XHJcbiAgICB0aGlzLnBhbi54ID0gdGhpcy5jYWxjdWxhdGVab29tVG9QYW5PZmZzZXQoJ3gnLCBjZW50ZXJQb2ludCwgcHJldlpvb21MZXZlbCk7XHJcbiAgICB0aGlzLnBhbi55ID0gdGhpcy5jYWxjdWxhdGVab29tVG9QYW5PZmZzZXQoJ3knLCBjZW50ZXJQb2ludCwgcHJldlpvb21MZXZlbCk7XHJcbiAgICByb3VuZFBvaW50KHRoaXMucGFuKTtcclxuXHJcbiAgICBjb25zdCBmaW5pc2hUcmFuc2l0aW9uID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9zZXRSZXNvbHV0aW9uKGRlc3Rab29tTGV2ZWwpO1xyXG4gICAgICB0aGlzLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcclxuICAgICAgZmluaXNoVHJhbnNpdGlvbigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHN3cC5hbmltYXRpb25zLnN0YXJ0VHJhbnNpdGlvbih7XHJcbiAgICAgICAgaXNQYW46IHRydWUsXHJcbiAgICAgICAgbmFtZTogJ3pvb21UbycsXHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmNvbnRhaW5lcixcclxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybSgpLFxyXG4gICAgICAgIG9uQ29tcGxldGU6IGZpbmlzaFRyYW5zaXRpb24sXHJcbiAgICAgICAgZHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbixcclxuICAgICAgICBlYXNpbmc6IHBzd3Aub3B0aW9ucy5lYXNpbmdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50fSBbY2VudGVyUG9pbnRdXHJcbiAgICovXHJcbiAgdG9nZ2xlWm9vbShjZW50ZXJQb2ludCkge1xyXG4gICAgdGhpcy56b29tVG8oXHJcbiAgICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9PT0gdGhpcy56b29tTGV2ZWxzLmluaXRpYWxcclxuICAgICAgICA/IHRoaXMuem9vbUxldmVscy5zZWNvbmRhcnkgOiB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbCxcclxuICAgICAgY2VudGVyUG9pbnQsXHJcbiAgICAgIHRoaXMucHN3cC5vcHRpb25zLnpvb21BbmltYXRpb25EdXJhdGlvblxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgem9vbSBsZXZlbCBwcm9wZXJ0eSBhbmQgcmVjYWxjdWxhdGVzIG5ldyBwYW4gYm91bmRzLFxyXG4gICAqIHVubGlrZSB6b29tVG8gaXQgZG9lcyBub3QgYXBwbHkgdHJhbnNmb3JtICh1c2UgYXBwbHlDdXJyZW50Wm9vbVBhbilcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyWm9vbUxldmVsXHJcbiAgICovXHJcbiAgc2V0Wm9vbUxldmVsKGN1cnJab29tTGV2ZWwpIHtcclxuICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9IGN1cnJab29tTGV2ZWw7XHJcbiAgICB0aGlzLmJvdW5kcy51cGRhdGUodGhpcy5jdXJyWm9vbUxldmVsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBwYW4gcG9zaXRpb24gYWZ0ZXIgem9vbSBhdCBhIGdpdmVuIGBwb2ludGAuXHJcbiAgICpcclxuICAgKiBBbHdheXMgY2FsbCBzZXRab29tTGV2ZWwobmV3Wm9vbUxldmVsKSBiZWZvcmVoYW5kIHRvIHJlY2FsY3VsYXRlXHJcbiAgICogcGFuIGJvdW5kcyBhY2NvcmRpbmcgdG8gdGhlIG5ldyB6b29tIGxldmVsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsneCcgfCAneSd9IGF4aXNcclxuICAgKiBAcGFyYW0ge1BvaW50fSBbcG9pbnRdXHJcbiAgICogcG9pbnQgYmFzZWQgb24gd2hpY2ggem9vbSBpcyBwZXJmb3JtZWQsIHVzdWFsbHkgcmVmZXJzIHRvIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uLFxyXG4gICAqIGlmIGZhbHNlIC0gdmlld3BvcnQgY2VudGVyIHdpbGwgYmUgdXNlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZXZab29tTGV2ZWxdIFpvb20gbGV2ZWwgYmVmb3JlIG5ldyB6b29tIHdhcyBhcHBsaWVkLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgY2FsY3VsYXRlWm9vbVRvUGFuT2Zmc2V0KGF4aXMsIHBvaW50LCBwcmV2Wm9vbUxldmVsKSB7XHJcbiAgICBjb25zdCB0b3RhbFBhbkRpc3RhbmNlID0gdGhpcy5ib3VuZHMubWF4W2F4aXNdIC0gdGhpcy5ib3VuZHMubWluW2F4aXNdO1xyXG4gICAgaWYgKHRvdGFsUGFuRGlzdGFuY2UgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYm91bmRzLmNlbnRlcltheGlzXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBvaW50KSB7XHJcbiAgICAgIHBvaW50ID0gdGhpcy5wc3dwLmdldFZpZXdwb3J0Q2VudGVyUG9pbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXByZXZab29tTGV2ZWwpIHtcclxuICAgICAgcHJldlpvb21MZXZlbCA9IHRoaXMuem9vbUxldmVscy5pbml0aWFsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0aGlzLmN1cnJab29tTGV2ZWwgLyBwcmV2Wm9vbUxldmVsO1xyXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmNvcnJlY3RQYW4oXHJcbiAgICAgIGF4aXMsXHJcbiAgICAgICh0aGlzLnBhbltheGlzXSAtIHBvaW50W2F4aXNdKSAqIHpvb21GYWN0b3IgKyBwb2ludFtheGlzXVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHBhbiBhbmQga2VlcCBpdCB3aXRoaW4gYm91bmRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhblhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFuWVxyXG4gICAqL1xyXG4gIHBhblRvKHBhblgsIHBhblkpIHtcclxuICAgIHRoaXMucGFuLnggPSB0aGlzLmJvdW5kcy5jb3JyZWN0UGFuKCd4JywgcGFuWCk7XHJcbiAgICB0aGlzLnBhbi55ID0gdGhpcy5ib3VuZHMuY29ycmVjdFBhbigneScsIHBhblkpO1xyXG4gICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgc2xpZGUgaW4gdGhlIGN1cnJlbnQgc3RhdGUgY2FuIGJlIHBhbm5lZCBieSB0aGUgdXNlclxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzUGFubmFibGUoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLndpZHRoKSAmJiAodGhpcy5jdXJyWm9vbUxldmVsID4gdGhpcy56b29tTGV2ZWxzLmZpdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgc2xpZGUgY2FuIGJlIHpvb21lZFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzWm9vbWFibGUoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLndpZHRoKSAmJiB0aGlzLmNvbnRlbnQuaXNab29tYWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgdHJhbnNmb3JtIGFuZCBzY2FsZSBiYXNlZCBvblxyXG4gICAqIHRoZSBjdXJyZW50IHBhbiBwb3NpdGlvbiAodGhpcy5wYW4pIGFuZCB6b29tIGxldmVsICh0aGlzLmN1cnJab29tTGV2ZWwpXHJcbiAgICovXHJcbiAgYXBwbHlDdXJyZW50Wm9vbVBhbigpIHtcclxuICAgIHRoaXMuX2FwcGx5Wm9vbVRyYW5zZm9ybSh0aGlzLnBhbi54LCB0aGlzLnBhbi55LCB0aGlzLmN1cnJab29tTGV2ZWwpO1xyXG4gICAgaWYgKHRoaXMgPT09IHRoaXMucHN3cC5jdXJyU2xpZGUpIHtcclxuICAgICAgdGhpcy5wc3dwLmRpc3BhdGNoKCd6b29tUGFuVXBkYXRlJywgeyBzbGlkZTogdGhpcyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHpvb21BbmRQYW5Ub0luaXRpYWwoKSB7XHJcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbDtcclxuXHJcbiAgICAvLyBwYW4gYWNjb3JkaW5nIHRvIHRoZSB6b29tIGxldmVsXHJcbiAgICB0aGlzLmJvdW5kcy51cGRhdGUodGhpcy5jdXJyWm9vbUxldmVsKTtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucGFuLCB0aGlzLmJvdW5kcy5jZW50ZXIpO1xyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdpbml0aWFsWm9vbVBhbicsIHsgc2xpZGU6IHRoaXMgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdHJhbnNsYXRlIGFuZCBzY2FsZSBiYXNlZCBvbiBjdXJyZW50IHJlc29sdXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2FwcGx5Wm9vbVRyYW5zZm9ybSh4LCB5LCB6b29tKSB7XHJcbiAgICB6b29tIC89IHRoaXMuY3VycmVudFJlc29sdXRpb24gfHwgdGhpcy56b29tTGV2ZWxzLmluaXRpYWw7XHJcbiAgICBzZXRUcmFuc2Zvcm0odGhpcy5jb250YWluZXIsIHgsIHksIHpvb20pO1xyXG4gIH1cclxuXHJcbiAgY2FsY3VsYXRlU2l6ZSgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuXHJcbiAgICBlcXVhbGl6ZVBvaW50cyhcclxuICAgICAgdGhpcy5wYW5BcmVhU2l6ZSxcclxuICAgICAgZ2V0UGFuQXJlYVNpemUocHN3cC5vcHRpb25zLCBwc3dwLnZpZXdwb3J0U2l6ZSwgdGhpcy5kYXRhLCB0aGlzLmluZGV4KVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnpvb21MZXZlbHMudXBkYXRlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnBhbkFyZWFTaXplKTtcclxuXHJcbiAgICBwc3dwLmRpc3BhdGNoKCdjYWxjU2xpZGVTaXplJywge1xyXG4gICAgICBzbGlkZTogdGhpc1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQHJldHVybnMge3N0cmluZ30gKi9cclxuICBnZXRDdXJyZW50VHJhbnNmb3JtKCkge1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmN1cnJab29tTGV2ZWwgLyAodGhpcy5jdXJyZW50UmVzb2x1dGlvbiB8fCB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbCk7XHJcbiAgICByZXR1cm4gdG9UcmFuc2Zvcm1TdHJpbmcodGhpcy5wYW4ueCwgdGhpcy5wYW4ueSwgc2NhbGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHJlc29sdXRpb24gYW5kIHJlLXJlbmRlciB0aGUgaW1hZ2UuXHJcbiAgICpcclxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHJlYWwgaW1hZ2Ugc2l6ZSBpcyAyMDAweDE1MDAsXHJcbiAgICogYW5kIHJlc29sdXRpb24gaXMgMC41IC0gaXQgd2lsbCBiZSByZW5kZXJlZCBhcyAxMDAweDc1MC5cclxuICAgKlxyXG4gICAqIEltYWdlIHdpdGggem9vbSBsZXZlbCAyIGFuZCByZXNvbHV0aW9uIDAuNSBpc1xyXG4gICAqIHRoZSBzYW1lIGFzIGltYWdlIHdpdGggem9vbSBsZXZlbCAxIGFuZCByZXNvbHV0aW9uIDEuXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIG9wdGltaXplIGFuaW1hdGlvbnMgYW5kIG1ha2VcclxuICAgKiBzdXJlIHRoYXQgYnJvd3NlciByZW5kZXJzIGltYWdlIGluIHRoZSBoaWdoZXN0IHF1YWxpdHkuXHJcbiAgICogQWxzbyB1c2VkIGJ5IHJlc3BvbnNpdmUgaW1hZ2VzIHRvIGxvYWQgdGhlIGNvcnJlY3Qgb25lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Jlc29sdXRpb25cclxuICAgKi9cclxuICBfc2V0UmVzb2x1dGlvbihuZXdSZXNvbHV0aW9uKSB7XHJcbiAgICBpZiAobmV3UmVzb2x1dGlvbiA9PT0gdGhpcy5jdXJyZW50UmVzb2x1dGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbiA9IG5ld1Jlc29sdXRpb247XHJcbiAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdyZXNvbHV0aW9uQ2hhbmdlZCcpO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9nZXN0dXJlcy5qcycpLmRlZmF1bHR9IEdlc3R1cmVzICovXHJcblxyXG5jb25zdCBQQU5fRU5EX0ZSSUNUSU9OID0gMC4zNTtcclxuY29uc3QgVkVSVElDQUxfRFJBR19GUklDVElPTiA9IDAuNjtcclxuXHJcbi8vIDEgY29ycmVzcG9uZHMgdG8gdGhlIHRoaXJkIG9mIHZpZXdwb3J0IGhlaWdodFxyXG5jb25zdCBNSU5fUkFUSU9fVE9fQ0xPU0UgPSAwLjQ7XHJcblxyXG4vLyBNaW5pbXVtIHNwZWVkIHJlcXVpcmVkIHRvIG5hdmlnYXRlXHJcbi8vIHRvIG5leHQgb3IgcHJldmlvdXMgc2xpZGVcclxuY29uc3QgTUlOX05FWFRfU0xJREVfU1BFRUQgPSAwLjU7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxWZWxvY2l0eVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjZWxlcmF0aW9uUmF0ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gcHJvamVjdChpbml0aWFsVmVsb2NpdHksIGRlY2VsZXJhdGlvblJhdGUpIHtcclxuICByZXR1cm4gaW5pdGlhbFZlbG9jaXR5ICogZGVjZWxlcmF0aW9uUmF0ZSAvICgxIC0gZGVjZWxlcmF0aW9uUmF0ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIHNpbmdsZSBwb2ludGVyIGRyYWdnaW5nXHJcbiAqL1xyXG5jbGFzcyBEcmFnSGFuZGxlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHZXN0dXJlc30gZ2VzdHVyZXNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xyXG4gICAgdGhpcy5nZXN0dXJlcyA9IGdlc3R1cmVzO1xyXG4gICAgdGhpcy5wc3dwID0gZ2VzdHVyZXMucHN3cDtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnN0YXJ0UGFuID0geyB4OiAwLCB5OiAwIH07XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIGlmICh0aGlzLnBzd3AuY3VyclNsaWRlKSB7XHJcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQYW4sIHRoaXMucHN3cC5jdXJyU2xpZGUucGFuKTtcclxuICAgIH1cclxuICAgIHRoaXMucHN3cC5hbmltYXRpb25zLnN0b3BBbGwoKTtcclxuICB9XHJcblxyXG4gIGNoYW5nZSgpIHtcclxuICAgIGNvbnN0IHsgcDEsIHByZXZQMSwgZHJhZ0F4aXMgfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSB9ID0gdGhpcy5wc3dwO1xyXG5cclxuICAgIGlmIChkcmFnQXhpcyA9PT0gJ3knXHJcbiAgICAgICAgJiYgdGhpcy5wc3dwLm9wdGlvbnMuY2xvc2VPblZlcnRpY2FsRHJhZ1xyXG4gICAgICAgICYmIChjdXJyU2xpZGUgJiYgY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPD0gY3VyclNsaWRlLnpvb21MZXZlbHMuZml0KVxyXG4gICAgICAgICYmICF0aGlzLmdlc3R1cmVzLmlzTXVsdGl0b3VjaCkge1xyXG4gICAgICAvLyBIYW5kbGUgdmVydGljYWwgZHJhZyB0byBjbG9zZVxyXG4gICAgICBjb25zdCBwYW5ZID0gY3VyclNsaWRlLnBhbi55ICsgKHAxLnkgLSBwcmV2UDEueSk7XHJcbiAgICAgIGlmICghdGhpcy5wc3dwLmRpc3BhdGNoKCd2ZXJ0aWNhbERyYWcnLCB7IHBhblkgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbigneScsIHBhblksIFZFUlRJQ0FMX0RSQUdfRlJJQ1RJT04pO1xyXG4gICAgICAgIGNvbnN0IGJnT3BhY2l0eSA9IDEgLSBNYXRoLmFicyh0aGlzLl9nZXRWZXJ0aWNhbERyYWdSYXRpbyhjdXJyU2xpZGUucGFuLnkpKTtcclxuICAgICAgICB0aGlzLnBzd3AuYXBwbHlCZ09wYWNpdHkoYmdPcGFjaXR5KTtcclxuICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBtYWluU2Nyb2xsQ2hhbmdlZCA9IHRoaXMuX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3gnKTtcclxuICAgICAgaWYgKCFtYWluU2Nyb2xsQ2hhbmdlZCkge1xyXG4gICAgICAgIHRoaXMuX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3knKTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJTbGlkZSkge1xyXG4gICAgICAgICAgcm91bmRQb2ludChjdXJyU2xpZGUucGFuKTtcclxuICAgICAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbmQoKSB7XHJcbiAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSB0aGlzLmdlc3R1cmVzO1xyXG4gICAgY29uc3QgeyBtYWluU2Nyb2xsLCBjdXJyU2xpZGUgfSA9IHRoaXMucHN3cDtcclxuICAgIGxldCBpbmRleERpZmYgPSAwO1xyXG5cclxuICAgIHRoaXMucHN3cC5hbmltYXRpb25zLnN0b3BBbGwoKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgbWFpbiBzY3JvbGwgaWYgaXQncyBzaGlmdGVkXHJcbiAgICBpZiAobWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICAvLyBQb3NpdGlvbiBvZiB0aGUgbWFpbiBzY3JvbGwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICAgIGNvbnN0IG1haW5TY3JvbGxTaGlmdERpZmYgPSBtYWluU2Nyb2xsLnggLSBtYWluU2Nyb2xsLmdldEN1cnJTbGlkZVgoKTtcclxuXHJcbiAgICAgIC8vIFJhdGlvIGJldHdlZW4gMCBhbmQgMTpcclxuICAgICAgLy8gMCAtIHNsaWRlIGlzIG5vdCB2aXNpYmxlIGF0IGFsbCxcclxuICAgICAgLy8gMC41IC0gaGFsZiBvZiB0aGUgc2xpZGUgaXMgdmlzaWJsZVxyXG4gICAgICAvLyAxIC0gc2xpZGUgaXMgZnVsbHkgdmlzaWJsZVxyXG4gICAgICBjb25zdCBjdXJyZW50U2xpZGVWaXNpYmlsaXR5UmF0aW8gPSAobWFpblNjcm9sbFNoaWZ0RGlmZiAvIHRoaXMucHN3cC52aWV3cG9ydFNpemUueCk7XHJcblxyXG4gICAgICAvLyBHbyBuZXh0IHNsaWRlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyAtIGlmIHZlbG9jaXR5IGFuZCBpdHMgZGlyZWN0aW9uIGlzIG1hdGNoZWQsXHJcbiAgICAgIC8vICAgYW5kIHdlIHNlZSBhdCBsZWFzdCB0aW55IHBhcnQgb2YgdGhlIG5leHQgc2xpZGVcclxuICAgICAgLy9cclxuICAgICAgLy8gLSBvciBpZiB3ZSBzZWUgbGVzcyB0aGFuIDUwJSBvZiB0aGUgY3VycmVudCBzbGlkZVxyXG4gICAgICAvLyAgIGFuZCB2ZWxvY2l0eSBpcyBjbG9zZSB0byAwXHJcbiAgICAgIC8vXHJcbiAgICAgIGlmICgodmVsb2NpdHkueCA8IC1NSU5fTkVYVF9TTElERV9TUEVFRCAmJiBjdXJyZW50U2xpZGVWaXNpYmlsaXR5UmF0aW8gPCAwKVxyXG4gICAgICAgICAgfHwgKHZlbG9jaXR5LnggPCAwLjEgJiYgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvIDwgLTAuNSkpIHtcclxuICAgICAgICAvLyBHbyB0byBuZXh0IHNsaWRlXHJcbiAgICAgICAgaW5kZXhEaWZmID0gMTtcclxuICAgICAgICB2ZWxvY2l0eS54ID0gTWF0aC5taW4odmVsb2NpdHkueCwgMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoKHZlbG9jaXR5LnggPiBNSU5fTkVYVF9TTElERV9TUEVFRCAmJiBjdXJyZW50U2xpZGVWaXNpYmlsaXR5UmF0aW8gPiAwKVxyXG4gICAgICAgICAgfHwgKHZlbG9jaXR5LnggPiAtMC4xICYmIGN1cnJlbnRTbGlkZVZpc2liaWxpdHlSYXRpbyA+IDAuNSkpIHtcclxuICAgICAgICAvLyBHbyB0byBwcmV2IHNsaWRlXHJcbiAgICAgICAgaW5kZXhEaWZmID0gLTE7XHJcbiAgICAgICAgdmVsb2NpdHkueCA9IE1hdGgubWF4KHZlbG9jaXR5LngsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtYWluU2Nyb2xsLm1vdmVJbmRleEJ5KGluZGV4RGlmZiwgdHJ1ZSwgdmVsb2NpdHkueCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzdG9yZSB6b29tIGxldmVsXHJcbiAgICBpZiAoKGN1cnJTbGlkZSAmJiBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heClcclxuICAgICAgICB8fCB0aGlzLmdlc3R1cmVzLmlzTXVsdGl0b3VjaCkge1xyXG4gICAgICB0aGlzLmdlc3R1cmVzLnpvb21MZXZlbHMuY29ycmVjdFpvb21QYW4odHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB3ZSBydW4gdHdvIGFuaW1hdGlvbnMgaW5zdGVhZCBvZiBvbmUsXHJcbiAgICAgIC8vIGFzIGVhY2ggYXhpcyBoYXMgb3duIHBhbiBib3VuZGFyaWVzIGFuZCB0aHVzIGRpZmZlcmVudCBzcHJpbmcgZnVuY3Rpb25cclxuICAgICAgLy8gKGNvcnJlY3Rab29tUGFuIGRvZXMgbm90IGhhdmUgdGhpcyBmdW5jdGlvbmFsaXR5LFxyXG4gICAgICAvLyAgaXQgYW5pbWF0ZXMgYWxsIHByb3BlcnRpZXMgd2l0aCBzaW5nbGUgdGltaW5nIGZ1bmN0aW9uKVxyXG4gICAgICB0aGlzLl9maW5pc2hQYW5HZXN0dXJlRm9yQXhpcygneCcpO1xyXG4gICAgICB0aGlzLl9maW5pc2hQYW5HZXN0dXJlRm9yQXhpcygneScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyd4JyB8ICd5J30gYXhpc1xyXG4gICAqL1xyXG4gIF9maW5pc2hQYW5HZXN0dXJlRm9yQXhpcyhheGlzKSB7XHJcbiAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSB0aGlzLmdlc3R1cmVzO1xyXG4gICAgY29uc3QgeyBjdXJyU2xpZGUgfSA9IHRoaXMucHN3cDtcclxuXHJcbiAgICBpZiAoIWN1cnJTbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBwYW4sIGJvdW5kcyB9ID0gY3VyclNsaWRlO1xyXG4gICAgY29uc3QgcGFuUG9zID0gcGFuW2F4aXNdO1xyXG4gICAgY29uc3QgcmVzdG9yZUJnT3BhY2l0eSA9ICh0aGlzLnBzd3AuYmdPcGFjaXR5IDwgMSAmJiBheGlzID09PSAneScpO1xyXG5cclxuICAgIC8vIDAuOTk1IG1lYW5zIC0gc2Nyb2xsIHZpZXcgbG9zZXMgMC41JSBvZiBpdHMgdmVsb2NpdHkgcGVyIG1pbGxpc2Vjb25kXHJcbiAgICAvLyBJbmNyZWFzaW5nIHRoaXMgbnVtYmVyIHdpbGwgcmVkdWNlIHRyYXZlbCBkaXN0YW5jZVxyXG4gICAgY29uc3QgZGVjZWxlcmF0aW9uUmF0ZSA9IDAuOTk1OyAvLyAwLjk5XHJcblxyXG4gICAgLy8gUGFuIHBvc2l0aW9uIGlmIHRoZXJlIGlzIG5vIGJvdW5kc1xyXG4gICAgY29uc3QgcHJvamVjdGVkUG9zaXRpb24gPSBwYW5Qb3MgKyBwcm9qZWN0KHZlbG9jaXR5W2F4aXNdLCBkZWNlbGVyYXRpb25SYXRlKTtcclxuXHJcbiAgICBpZiAocmVzdG9yZUJnT3BhY2l0eSkge1xyXG4gICAgICBjb25zdCB2RHJhZ1JhdGlvID0gdGhpcy5fZ2V0VmVydGljYWxEcmFnUmF0aW8ocGFuUG9zKTtcclxuICAgICAgY29uc3QgcHJvamVjdGVkVkRyYWdSYXRpbyA9IHRoaXMuX2dldFZlcnRpY2FsRHJhZ1JhdGlvKHByb2plY3RlZFBvc2l0aW9uKTtcclxuXHJcbiAgICAgIC8vIElmIHdlIGFyZSBhYm92ZSBhbmQgbW92aW5nIHVwd2FyZHMsXHJcbiAgICAgIC8vIG9yIGlmIHdlIGFyZSBiZWxvdyBhbmQgbW92aW5nIGRvd253YXJkc1xyXG4gICAgICBpZiAoKHZEcmFnUmF0aW8gPCAwICYmIHByb2plY3RlZFZEcmFnUmF0aW8gPCAtTUlOX1JBVElPX1RPX0NMT1NFKVxyXG4gICAgICAgICAgfHwgKHZEcmFnUmF0aW8gPiAwICYmIHByb2plY3RlZFZEcmFnUmF0aW8gPiBNSU5fUkFUSU9fVE9fQ0xPU0UpKSB7XHJcbiAgICAgICAgdGhpcy5wc3dwLmNsb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFuIHBvc2l0aW9uIHdpdGggY29ycmVjdGVkIGJvdW5kc1xyXG4gICAgY29uc3QgY29ycmVjdGVkUGFuUG9zaXRpb24gPSBib3VuZHMuY29ycmVjdFBhbihheGlzLCBwcm9qZWN0ZWRQb3NpdGlvbik7XHJcblxyXG4gICAgLy8gRXhpdCBpZiBwYW4gcG9zaXRpb24gc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXHJcbiAgICAvLyBvciBpZiBzcGVlZCBpdCB0b28gbG93XHJcbiAgICBpZiAocGFuUG9zID09PSBjb3JyZWN0ZWRQYW5Qb3NpdGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3ZlcnNob290IGlmIHRoZSBmaW5hbCBwb3NpdGlvbiBpcyBvdXQgb2YgcGFuIGJvdW5kc1xyXG4gICAgY29uc3QgZGFtcGluZ1JhdGlvID0gKGNvcnJlY3RlZFBhblBvc2l0aW9uID09PSBwcm9qZWN0ZWRQb3NpdGlvbikgPyAxIDogMC44MjtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsQmdPcGFjaXR5ID0gdGhpcy5wc3dwLmJnT3BhY2l0eTtcclxuICAgIGNvbnN0IHRvdGFsUGFuRGlzdCA9IGNvcnJlY3RlZFBhblBvc2l0aW9uIC0gcGFuUG9zO1xyXG5cclxuICAgIHRoaXMucHN3cC5hbmltYXRpb25zLnN0YXJ0U3ByaW5nKHtcclxuICAgICAgbmFtZTogJ3Bhbkdlc3R1cmUnICsgYXhpcyxcclxuICAgICAgaXNQYW46IHRydWUsXHJcbiAgICAgIHN0YXJ0OiBwYW5Qb3MsXHJcbiAgICAgIGVuZDogY29ycmVjdGVkUGFuUG9zaXRpb24sXHJcbiAgICAgIHZlbG9jaXR5OiB2ZWxvY2l0eVtheGlzXSxcclxuICAgICAgZGFtcGluZ1JhdGlvLFxyXG4gICAgICBvblVwZGF0ZTogKHBvcykgPT4ge1xyXG4gICAgICAgIC8vIEFuaW1hdGUgb3BhY2l0eSBvZiBiYWNrZ3JvdW5kIHJlbGF0aXZlIHRvIFkgcGFuIHBvc2l0aW9uIG9mIGFuIGltYWdlXHJcbiAgICAgICAgaWYgKHJlc3RvcmVCZ09wYWNpdHkgJiYgdGhpcy5wc3dwLmJnT3BhY2l0eSA8IDEpIHtcclxuICAgICAgICAgIC8vIDAgLSBzdGFydCBvZiBhbmltYXRpb24sIDEgLSBlbmQgb2YgYW5pbWF0aW9uXHJcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25Qcm9ncmVzc1JhdGlvID0gMSAtIChjb3JyZWN0ZWRQYW5Qb3NpdGlvbiAtIHBvcykgLyB0b3RhbFBhbkRpc3Q7XHJcblxyXG4gICAgICAgICAgLy8gV2UgY2xhbXAgb3BhY2l0eSB0byBrZWVwIGl0IGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICAgIC8vIEFzIHByb2dyZXNzIHJhdGlvIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGR1ZSB0byBvdmVyc2hvb3QsXHJcbiAgICAgICAgICAvLyBhbmQgd2UgZG8gbm90IHdhbnQgdG8gYm91bmNlIG9wYWNpdHkuXHJcbiAgICAgICAgICB0aGlzLnBzd3AuYXBwbHlCZ09wYWNpdHkoY2xhbXAoXHJcbiAgICAgICAgICAgIGluaXRpYWxCZ09wYWNpdHkgKyAoMSAtIGluaXRpYWxCZ09wYWNpdHkpICogYW5pbWF0aW9uUHJvZ3Jlc3NSYXRpbyxcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgMVxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYW5bYXhpc10gPSBNYXRoLmZsb29yKHBvcyk7XHJcbiAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCxcclxuICAgKiBvci9hbmQgdXBkYXRlIHBhbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBzbGlkZS5cclxuICAgKlxyXG4gICAqIFNob3VsZCByZXR1cm4gdHJ1ZSBpZiBpdCBjaGFuZ2VzIChvciBjYW4gY2hhbmdlKSBtYWluIHNjcm9sbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHsneCcgfCAneSd9IGF4aXNcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBfcGFuT3JNb3ZlTWFpblNjcm9sbChheGlzKSB7XHJcbiAgICBjb25zdCB7IHAxLCBkcmFnQXhpcywgcHJldlAxLCBpc011bHRpdG91Y2ggfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSwgbWFpblNjcm9sbCB9ID0gdGhpcy5wc3dwO1xyXG4gICAgY29uc3QgZGVsdGEgPSAocDFbYXhpc10gLSBwcmV2UDFbYXhpc10pO1xyXG4gICAgY29uc3QgbmV3TWFpblNjcm9sbFggPSBtYWluU2Nyb2xsLnggKyBkZWx0YTtcclxuXHJcbiAgICBpZiAoIWRlbHRhIHx8ICFjdXJyU2xpZGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsd2F5cyBtb3ZlIG1haW4gc2Nyb2xsIGlmIGltYWdlIGNhbiBub3QgYmUgcGFubmVkXHJcbiAgICBpZiAoYXhpcyA9PT0gJ3gnICYmICFjdXJyU2xpZGUuaXNQYW5uYWJsZSgpICYmICFpc011bHRpdG91Y2gpIHtcclxuICAgICAgbWFpblNjcm9sbC5tb3ZlVG8obmV3TWFpblNjcm9sbFgsIHRydWUpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gY2hhbmdlZCBtYWluIHNjcm9sbFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgYm91bmRzIH0gPSBjdXJyU2xpZGU7XHJcbiAgICBjb25zdCBuZXdQYW4gPSBjdXJyU2xpZGUucGFuW2F4aXNdICsgZGVsdGE7XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5vcHRpb25zLmFsbG93UGFuVG9OZXh0XHJcbiAgICAgICAgJiYgZHJhZ0F4aXMgPT09ICd4J1xyXG4gICAgICAgICYmIGF4aXMgPT09ICd4J1xyXG4gICAgICAgICYmICFpc011bHRpdG91Y2gpIHtcclxuICAgICAgY29uc3QgY3VyclNsaWRlTWFpblNjcm9sbFggPSBtYWluU2Nyb2xsLmdldEN1cnJTbGlkZVgoKTtcclxuXHJcbiAgICAgIC8vIFBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAgY29uc3QgbWFpblNjcm9sbFNoaWZ0RGlmZiA9IG1haW5TY3JvbGwueCAtIGN1cnJTbGlkZU1haW5TY3JvbGxYO1xyXG5cclxuICAgICAgY29uc3QgaXNMZWZ0VG9SaWdodCA9IGRlbHRhID4gMDtcclxuICAgICAgY29uc3QgaXNSaWdodFRvTGVmdCA9ICFpc0xlZnRUb1JpZ2h0O1xyXG5cclxuICAgICAgaWYgKG5ld1BhbiA+IGJvdW5kcy5taW5bYXhpc10gJiYgaXNMZWZ0VG9SaWdodCkge1xyXG4gICAgICAgIC8vIFBhbm5pbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBiZXlvbmQgdGhlIGxlZnQgZWRnZVxyXG5cclxuICAgICAgICAvLyBXZXRoZXIgdGhlIGltYWdlIHdhcyBhdCBtaW5pbXVtIHBhbiBwb3NpdGlvbiAob3IgbGVzcylcclxuICAgICAgICAvLyB3aGVuIHRoaXMgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQuXHJcbiAgICAgICAgLy8gTWluaW11bSBwYW4gcG9zaXRpb24gcmVmZXJzIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGltYWdlLlxyXG4gICAgICAgIGNvbnN0IHdhc0F0TWluUGFuUG9zaXRpb24gPSAoYm91bmRzLm1pbltheGlzXSA8PSB0aGlzLnN0YXJ0UGFuW2F4aXNdKTtcclxuXHJcbiAgICAgICAgaWYgKHdhc0F0TWluUGFuUG9zaXRpb24pIHtcclxuICAgICAgICAgIG1haW5TY3JvbGwubW92ZVRvKG5ld01haW5TY3JvbGxYLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgbmV3UGFuKTtcclxuICAgICAgICAgIC8vY3VyclNsaWRlLnBhbltheGlzXSA9IG5ld1BhbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobmV3UGFuIDwgYm91bmRzLm1heFtheGlzXSAmJiBpc1JpZ2h0VG9MZWZ0KSB7XHJcbiAgICAgICAgLy8gUGFuaW5nIGZyb20gcmlnaHQgdG8gbGVmdCwgYmV5b25kIHRoZSByaWdodCBlZGdlXHJcblxyXG4gICAgICAgIC8vIE1heGltdW0gcGFuIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgICAgY29uc3Qgd2FzQXRNYXhQYW5Qb3NpdGlvbiA9ICh0aGlzLnN0YXJ0UGFuW2F4aXNdIDw9IGJvdW5kcy5tYXhbYXhpc10pO1xyXG5cclxuICAgICAgICBpZiAod2FzQXRNYXhQYW5Qb3NpdGlvbikge1xyXG4gICAgICAgICAgbWFpblNjcm9sbC5tb3ZlVG8obmV3TWFpblNjcm9sbFgsIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgICAgLy9jdXJyU2xpZGUucGFuW2F4aXNdID0gbmV3UGFuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkXHJcbiAgICAgICAgaWYgKG1haW5TY3JvbGxTaGlmdERpZmYgIT09IDApIHtcclxuICAgICAgICAgIC8vIElmIG1haW4gc2Nyb2xsIGlzIHNoaWZ0ZWQgcmlnaHRcclxuICAgICAgICAgIGlmIChtYWluU2Nyb2xsU2hpZnREaWZmID4gMCAvKiYmIGlzUmlnaHRUb0xlZnQqLykge1xyXG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1heChuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG1haW5TY3JvbGxTaGlmdERpZmYgPCAwIC8qJiYgaXNMZWZ0VG9SaWdodCovKSB7XHJcbiAgICAgICAgICAgIC8vIE1haW4gc2Nyb2xsIGlzIHNoaWZ0ZWQgbGVmdCAoUG9zaXRpb24gaXMgbGVzcyB0aGFuIDAgY29tcGFyaW5nIHRvIHRoZSB2aWV3cG9ydCAwKVxyXG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1pbihuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFdlIGFyZSB3aXRoaW4gcGFuIGJvdW5kcywgc28ganVzdCBwYW5cclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xyXG4gICAgICAgIC8vIERvIG5vdCBwYW4gdmVydGljYWxseSBpZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkIG9cclxuICAgICAgICBpZiAoIW1haW5TY3JvbGwuaXNTaGlmdGVkKCkgJiYgYm91bmRzLm1pbi55ICE9PSBib3VuZHMubWF4LnkpIHtcclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgbmV3UGFuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIElmIHdlIG1vdmUgYWJvdmUgLSB0aGUgcmF0aW8gaXMgbmVnYXRpdmVcclxuICAvLyBJZiB3ZSBtb3ZlIGJlbG93IHRoZSByYXRpbyBpcyBwb3NpdGl2ZVxyXG5cclxuICAvKipcclxuICAgKiBSZWxhdGlvbiBiZXR3ZWVuIHBhbiBZIHBvc2l0aW9uIGFuZCB0aGlyZCBvZiB2aWV3cG9ydCBoZWlnaHQuXHJcbiAgICpcclxuICAgKiBXaGVuIHdlIGFyZSBhdCBpbml0aWFsIHBvc2l0aW9uIChjZW50ZXIgYm91bmRzKSAtIHRoZSByYXRpbyBpcyAwLFxyXG4gICAqIGlmIHBvc2l0aW9uIGlzIHNoaWZ0ZWQgdXB3YXJkcyAtIHRoZSByYXRpbyBpcyBuZWdhdGl2ZSxcclxuICAgKiBpZiBwb3NpdGlvbiBpcyBzaGlmdGVkIGRvd253YXJkcyAtIHRoZSByYXRpbyBpcyBwb3NpdGl2ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhblkgVGhlIGN1cnJlbnQgcGFuIFkgcG9zaXRpb24uXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0VmVydGljYWxEcmFnUmF0aW8ocGFuWSkge1xyXG4gICAgcmV0dXJuIChwYW5ZIC0gKHRoaXMucHN3cC5jdXJyU2xpZGU/LmJvdW5kcy5jZW50ZXIueSA/PyAwKSkgLyAodGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS55IC8gMyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcGFuIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHNsaWRlLlxyXG4gICAqIEFwcGx5IGZyaWN0aW9uIGlmIHRoZSBwb3NpdGlvbiBpcyBiZXlvbmQgdGhlIHBhbiBib3VuZHMsXHJcbiAgICogb3IgaWYgY3VzdG9tIGZyaWN0aW9uIGlzIGRlZmluZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvdGVudGlhbFBhblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VzdG9tRnJpY3Rpb25dICgwLjEgLSAxKVxyXG4gICAqL1xyXG4gIF9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgcG90ZW50aWFsUGFuLCBjdXN0b21GcmljdGlvbikge1xyXG4gICAgY29uc3QgeyBjdXJyU2xpZGUgfSA9IHRoaXMucHN3cDtcclxuXHJcbiAgICBpZiAoIWN1cnJTbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBwYW4sIGJvdW5kcyB9ID0gY3VyclNsaWRlO1xyXG4gICAgY29uc3QgY29ycmVjdGVkUGFuID0gYm91bmRzLmNvcnJlY3RQYW4oYXhpcywgcG90ZW50aWFsUGFuKTtcclxuICAgIC8vIElmIHdlIGFyZSBvdXQgb2YgcGFuIGJvdW5kc1xyXG4gICAgaWYgKGNvcnJlY3RlZFBhbiAhPT0gcG90ZW50aWFsUGFuIHx8IGN1c3RvbUZyaWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5yb3VuZChwb3RlbnRpYWxQYW4gLSBwYW5bYXhpc10pO1xyXG4gICAgICBwYW5bYXhpc10gKz0gZGVsdGEgKiAoY3VzdG9tRnJpY3Rpb24gfHwgUEFOX0VORF9GUklDVElPTik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYW5bYXhpc10gPSBwb3RlbnRpYWxQYW47XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUG9pbnR9IFBvaW50ICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2dlc3R1cmVzLmpzJykuZGVmYXVsdH0gR2VzdHVyZXMgKi9cclxuXHJcbmNvbnN0IFVQUEVSX1pPT01fRlJJQ1RJT04gPSAwLjA1O1xyXG5jb25zdCBMT1dFUl9aT09NX0ZSSUNUSU9OID0gMC4xNTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IGNlbnRlciBwb2ludCBiZXR3ZWVuIHR3byBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtQb2ludH0gcFxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMVxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMlxyXG4gKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRab29tUG9pbnRzQ2VudGVyKHAsIHAxLCBwMikge1xyXG4gIHAueCA9IChwMS54ICsgcDIueCkgLyAyO1xyXG4gIHAueSA9IChwMS55ICsgcDIueSkgLyAyO1xyXG4gIHJldHVybiBwO1xyXG59XHJcblxyXG5jbGFzcyBab29tSGFuZGxlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHZXN0dXJlc30gZ2VzdHVyZXNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xyXG4gICAgdGhpcy5nZXN0dXJlcyA9IGdlc3R1cmVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9zdGFydFBhbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9zdGFydFpvb21Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl96b29tUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fd2FzT3ZlckZpdFpvb21MZXZlbCA9IGZhbHNlO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9zdGFydFpvb21MZXZlbCA9IDE7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSB0aGlzLmdlc3R1cmVzLnBzd3A7XHJcbiAgICBpZiAoY3VyclNsaWRlKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0Wm9vbUxldmVsID0gY3VyclNsaWRlLmN1cnJab29tTGV2ZWw7XHJcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX3N0YXJ0UGFuLCBjdXJyU2xpZGUucGFuKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdlc3R1cmVzLnBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsUGFuKCk7XHJcbiAgICB0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjaGFuZ2UoKSB7XHJcbiAgICBjb25zdCB7IHAxLCBzdGFydFAxLCBwMiwgc3RhcnRQMiwgcHN3cCB9ID0gdGhpcy5nZXN0dXJlcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSBwc3dwO1xyXG5cclxuICAgIGlmICghY3VyclNsaWRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtaW5ab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5taW47XHJcbiAgICBjb25zdCBtYXhab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5tYXg7XHJcblxyXG4gICAgaWYgKCFjdXJyU2xpZGUuaXNab29tYWJsZSgpIHx8IHBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Wm9vbVBvaW50c0NlbnRlcih0aGlzLl9zdGFydFpvb21Qb2ludCwgc3RhcnRQMSwgc3RhcnRQMik7XHJcbiAgICBnZXRab29tUG9pbnRzQ2VudGVyKHRoaXMuX3pvb21Qb2ludCwgcDEsIHAyKTtcclxuXHJcbiAgICBsZXQgY3Vyclpvb21MZXZlbCA9ICgxIC8gZ2V0RGlzdGFuY2VCZXR3ZWVuKHN0YXJ0UDEsIHN0YXJ0UDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgKiBnZXREaXN0YW5jZUJldHdlZW4ocDEsIHAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgKiB0aGlzLl9zdGFydFpvb21MZXZlbDtcclxuXHJcbiAgICAvLyBzbGlnaHRseSBvdmVyIHRoZSB6b29tLmZpdFxyXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPiBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsICsgKGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwgLyAxNSkpIHtcclxuICAgICAgdGhpcy5fd2FzT3ZlckZpdFpvb21MZXZlbCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwpIHtcclxuICAgICAgaWYgKHBzd3Aub3B0aW9ucy5waW5jaFRvQ2xvc2VcclxuICAgICAgICAgICYmICF0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsXHJcbiAgICAgICAgICAmJiB0aGlzLl9zdGFydFpvb21MZXZlbCA8PSBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgICAgLy8gZmFkZSBvdXQgYmFja2dyb3VuZCBpZiB6b29taW5nIG91dFxyXG4gICAgICAgIGNvbnN0IGJnT3BhY2l0eSA9IDEgLSAoKG1pblpvb21MZXZlbCAtIGN1cnJab29tTGV2ZWwpIC8gKG1pblpvb21MZXZlbCAvIDEuMikpO1xyXG4gICAgICAgIGlmICghcHN3cC5kaXNwYXRjaCgncGluY2hDbG9zZScsIHsgYmdPcGFjaXR5IH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgIHBzd3AuYXBwbHlCZ09wYWNpdHkoYmdPcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgYmVsb3cgdGhlIG1pblxyXG4gICAgICAgIGN1cnJab29tTGV2ZWwgPSBtaW5ab29tTGV2ZWwgLSAobWluWm9vbUxldmVsIC0gY3Vyclpvb21MZXZlbCkgKiBMT1dFUl9aT09NX0ZSSUNUSU9OO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGN1cnJab29tTGV2ZWwgPiBtYXhab29tTGV2ZWwpIHtcclxuICAgICAgLy8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgYWJvdmUgdGhlIG1heFxyXG4gICAgICBjdXJyWm9vbUxldmVsID0gbWF4Wm9vbUxldmVsICsgKGN1cnJab29tTGV2ZWwgLSBtYXhab29tTGV2ZWwpICogVVBQRVJfWk9PTV9GUklDVElPTjtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyU2xpZGUucGFuLnggPSB0aGlzLl9jYWxjdWxhdGVQYW5Gb3Jab29tTGV2ZWwoJ3gnLCBjdXJyWm9vbUxldmVsKTtcclxuICAgIGN1cnJTbGlkZS5wYW4ueSA9IHRoaXMuX2NhbGN1bGF0ZVBhbkZvclpvb21MZXZlbCgneScsIGN1cnJab29tTGV2ZWwpO1xyXG5cclxuICAgIGN1cnJTbGlkZS5zZXRab29tTGV2ZWwoY3Vyclpvb21MZXZlbCk7XHJcbiAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gIH1cclxuXHJcbiAgZW5kKCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzLmdlc3R1cmVzO1xyXG4gICAgY29uc3QgeyBjdXJyU2xpZGUgfSA9IHBzd3A7XHJcbiAgICBpZiAoKCFjdXJyU2xpZGUgfHwgY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPCBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKVxyXG4gICAgICAgICYmICF0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsXHJcbiAgICAgICAgJiYgcHN3cC5vcHRpb25zLnBpbmNoVG9DbG9zZSkge1xyXG4gICAgICBwc3dwLmNsb3NlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNvcnJlY3Rab29tUGFuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJab29tTGV2ZWxcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIF9jYWxjdWxhdGVQYW5Gb3Jab29tTGV2ZWwoYXhpcywgY3Vyclpvb21MZXZlbCkge1xyXG4gICAgY29uc3Qgem9vbUZhY3RvciA9IGN1cnJab29tTGV2ZWwgLyB0aGlzLl9zdGFydFpvb21MZXZlbDtcclxuICAgIHJldHVybiB0aGlzLl96b29tUG9pbnRbYXhpc11cclxuICAgICAgICAgICAgLSAoKHRoaXMuX3N0YXJ0Wm9vbVBvaW50W2F4aXNdIC0gdGhpcy5fc3RhcnRQYW5bYXhpc10pICogem9vbUZhY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3JyZWN0IGN1cnJab29tTGV2ZWwgYW5kIHBhbiBpZiB0aGV5IGFyZVxyXG4gICAqIGJleW9uZCBtaW5pbXVtIG9yIG1heGltdW0gdmFsdWVzLlxyXG4gICAqIFdpdGggYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlR2VzdHVyZV1cclxuICAgKiBXZXRoZXIgZ2VzdHVyZSBjb29yZGluYXRlcyBzaG91bGQgYmUgaWdub3JlZCB3aGVuIGNhbGN1bGF0aW5nIGRlc3RpbmF0aW9uIHBhbiBwb3NpdGlvbi5cclxuICAgKi9cclxuICBjb3JyZWN0Wm9vbVBhbihpZ25vcmVHZXN0dXJlKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSB9ID0gcHN3cDtcclxuXHJcbiAgICBpZiAoIWN1cnJTbGlkZT8uaXNab29tYWJsZSgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fem9vbVBvaW50LnggPT09IDApIHtcclxuICAgICAgaWdub3JlR2VzdHVyZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJldlpvb21MZXZlbCA9IGN1cnJTbGlkZS5jdXJyWm9vbUxldmVsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IGRlc3RpbmF0aW9uWm9vbUxldmVsO1xyXG4gICAgbGV0IGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSA9IHRydWU7XHJcblxyXG4gICAgaWYgKHByZXZab29tTGV2ZWwgPCBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgIGRlc3RpbmF0aW9uWm9vbUxldmVsID0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbDtcclxuICAgICAgLy8gem9vbSB0byBtaW5cclxuICAgIH0gZWxzZSBpZiAocHJldlpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heCkge1xyXG4gICAgICBkZXN0aW5hdGlvblpvb21MZXZlbCA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heDtcclxuICAgICAgLy8gem9vbSB0byBtYXhcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSA9IGZhbHNlO1xyXG4gICAgICBkZXN0aW5hdGlvblpvb21MZXZlbCA9IHByZXZab29tTGV2ZWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbEJnT3BhY2l0eSA9IHBzd3AuYmdPcGFjaXR5O1xyXG4gICAgY29uc3QgcmVzdG9yZUJnT3BhY2l0eSA9IHBzd3AuYmdPcGFjaXR5IDwgMTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsUGFuID0gZXF1YWxpemVQb2ludHMoeyB4OiAwLCB5OiAwIH0sIGN1cnJTbGlkZS5wYW4pO1xyXG4gICAgbGV0IGRlc3RpbmF0aW9uUGFuID0gZXF1YWxpemVQb2ludHMoeyB4OiAwLCB5OiAwIH0sIGluaXRpYWxQYW4pO1xyXG5cclxuICAgIGlmIChpZ25vcmVHZXN0dXJlKSB7XHJcbiAgICAgIHRoaXMuX3pvb21Qb2ludC54ID0gMDtcclxuICAgICAgdGhpcy5fem9vbVBvaW50LnkgPSAwO1xyXG4gICAgICB0aGlzLl9zdGFydFpvb21Qb2ludC54ID0gMDtcclxuICAgICAgdGhpcy5fc3RhcnRab29tUG9pbnQueSA9IDA7XHJcbiAgICAgIHRoaXMuX3N0YXJ0Wm9vbUxldmVsID0gcHJldlpvb21MZXZlbDtcclxuICAgICAgZXF1YWxpemVQb2ludHModGhpcy5fc3RhcnRQYW4sIGluaXRpYWxQYW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UpIHtcclxuICAgICAgZGVzdGluYXRpb25QYW4gPSB7XHJcbiAgICAgICAgeDogdGhpcy5fY2FsY3VsYXRlUGFuRm9yWm9vbUxldmVsKCd4JywgZGVzdGluYXRpb25ab29tTGV2ZWwpLFxyXG4gICAgICAgIHk6IHRoaXMuX2NhbGN1bGF0ZVBhbkZvclpvb21MZXZlbCgneScsIGRlc3RpbmF0aW9uWm9vbUxldmVsKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB6b29tIGxldmVsLCBzbyBwYW4gYm91bmRzIGFyZSB1cGRhdGVkIGFjY29yZGluZyB0byBpdFxyXG4gICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChkZXN0aW5hdGlvblpvb21MZXZlbCk7XHJcblxyXG4gICAgZGVzdGluYXRpb25QYW4gPSB7XHJcbiAgICAgIHg6IGN1cnJTbGlkZS5ib3VuZHMuY29ycmVjdFBhbigneCcsIGRlc3RpbmF0aW9uUGFuLngpLFxyXG4gICAgICB5OiBjdXJyU2xpZGUuYm91bmRzLmNvcnJlY3RQYW4oJ3knLCBkZXN0aW5hdGlvblBhbi55KVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZXR1cm4gem9vbSBsZXZlbCBhbmQgaXRzIGJvdW5kcyB0byBpbml0aWFsXHJcbiAgICBjdXJyU2xpZGUuc2V0Wm9vbUxldmVsKHByZXZab29tTGV2ZWwpO1xyXG5cclxuICAgIGNvbnN0IHBhbk5lZWRzQ2hhbmdlID0gIXBvaW50c0VxdWFsKGRlc3RpbmF0aW9uUGFuLCBpbml0aWFsUGFuKTtcclxuXHJcbiAgICBpZiAoIXBhbk5lZWRzQ2hhbmdlICYmICFjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UgJiYgIXJlc3RvcmVCZ09wYWNpdHkpIHtcclxuICAgICAgLy8gdXBkYXRlIHJlc29sdXRpb24gYWZ0ZXIgZ2VzdHVyZVxyXG4gICAgICBjdXJyU2xpZGUuX3NldFJlc29sdXRpb24oZGVzdGluYXRpb25ab29tTGV2ZWwpO1xyXG4gICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG5cclxuICAgICAgLy8gbm90aGluZyB0byBhbmltYXRlXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RvcEFsbFBhbigpO1xyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdGFydFNwcmluZyh7XHJcbiAgICAgIGlzUGFuOiB0cnVlLFxyXG4gICAgICBzdGFydDogMCxcclxuICAgICAgZW5kOiAxMDAwLFxyXG4gICAgICB2ZWxvY2l0eTogMCxcclxuICAgICAgZGFtcGluZ1JhdGlvOiAxLFxyXG4gICAgICBuYXR1cmFsRnJlcXVlbmN5OiA0MCxcclxuICAgICAgb25VcGRhdGU6IChub3cpID0+IHtcclxuICAgICAgICBub3cgLz0gMTAwMDsgLy8gMCAtIHN0YXJ0LCAxIC0gZW5kXHJcblxyXG4gICAgICAgIGlmIChwYW5OZWVkc0NoYW5nZSB8fCBjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UpIHtcclxuICAgICAgICAgIGlmIChwYW5OZWVkc0NoYW5nZSkge1xyXG4gICAgICAgICAgICBjdXJyU2xpZGUucGFuLnggPSBpbml0aWFsUGFuLnggKyAoZGVzdGluYXRpb25QYW4ueCAtIGluaXRpYWxQYW4ueCkgKiBub3c7XHJcbiAgICAgICAgICAgIGN1cnJTbGlkZS5wYW4ueSA9IGluaXRpYWxQYW4ueSArIChkZXN0aW5hdGlvblBhbi55IC0gaW5pdGlhbFBhbi55KSAqIG5vdztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1pvb21MZXZlbCA9IHByZXZab29tTGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoZGVzdGluYXRpb25ab29tTGV2ZWwgLSBwcmV2Wm9vbUxldmVsKSAqIG5vdztcclxuICAgICAgICAgICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChuZXdab29tTGV2ZWwpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGJhY2tncm91bmQgb3BhY2l0eVxyXG4gICAgICAgIGlmIChyZXN0b3JlQmdPcGFjaXR5ICYmIHBzd3AuYmdPcGFjaXR5IDwgMSkge1xyXG4gICAgICAgICAgLy8gV2UgY2xhbXAgb3BhY2l0eSB0byBrZWVwIGl0IGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICAgIC8vIEFzIHByb2dyZXNzIHJhdGlvIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGR1ZSB0byBvdmVyc2hvb3QsXHJcbiAgICAgICAgICAvLyBhbmQgd2UgZG8gbm90IHdhbnQgdG8gYm91bmNlIG9wYWNpdHkuXHJcbiAgICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KGNsYW1wKFxyXG4gICAgICAgICAgICBpbml0aWFsQmdPcGFjaXR5ICsgKDEgLSBpbml0aWFsQmdPcGFjaXR5KSAqIG5vdywgMCwgMVxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgLy8gdXBkYXRlIHJlc29sdXRpb24gYWZ0ZXIgdHJhbnNpdGlvbiBlbmRzXHJcbiAgICAgICAgY3VyclNsaWRlLl9zZXRSZXNvbHV0aW9uKGRlc3RpbmF0aW9uWm9vbUxldmVsKTtcclxuICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cblxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBULCBQXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuQWRkUG9zdGZpeDxULCBQPn0gQWRkUG9zdGZpeDxULCBQPlxyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2dlc3R1cmVzLmpzJykuZGVmYXVsdH0gR2VzdHVyZXMgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7J2ltYWdlQ2xpY2snIHwgJ2JnQ2xpY2snIHwgJ3RhcCcgfCAnZG91YmxlVGFwJ30gQWN0aW9ucyAqL1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHRhcCB3YXMgcGVyZm9ybWVkIG9uIHRoZSBtYWluIHNsaWRlXHJcbiAqIChyYXRoZXIgdGhhbiBjb250cm9scyBvciBjYXB0aW9uKS5cclxuICpcclxuICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gZGlkVGFwT25NYWluQ29udGVudChldmVudCkge1xyXG4gIHJldHVybiAhISgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcucHN3cF9fY29udGFpbmVyJykpO1xyXG59XHJcblxyXG4vKipcclxuICogVGFwLCBkb3VibGUtdGFwIGhhbmRsZXIuXHJcbiAqL1xyXG5jbGFzcyBUYXBIYW5kbGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0dlc3R1cmVzfSBnZXN0dXJlc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGdlc3R1cmVzKSB7XHJcbiAgICB0aGlzLmdlc3R1cmVzID0gZ2VzdHVyZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50XHJcbiAgICovXHJcbiAgY2xpY2socG9pbnQsIG9yaWdpbmFsRXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldENsYXNzTGlzdCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCkuY2xhc3NMaXN0O1xyXG4gICAgY29uc3QgaXNJbWFnZUNsaWNrID0gdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX19pbWcnKTtcclxuICAgIGNvbnN0IGlzQmFja2dyb3VuZENsaWNrID0gdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX19pdGVtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX196b29tLXdyYXAnKTtcclxuXHJcbiAgICBpZiAoaXNJbWFnZUNsaWNrKSB7XHJcbiAgICAgIHRoaXMuX2RvQ2xpY2tPclRhcEFjdGlvbignaW1hZ2VDbGljaycsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaXNCYWNrZ3JvdW5kQ2xpY2spIHtcclxuICAgICAgdGhpcy5fZG9DbGlja09yVGFwQWN0aW9uKCdiZ0NsaWNrJywgcG9pbnQsIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gb3JpZ2luYWxFdmVudFxyXG4gICAqL1xyXG4gIHRhcChwb2ludCwgb3JpZ2luYWxFdmVudCkge1xyXG4gICAgaWYgKGRpZFRhcE9uTWFpbkNvbnRlbnQob3JpZ2luYWxFdmVudCkpIHtcclxuICAgICAgdGhpcy5fZG9DbGlja09yVGFwQWN0aW9uKCd0YXAnLCBwb2ludCwgb3JpZ2luYWxFdmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50XHJcbiAgICovXHJcbiAgZG91YmxlVGFwKHBvaW50LCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICBpZiAoZGlkVGFwT25NYWluQ29udGVudChvcmlnaW5hbEV2ZW50KSkge1xyXG4gICAgICB0aGlzLl9kb0NsaWNrT3JUYXBBY3Rpb24oJ2RvdWJsZVRhcCcsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBY3Rpb25zfSBhY3Rpb25OYW1lXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gb3JpZ2luYWxFdmVudFxyXG4gICAqL1xyXG4gIF9kb0NsaWNrT3JUYXBBY3Rpb24oYWN0aW9uTmFtZSwgcG9pbnQsIG9yaWdpbmFsRXZlbnQpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcy5nZXN0dXJlcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSBwc3dwO1xyXG4gICAgY29uc3QgYWN0aW9uRnVsbE5hbWUgPSAvKiogQHR5cGUge0FkZFBvc3RmaXg8QWN0aW9ucywgJ0FjdGlvbic+fSAqLyAoYWN0aW9uTmFtZSArICdBY3Rpb24nKTtcclxuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gcHN3cC5vcHRpb25zW2FjdGlvbkZ1bGxOYW1lXTtcclxuXHJcbiAgICBpZiAocHN3cC5kaXNwYXRjaChhY3Rpb25GdWxsTmFtZSwgeyBwb2ludCwgb3JpZ2luYWxFdmVudCB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIG9wdGlvblZhbHVlLmNhbGwocHN3cCwgcG9pbnQsIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChvcHRpb25WYWx1ZSkge1xyXG4gICAgICBjYXNlICdjbG9zZSc6XHJcbiAgICAgIGNhc2UgJ25leHQnOlxyXG4gICAgICAgIHBzd3Bbb3B0aW9uVmFsdWVdKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3pvb20nOlxyXG4gICAgICAgIGN1cnJTbGlkZT8udG9nZ2xlWm9vbShwb2ludCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3pvb20tb3ItY2xvc2UnOlxyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgY2xpY2sgem9vbXMgY3VycmVudCBpbWFnZSxcclxuICAgICAgICAvLyBpZiBpdCBjYW4gbm90IGJlIHpvb21lZCAtIGdhbGxlcnkgd2lsbCBiZSBjbG9zZWRcclxuICAgICAgICBpZiAoY3VyclNsaWRlPy5pc1pvb21hYmxlKClcclxuICAgICAgICAgICAgJiYgY3VyclNsaWRlLnpvb21MZXZlbHMuc2Vjb25kYXJ5ICE9PSBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgICAgICBjdXJyU2xpZGUudG9nZ2xlWm9vbShwb2ludCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwc3dwLm9wdGlvbnMuY2xpY2tUb0Nsb3NlTm9uWm9vbWFibGUpIHtcclxuICAgICAgICAgIHBzd3AuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvZ2dsZS1jb250cm9scyc6XHJcbiAgICAgICAgdGhpcy5nZXN0dXJlcy5wc3dwLmVsZW1lbnQ/LmNsYXNzTGlzdC50b2dnbGUoJ3Bzd3AtLXVpLXZpc2libGUnKTtcclxuICAgICAgICAvLyBpZiAoX2NvbnRyb2xzVmlzaWJsZSkge1xyXG4gICAgICAgIC8vICAgX3VpLmhpZGVDb250cm9scygpO1xyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICBfdWkuc2hvd0NvbnRyb2xzKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cclxuXHJcbi8vIEhvdyBmYXIgc2hvdWxkIHVzZXIgc2hvdWxkIGRyYWdcclxuLy8gdW50aWwgd2UgY2FuIGRldGVybWluZSB0aGF0IHRoZSBnZXN0dXJlIGlzIHN3aXBlIGFuZCBpdHMgZGlyZWN0aW9uXHJcbmNvbnN0IEFYSVNfU1dJUEVfSFlTVEVSSVNJUyA9IDEwO1xyXG4vL2NvbnN0IFBBTl9FTkRfRlJJQ1RJT04gPSAwLjM1O1xyXG5cclxuY29uc3QgRE9VQkxFX1RBUF9ERUxBWSA9IDMwMDsgLy8gbXNcclxuY29uc3QgTUlOX1RBUF9ESVNUQU5DRSA9IDI1OyAvLyBweFxyXG5cclxuLyoqXHJcbiAqIEdlc3R1cmVzIGNsYXNzIGJpbmQgdG91Y2gsIHBvaW50ZXIgb3IgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBlbWl0cyBkcmFnIHRvIGRyYWctaGFuZGxlciBhbmQgem9vbSBldmVudHMgem9vbS1oYW5kbGVyLlxyXG4gKlxyXG4gKiBEcmFnIGFuZCB6b29tIGV2ZW50cyBhcmUgZW1pdGVkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuICogYW5kIG9ubHkgd2hlbiBvbmUgb2YgcG9pbnRlcnMgd2FzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAqL1xyXG5jbGFzcyBHZXN0dXJlcyB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHN3cCkge1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuXHJcbiAgICAvKiogQHR5cGUgeyd4JyB8ICd5JyB8IG51bGx9ICovXHJcbiAgICB0aGlzLmRyYWdBeGlzID0gbnVsbDtcclxuXHJcbiAgICAvLyBwb2ludCBvYmplY3RzIGFyZSBkZWZpbmVkIG9uY2UgYW5kIHJldXNlZFxyXG4gICAgLy8gUGhvdG9Td2lwZSBrZWVwcyB0cmFjayBvbmx5IG9mIHR3byBwb2ludGVycywgb3RoZXJzIGFyZSBpZ25vcmVkXHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5wMSA9IHsgeDogMCwgeTogMCB9OyAvLyB0aGUgZmlyc3QgcHJlc3NlZCBwb2ludGVyXHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5wMiA9IHsgeDogMCwgeTogMCB9OyAvLyB0aGUgc2Vjb25kIHByZXNzZWQgcG9pbnRlclxyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMucHJldlAxID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5wcmV2UDIgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnN0YXJ0UDEgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnN0YXJ0UDIgPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgLyoqIEB0eXBlIHtQb2ludH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xhc3RTdGFydFAxID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAvKiogQHR5cGUge1BvaW50fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faW50ZXJ2YWxQMSA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9udW1BY3RpdmVQb2ludHMgPSAwO1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludFtdfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fb25nb2luZ1BvaW50ZXJzID0gW107XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3RvdWNoRXZlbnRFbmFibGVkID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkID0gISEod2luZG93LlBvaW50ZXJFdmVudCk7XHJcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2ggPSB0aGlzLl90b3VjaEV2ZW50RW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9udW1BY3RpdmVQb2ludHMgPSAwO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9pbnRlcnZhbFRpbWUgPSAwO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl92ZWxvY2l0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNNdWx0aXRvdWNoID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XHJcbiAgICAvKiogQHR5cGUge251bWJlciB8IG51bGx9ICovXHJcbiAgICB0aGlzLnJhZiA9IG51bGw7XHJcbiAgICAvKiogQHR5cGUge05vZGVKUy5UaW1lb3V0IHwgbnVsbH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3RhcFRpbWVyID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHNUb3VjaCkge1xyXG4gICAgICAvLyBkaXNhYmxlIHBhbiB0byBuZXh0IHNsaWRlIGZvciBub24tdG91Y2ggZGV2aWNlc1xyXG4gICAgICBwc3dwLm9wdGlvbnMuYWxsb3dQYW5Ub05leHQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRyYWcgPSBuZXcgRHJhZ0hhbmRsZXIodGhpcyk7XHJcbiAgICB0aGlzLnpvb21MZXZlbHMgPSBuZXcgWm9vbUhhbmRsZXIodGhpcyk7XHJcbiAgICB0aGlzLnRhcEhhbmRsZXIgPSBuZXcgVGFwSGFuZGxlcih0aGlzKTtcclxuXHJcbiAgICBwc3dwLm9uKCdiaW5kRXZlbnRzJywgKCkgPT4ge1xyXG4gICAgICBwc3dwLmV2ZW50cy5hZGQoXHJcbiAgICAgICAgcHN3cC5zY3JvbGxXcmFwLFxyXG4gICAgICAgICdjbGljaycsXHJcbiAgICAgICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi8odGhpcy5fb25DbGljay5iaW5kKHRoaXMpKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCdwb2ludGVyJywgJ2Rvd24nLCAndXAnLCAnY2FuY2VsJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdG91Y2hFdmVudEVuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCd0b3VjaCcsICdzdGFydCcsICdlbmQnLCAnY2FuY2VsJyk7XHJcblxyXG4gICAgICAgIC8vIEluIHByZXZpb3VzIHZlcnNpb25zIHdlIGFsc28gYm91bmQgbW91c2UgZXZlbnQgaGVyZSxcclxuICAgICAgICAvLyBpbiBjYXNlIGRldmljZSBzdXBwb3J0cyBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHMsXHJcbiAgICAgICAgLy8gYnV0IG5ld2VyIHZlcnNpb25zIG9mIGJyb3dzZXJzIG5vdyBzdXBwb3J0IFBvaW50ZXJFdmVudC5cclxuXHJcbiAgICAgICAgLy8gb24gaU9TMTAgaWYgeW91IGJpbmQgdG91Y2htb3ZlL2VuZCBhZnRlciB0b3VjaHN0YXJ0LFxyXG4gICAgICAgIC8vIGFuZCB5b3UgZG9uJ3QgcHJldmVudERlZmF1bHQgdG91Y2hzdGFydCAod2hpY2ggUGhvdG9Td2lwZSBkb2VzKSxcclxuICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIHRvdWNobW92ZSBhbmQgdG91Y2hlbmQuXHJcbiAgICAgICAgLy8gVW5sZXNzIHlvdSBiaW5kIGl0IHByZXZpb3VzbHkuXHJcbiAgICAgICAgaWYgKHBzd3Auc2Nyb2xsV3JhcCkge1xyXG4gICAgICAgICAgcHN3cC5zY3JvbGxXcmFwLm9udG91Y2htb3ZlID0gKCkgPT4ge307XHJcbiAgICAgICAgICBwc3dwLnNjcm9sbFdyYXAub250b3VjaGVuZCA9ICgpID0+IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCdtb3VzZScsICdkb3duJywgJ3VwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geydtb3VzZScgfCAndG91Y2gnIHwgJ3BvaW50ZXInfSBwcmVmXHJcbiAgICogQHBhcmFtIHsnZG93bicgfCAnc3RhcnQnfSBkb3duXHJcbiAgICogQHBhcmFtIHsndXAnIHwgJ2VuZCd9IHVwXHJcbiAgICogQHBhcmFtIHsnY2FuY2VsJ30gW2NhbmNlbF1cclxuICAgKi9cclxuICBfYmluZEV2ZW50cyhwcmVmLCBkb3duLCB1cCwgY2FuY2VsKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IGV2ZW50cyB9ID0gcHN3cDtcclxuXHJcbiAgICBjb25zdCBjYW5jZWxFdmVudCA9IGNhbmNlbCA/IHByZWYgKyBjYW5jZWwgOiAnJztcclxuXHJcbiAgICBldmVudHMuYWRkKFxyXG4gICAgICBwc3dwLnNjcm9sbFdyYXAsXHJcbiAgICAgIHByZWYgKyBkb3duLFxyXG4gICAgICAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqLyh0aGlzLm9uUG9pbnRlckRvd24uYmluZCh0aGlzKSlcclxuICAgICk7XHJcbiAgICBldmVudHMuYWRkKHdpbmRvdywgcHJlZiArICdtb3ZlJywgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi8odGhpcy5vblBvaW50ZXJNb3ZlLmJpbmQodGhpcykpKTtcclxuICAgIGV2ZW50cy5hZGQod2luZG93LCBwcmVmICsgdXAsIC8qKiBAdHlwZSBFdmVudExpc3RlbmVyICovKHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKSkpO1xyXG4gICAgaWYgKGNhbmNlbEV2ZW50KSB7XHJcbiAgICAgIGV2ZW50cy5hZGQoXHJcbiAgICAgICAgcHN3cC5zY3JvbGxXcmFwLFxyXG4gICAgICAgIGNhbmNlbEV2ZW50LFxyXG4gICAgICAgIC8qKiBAdHlwZSBFdmVudExpc3RlbmVyICovKHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgb25Qb2ludGVyRG93bihlKSB7XHJcbiAgICAvLyBXZSBkbyBub3QgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgdG91Y2ggZXZlbnRzXHJcbiAgICAvLyB0byBhbGxvdyBicm93c2VyIHRvIHNob3cgbmF0aXZlIGRpYWxvZyBvbiBsb25ncHJlc3NcclxuICAgIC8vICh0aGUgb25lIHRoYXQgYWxsb3dzIHRvIHNhdmUgaW1hZ2Ugb3Igb3BlbiBpdCBpbiBuZXcgdGFiKS5cclxuICAgIC8vXHJcbiAgICAvLyBEZXNrdG9wIFNhZmFyaSBhbGxvd3MgdG8gZHJhZyBpbWFnZXMgd2hlbiBwcmV2ZW50RGVmYXVsdCBpc24ndCBjYWxsZWQgb24gbW91c2Vkb3duLFxyXG4gICAgLy8gZXZlbiB0aG91Z2ggcHJldmVudERlZmF1bHQgSVMgY2FsbGVkIG9uIG1vdXNlbW92ZS4gVGhhdCdzIHdoeSB3ZSBwcmV2ZW50RGVmYXVsdCBtb3VzZWRvd24uXHJcbiAgICBjb25zdCBpc01vdXNlUG9pbnRlciA9IGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJztcclxuXHJcbiAgICAvLyBBbGxvdyBkcmFnZ2luZyBvbmx5IHZpYSBsZWZ0IG1vdXNlIGJ1dHRvbi5cclxuICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LmJ1dHRvblxyXG4gICAgaWYgKGlzTW91c2VQb2ludGVyICYmIGUuYnV0dG9uID4gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIC8vIGlmIFBob3RvU3dpcGUgaXMgb3BlbmluZyBvciBjbG9zaW5nXHJcbiAgICBpZiAoIXBzd3Aub3BlbmVyLmlzT3Blbikge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHN3cC5kaXNwYXRjaCgncG9pbnRlckRvd24nLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTW91c2VQb2ludGVyKSB7XHJcbiAgICAgIHBzd3AubW91c2VEZXRlY3RlZCgpO1xyXG5cclxuICAgICAgLy8gcHJldmVudERlZmF1bHQgbW91c2UgZXZlbnQgdG8gcHJldmVudFxyXG4gICAgICAvLyBicm93c2VyIGltYWdlIGRyYWcgZmVhdHVyZVxyXG4gICAgICB0aGlzLl9wcmV2ZW50UG9pbnRlckV2ZW50QmVoYXZpb3VyKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUG9pbnRzKGUsICdkb3duJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmRyYWdBeGlzID0gbnVsbDtcclxuICAgICAgLy8gd2UgbmVlZCB0byBzdG9yZSBpbml0aWFsIHBvaW50IHRvIGRldGVybWluZSB0aGUgbWFpbiBheGlzLFxyXG4gICAgICAvLyBkcmFnIGlzIGFjdGl2YXRlZCBvbmx5IGFmdGVyIHRoZSBheGlzIGlzIGRldGVybWluZWRcclxuICAgICAgZXF1YWxpemVQb2ludHModGhpcy5zdGFydFAxLCB0aGlzLnAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID4gMSkge1xyXG4gICAgICAvLyBUYXAgb3IgZG91YmxlIHRhcCBzaG91bGQgbm90IHRyaWdnZXIgaWYgbW9yZSB0aGFuIG9uZSBwb2ludGVyXHJcbiAgICAgIHRoaXMuX2NsZWFyVGFwVGltZXIoKTtcclxuICAgICAgdGhpcy5pc011bHRpdG91Y2ggPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pc011bHRpdG91Y2ggPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgb25Qb2ludGVyTW92ZShlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGFsd2F5cyBwcmV2ZW50RGVmYXVsdCBtb3ZlIGV2ZW50XHJcblxyXG4gICAgaWYgKCF0aGlzLl9udW1BY3RpdmVQb2ludHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVBvaW50cyhlLCAnbW92ZScpO1xyXG5cclxuICAgIGlmICh0aGlzLnBzd3AuZGlzcGF0Y2goJ3BvaW50ZXJNb3ZlJywgeyBvcmlnaW5hbEV2ZW50OiBlIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDEgJiYgIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICBpZiAoIXRoaXMuZHJhZ0F4aXMpIHtcclxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVEcmFnRGlyZWN0aW9uKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYWcgYXhpcyB3YXMgZGV0ZWN0ZWQsIGVtaXQgZHJhZy5zdGFydFxyXG4gICAgICBpZiAodGhpcy5kcmFnQXhpcyAmJiAhdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNab29taW5nKSB7XHJcbiAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy56b29tTGV2ZWxzLmVuZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jbGVhclRhcFRpbWVyKCk7IC8vIFRhcCBjYW4gbm90IHRyaWdnZXIgYWZ0ZXIgZHJhZ1xyXG5cclxuICAgICAgICAvLyBBZGp1c3Qgc3RhcnRpbmcgcG9pbnRcclxuICAgICAgICB0aGlzLl91cGRhdGVTdGFydFBvaW50cygpO1xyXG4gICAgICAgIHRoaXMuX2ludGVydmFsVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgLy90aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9pbnRlcnZhbFRpbWU7XHJcbiAgICAgICAgdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgZXF1YWxpemVQb2ludHModGhpcy5faW50ZXJ2YWxQMSwgdGhpcy5wMSk7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAwO1xyXG4gICAgICAgIHRoaXMuZHJhZy5zdGFydCgpO1xyXG5cclxuICAgICAgICB0aGlzLl9yYWZTdG9wTG9vcCgpO1xyXG4gICAgICAgIHRoaXMuX3JhZlJlbmRlckxvb3AoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPiAxICYmICF0aGlzLmlzWm9vbWluZykge1xyXG4gICAgICB0aGlzLl9maW5pc2hEcmFnKCk7XHJcblxyXG4gICAgICB0aGlzLmlzWm9vbWluZyA9IHRydWU7XHJcblxyXG4gICAgICAvLyBBZGp1c3Qgc3RhcnRpbmcgcG9pbnRzXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXJ0UG9pbnRzKCk7XHJcblxyXG4gICAgICB0aGlzLnpvb21MZXZlbHMuc3RhcnQoKTtcclxuXHJcbiAgICAgIHRoaXMuX3JhZlN0b3BMb29wKCk7XHJcbiAgICAgIHRoaXMuX3JhZlJlbmRlckxvb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2ZpbmlzaERyYWcoKSB7XHJcbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gVHJ5IHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eSxcclxuICAgICAgLy8gaWYgaXQgd2Fzbid0IGNhbGN1bGF0ZWQgeWV0IGluIGRyYWcuY2hhbmdlXHJcbiAgICAgIGlmICghdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVmVsb2NpdHkodHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZHJhZy5lbmQoKTtcclxuICAgICAgdGhpcy5kcmFnQXhpcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZVxyXG4gICAqL1xyXG4gIG9uUG9pbnRlclVwKGUpIHtcclxuICAgIGlmICghdGhpcy5fbnVtQWN0aXZlUG9pbnRzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVQb2ludHMoZSwgJ3VwJyk7XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgncG9pbnRlclVwJywgeyBvcmlnaW5hbEV2ZW50OiBlIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDApIHtcclxuICAgICAgdGhpcy5fcmFmU3RvcExvb3AoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICB0aGlzLl9maW5pc2hEcmFnKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNab29taW5nICYmICF0aGlzLmlzTXVsdGl0b3VjaCkge1xyXG4gICAgICAgIC8vdGhpcy56b29tTGV2ZWxzLmNvcnJlY3Rab29tUGFuKCk7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoVGFwKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA8IDIgJiYgdGhpcy5pc1pvb21pbmcpIHtcclxuICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy56b29tTGV2ZWxzLmVuZCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA9PT0gMSkge1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgMSBwb2ludCBsZWZ0LCB3ZSBuZWVkIHRvIHJlaW5pdGlhdGUgZHJhZ1xyXG4gICAgICAgIHRoaXMuZHJhZ0F4aXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YXJ0UG9pbnRzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3JhZlJlbmRlckxvb3AoKSB7XHJcbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuaXNab29taW5nKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVZlbG9jaXR5KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcG9pbnRlciBtb3ZlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAgICBpZiAoIXBvaW50c0VxdWFsKHRoaXMucDEsIHRoaXMucHJldlAxKSkge1xyXG4gICAgICAgICAgdGhpcy5kcmFnLmNoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLmlzWm9vbWluZykgKi8ge1xyXG4gICAgICAgIGlmICghcG9pbnRzRXF1YWwodGhpcy5wMSwgdGhpcy5wcmV2UDEpXHJcbiAgICAgICAgICAgIHx8ICFwb2ludHNFcXVhbCh0aGlzLnAyLCB0aGlzLnByZXZQMikpIHtcclxuICAgICAgICAgIHRoaXMuem9vbUxldmVscy5jaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVByZXZQb2ludHMoKTtcclxuICAgICAgdGhpcy5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmFmUmVuZGVyTG9vcC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB2ZWxvY2l0eSBhdCA1MG1zIGludGVydmFsXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXVxyXG4gICAqL1xyXG4gIF91cGRhdGVWZWxvY2l0eShmb3JjZSkge1xyXG4gICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWUgLSB0aGlzLl9pbnRlcnZhbFRpbWU7XHJcblxyXG4gICAgaWYgKGR1cmF0aW9uIDwgNTAgJiYgIWZvcmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdGhpcy52ZWxvY2l0eS54ID0gdGhpcy5fZ2V0VmVsb2NpdHkoJ3gnLCBkdXJhdGlvbik7XHJcbiAgICB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLl9nZXRWZWxvY2l0eSgneScsIGR1cmF0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9pbnRlcnZhbFRpbWUgPSB0aW1lO1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5faW50ZXJ2YWxQMSwgdGhpcy5wMSk7XHJcbiAgICB0aGlzLl92ZWxvY2l0eUNhbGN1bGF0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZVxyXG4gICAqL1xyXG4gIF9maW5pc2hUYXAoZSkge1xyXG4gICAgY29uc3QgeyBtYWluU2Nyb2xsIH0gPSB0aGlzLnBzd3A7XHJcblxyXG4gICAgLy8gRG8gbm90IHRyaWdnZXIgdGFwIGV2ZW50cyBpZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkXHJcbiAgICBpZiAobWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICAvLyByZXN0b3JlIG1haW4gc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgIC8vICh1c3VhbGx5IGhhcHBlbnMgaWYgc3RvcHBlZCBpbiB0aGUgbWlkZGxlIG9mIGFuaW1hdGlvbilcclxuICAgICAgbWFpblNjcm9sbC5tb3ZlSW5kZXhCeSgwLCB0cnVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIG5vdCB0cmlnZ2VyIHRhcCBmb3IgdG91Y2hjYW5jZWwgb3IgcG9pbnRlcmNhbmNlbFxyXG4gICAgaWYgKGUudHlwZS5pbmRleE9mKCdjYW5jZWwnKSA+IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyaWdnZXIgY2xpY2sgaW5zdGVhZCBvZiB0YXAgZm9yIG1vdXNlIGV2ZW50c1xyXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcclxuICAgICAgdGhpcy50YXBIYW5kbGVyLmNsaWNrKHRoaXMuc3RhcnRQMSwgZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNhYmxlIGRlbGF5IGlmIHRoZXJlIGlzIG5vIGRvdWJsZVRhcEFjdGlvblxyXG4gICAgY29uc3QgdGFwRGVsYXkgPSB0aGlzLnBzd3Aub3B0aW9ucy5kb3VibGVUYXBBY3Rpb24gPyBET1VCTEVfVEFQX0RFTEFZIDogMDtcclxuXHJcbiAgICAvLyBJZiB0YXBUaW1lciBpcyBkZWZpbmVkIC0gd2UgdGFwcGVkIHJlY2VudGx5LFxyXG4gICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgdGFwIGlzIGNsb3NlIHRvIHRoZSBwcmV2aW91cyBvbmUsXHJcbiAgICAvLyBpZiB5ZXMgLSB0cmlnZ2VyIGRvdWJsZSB0YXBcclxuICAgIGlmICh0aGlzLl90YXBUaW1lcikge1xyXG4gICAgICB0aGlzLl9jbGVhclRhcFRpbWVyKCk7XHJcbiAgICAgIC8vIENoZWNrIGlmIHR3byB0YXBzIHdlcmUgbW9yZSBvciBsZXNzIG9uIHRoZSBzYW1lIHBsYWNlXHJcbiAgICAgIGlmIChnZXREaXN0YW5jZUJldHdlZW4odGhpcy5fbGFzdFN0YXJ0UDEsIHRoaXMuc3RhcnRQMSkgPCBNSU5fVEFQX0RJU1RBTkNFKSB7XHJcbiAgICAgICAgdGhpcy50YXBIYW5kbGVyLmRvdWJsZVRhcCh0aGlzLnN0YXJ0UDEsIGUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLl9sYXN0U3RhcnRQMSwgdGhpcy5zdGFydFAxKTtcclxuICAgICAgdGhpcy5fdGFwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnRhcEhhbmRsZXIudGFwKHRoaXMuc3RhcnRQMSwgZSk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJUYXBUaW1lcigpO1xyXG4gICAgICB9LCB0YXBEZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9jbGVhclRhcFRpbWVyKCkge1xyXG4gICAgaWYgKHRoaXMuX3RhcFRpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90YXBUaW1lcik7XHJcbiAgICAgIHRoaXMuX3RhcFRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB2ZWxvY2l0eSBmb3IgYXhpc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyd4JyB8ICd5J30gYXhpc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldFZlbG9jaXR5KGF4aXMsIGR1cmF0aW9uKSB7XHJcbiAgICAvLyBkaXNwbGFjZW1lbnQgaXMgbGlrZSBkaXN0YW5jZSwgYnV0IGNhbiBiZSBuZWdhdGl2ZS5cclxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMucDFbYXhpc10gLSB0aGlzLl9pbnRlcnZhbFAxW2F4aXNdO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhkaXNwbGFjZW1lbnQpID4gMSAmJiBkdXJhdGlvbiA+IDUpIHtcclxuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudCAvIGR1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmFmU3RvcExvb3AoKSB7XHJcbiAgICBpZiAodGhpcy5yYWYpIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xyXG4gICAgICB0aGlzLnJhZiA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgX3ByZXZlbnRQb2ludGVyRXZlbnRCZWhhdmlvdXIoZSkge1xyXG4gICAgLy8gVE9ETyBmaW5kIGEgd2F5IHRvIGRpc2FibGUgZS5wcmV2ZW50RGVmYXVsdCBvbiBzb21lIGVsZW1lbnRzXHJcbiAgICAvLyAgICAgIHZpYSBldmVudCBvciBzb21lIGNsYXNzIG9yIHNvbWV0aGluZ1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIGFuZCBub3JtYWxpemVzIHBvaW50cyBmcm9tIHRoZSB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlciBldmVudC5cclxuICAgKiBVcGRhdGVzIHAxIGFuZCBwMi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnQgfCBUb3VjaEV2ZW50fSBlXHJcbiAgICogQHBhcmFtIHsndXAnIHwgJ2Rvd24nIHwgJ21vdmUnfSBwb2ludGVyVHlwZSBOb3JtYWxpemVkIHBvaW50ZXIgdHlwZVxyXG4gICAqL1xyXG4gIF91cGRhdGVQb2ludHMoZSwgcG9pbnRlclR5cGUpIHtcclxuICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkKSB7XHJcbiAgICAgIGNvbnN0IHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7UG9pbnRlckV2ZW50fSAqLyAoZSk7XHJcbiAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBjdXJyZW50IHBvaW50ZXIgaW4gb25nb2luZyBwb2ludGVycyBieSBpdHMgSURcclxuICAgICAgY29uc3QgcG9pbnRlckluZGV4ID0gdGhpcy5fb25nb2luZ1BvaW50ZXJzLmZpbmRJbmRleCgob25nb2luZ1BvaW50ZXIpID0+IHtcclxuICAgICAgICByZXR1cm4gb25nb2luZ1BvaW50ZXIuaWQgPT09IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSAndXAnICYmIHBvaW50ZXJJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgLy8gcmVsZWFzZSB0aGUgcG9pbnRlciAtIHJlbW92ZSBpdCBmcm9tIG9uZ29pbmdcclxuICAgICAgICB0aGlzLl9vbmdvaW5nUG9pbnRlcnMuc3BsaWNlKHBvaW50ZXJJbmRleCwgMSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09ICdkb3duJyAmJiBwb2ludGVySW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgLy8gYWRkIG5ldyBwb2ludGVyXHJcbiAgICAgICAgdGhpcy5fb25nb2luZ1BvaW50ZXJzLnB1c2godGhpcy5fY29udmVydEV2ZW50UG9zVG9Qb2ludChwb2ludGVyRXZlbnQsIHsgeDogMCwgeTogMCB9KSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlckluZGV4ID4gLTEpIHtcclxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcG9pbnRlclxyXG4gICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQocG9pbnRlckV2ZW50LCB0aGlzLl9vbmdvaW5nUG9pbnRlcnNbcG9pbnRlckluZGV4XSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IHRoaXMuX29uZ29pbmdQb2ludGVycy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB1cGRhdGUgcG9pbnRzIHRoYXQgUGhvdG9Td2lwZSB1c2VzXHJcbiAgICAgIC8vIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgc2NhbGVcclxuICAgICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA+IDApIHtcclxuICAgICAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnAxLCB0aGlzLl9vbmdvaW5nUG9pbnRlcnNbMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID4gMSkge1xyXG4gICAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucDIsIHRoaXMuX29uZ29pbmdQb2ludGVyc1sxXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHRvdWNoRXZlbnQgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovIChlKTtcclxuXHJcbiAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IDA7XHJcbiAgICAgIGlmICh0b3VjaEV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xKSB7XHJcbiAgICAgICAgLy8gVG91Y2ggRXZlbnRcclxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVG91Y2hFdmVudFxyXG4gICAgICAgIGlmICh0b3VjaEV2ZW50LnRvdWNoZXMgJiYgdG91Y2hFdmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQodG91Y2hFdmVudC50b3VjaGVzWzBdLCB0aGlzLnAxKTtcclxuICAgICAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cysrO1xyXG4gICAgICAgICAgaWYgKHRvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQodG91Y2hFdmVudC50b3VjaGVzWzFdLCB0aGlzLnAyKTtcclxuICAgICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE1vdXNlIEV2ZW50XHJcbiAgICAgICAgdGhpcy5fY29udmVydEV2ZW50UG9zVG9Qb2ludCgvKiogQHR5cGUge1BvaW50ZXJFdmVudH0gKi8gKGUpLCB0aGlzLnAxKTtcclxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09ICd1cCcpIHtcclxuICAgICAgICAgIC8vIGNsZWFyIGFsbCBwb2ludHMgb24gbW91c2V1cFxyXG4gICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogdXBkYXRlIHBvaW50cyB0aGF0IHdlcmUgdXNlZCBkdXJpbmcgcHJldmlvdXMgckFGIHRpY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF91cGRhdGVQcmV2UG9pbnRzKCkge1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5wcmV2UDEsIHRoaXMucDEpO1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5wcmV2UDIsIHRoaXMucDIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIHVwZGF0ZSBwb2ludHMgYXQgdGhlIHN0YXJ0IG9mIGdlc3R1cmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF91cGRhdGVTdGFydFBvaW50cygpIHtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQMSwgdGhpcy5wMSk7XHJcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnN0YXJ0UDIsIHRoaXMucDIpO1xyXG4gICAgdGhpcy5fdXBkYXRlUHJldlBvaW50cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBwcml2YXRlICovXHJcbiAgX2NhbGN1bGF0ZURyYWdEaXJlY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKCkpIHtcclxuICAgICAgLy8gaWYgbWFpbiBzY3JvbGwgcG9zaXRpb24gaXMgc2hpZnRlZCDigJMgZGlyZWN0aW9uIGlzIGFsd2F5cyBob3Jpem9udGFsXHJcbiAgICAgIHRoaXMuZHJhZ0F4aXMgPSAneCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjYWxjdWxhdGUgZGVsdGEgb2YgdGhlIGxhc3QgdG91Y2htb3ZlIHRpY2tcclxuICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHRoaXMucDEueCAtIHRoaXMuc3RhcnRQMS54KSAtIE1hdGguYWJzKHRoaXMucDEueSAtIHRoaXMuc3RhcnRQMS55KTtcclxuXHJcbiAgICAgIGlmIChkaWZmICE9PSAwKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgcG9pbnRlciB3YXMgc2hpZnRlZCBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxyXG4gICAgICAgIGNvbnN0IGF4aXNUb0NoZWNrID0gZGlmZiA+IDAgPyAneCcgOiAneSc7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnAxW2F4aXNUb0NoZWNrXSAtIHRoaXMuc3RhcnRQMVtheGlzVG9DaGVja10pID49IEFYSVNfU1dJUEVfSFlTVEVSSVNJUykge1xyXG4gICAgICAgICAgdGhpcy5kcmFnQXhpcyA9IGF4aXNUb0NoZWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdG91Y2gsIHBvaW50ZXIgb3IgbW91c2UgZXZlbnRcclxuICAgKiB0byBQaG90b1N3aXBlIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1RvdWNoIHwgUG9pbnRlckV2ZW50fSBlXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcFxyXG4gICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgKi9cclxuICBfY29udmVydEV2ZW50UG9zVG9Qb2ludChlLCBwKSB7XHJcbiAgICBwLnggPSBlLnBhZ2VYIC0gdGhpcy5wc3dwLm9mZnNldC54O1xyXG4gICAgcC55ID0gZS5wYWdlWSAtIHRoaXMucHN3cC5vZmZzZXQueTtcclxuXHJcbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZSkge1xyXG4gICAgICBwLmlkID0gZS5wb2ludGVySWQ7XHJcbiAgICB9IGVsc2UgaWYgKGUuaWRlbnRpZmllciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHAuaWQgPSBlLmlkZW50aWZpZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgX29uQ2xpY2soZSkge1xyXG4gICAgLy8gRG8gbm90IGFsbG93IGNsaWNrIGV2ZW50IHRvIHBhc3MgdGhyb3VnaCBhZnRlciBkcmFnXHJcbiAgICBpZiAodGhpcy5wc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKCkpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9zbGlkZS5qcycpLmRlZmF1bHR9IFNsaWRlICovXHJcblxyXG4vKiogQHR5cGVkZWYge3sgZWw6IEhUTUxEaXZFbGVtZW50OyBzbGlkZT86IFNsaWRlIH19IEl0ZW1Ib2xkZXIgKi9cclxuXHJcbmNvbnN0IE1BSU5fU0NST0xMX0VORF9GUklDVElPTiA9IDAuMzU7XHJcblxyXG5cclxuLy8gY29uc3QgTUlOX1NXSVBFX1RSQU5TSVRJT05fRFVSQVRJT04gPSAyNTA7XHJcbi8vIGNvbnN0IE1BWF9TV0lQRV9UUkFCU0lUSU9OX0RVUkFUSU9OID0gNTAwO1xyXG4vLyBjb25zdCBERUZBVUxUX1NXSVBFX1RSQU5TSVRJT05fRFVSQVRJT04gPSAzMzM7XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBtb3ZlbWVudCBvZiB0aGUgbWFpbiBzY3JvbGxpbmcgY29udGFpbmVyXHJcbiAqIChmb3IgZXhhbXBsZSwgaXQgcmVwb3NpdGlvbnMgd2hlbiB1c2VyIHN3aXBlcyBsZWZ0IG9yIHJpZ2h0KS5cclxuICpcclxuICogQWxzbyBzdG9yZXMgaXRzIHN0YXRlLlxyXG4gKi9cclxuY2xhc3MgTWFpblNjcm9sbCB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHN3cCkge1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuICAgIHRoaXMueCA9IDA7XHJcbiAgICB0aGlzLnNsaWRlV2lkdGggPSAwO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9jdXJyUG9zaXRpb25JbmRleCA9IDA7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4ID0gMDtcclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCA9IC0xO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7SXRlbUhvbGRlcltdfSAqL1xyXG4gICAgdGhpcy5pdGVtSG9sZGVycyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gdGhlIHNjcm9sbGVyIGFuZCBzbGlkZSBjb250YWluZXJzXHJcbiAgICogYWNjb3JkaW5nIHRvIHZpZXdwb3J0IHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNpemVTbGlkZXNdIFdoZXRoZXIgc2xpZGVzIGNvbnRlbnQgc2hvdWxkIHJlc2l6ZWRcclxuICAgKi9cclxuICByZXNpemUocmVzaXplU2xpZGVzKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBuZXdTbGlkZVdpZHRoID0gTWF0aC5yb3VuZChcclxuICAgICAgcHN3cC52aWV3cG9ydFNpemUueCArIHBzd3Audmlld3BvcnRTaXplLnggKiBwc3dwLm9wdGlvbnMuc3BhY2luZ1xyXG4gICAgKTtcclxuICAgIC8vIE1vYmlsZSBicm93c2VycyBtaWdodCB0cmlnZ2VyIGEgcmVzaXplIGV2ZW50IGR1cmluZyBhIGdlc3R1cmUuXHJcbiAgICAvLyAoZHVlIHRvIHRvb2xiYXIgYXBwZWFyaW5nIG9yIGhpZGluZykuXHJcbiAgICAvLyBBdm9pZCByZS1hZGp1c3RpbmcgbWFpbiBzY3JvbGwgcG9zaXRpb24gaWYgd2lkdGggd2Fzbid0IGNoYW5nZWRcclxuICAgIGNvbnN0IHNsaWRlV2lkdGhDaGFuZ2VkID0gKG5ld1NsaWRlV2lkdGggIT09IHRoaXMuc2xpZGVXaWR0aCk7XHJcblxyXG4gICAgaWYgKHNsaWRlV2lkdGhDaGFuZ2VkKSB7XHJcbiAgICAgIHRoaXMuc2xpZGVXaWR0aCA9IG5ld1NsaWRlV2lkdGg7XHJcbiAgICAgIHRoaXMubW92ZVRvKHRoaXMuZ2V0Q3VyclNsaWRlWCgpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLml0ZW1Ib2xkZXJzLmZvckVhY2goKGl0ZW1Ib2xkZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmIChzbGlkZVdpZHRoQ2hhbmdlZCkge1xyXG4gICAgICAgIHNldFRyYW5zZm9ybShpdGVtSG9sZGVyLmVsLCAoaW5kZXggKyB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMuc2xpZGVXaWR0aCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZXNpemVTbGlkZXMgJiYgaXRlbUhvbGRlci5zbGlkZSkge1xyXG4gICAgICAgIGl0ZW1Ib2xkZXIuc2xpZGUucmVzaXplKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgWCBwb3NpdGlvbiBvZiB0aGUgbWFpbiBzY3JvbGxlciB0byB6ZXJvXHJcbiAgICovXHJcbiAgcmVzZXRQb3NpdGlvbigpIHtcclxuICAgIC8vIFBvc2l0aW9uIG9uIHRoZSBtYWluIHNjcm9sbGVyIChvZmZzZXQpXHJcbiAgICAvLyBpdCBpcyBpbmRlcGVuZGVudCBmcm9tIHNsaWRlIGluZGV4XHJcbiAgICB0aGlzLl9jdXJyUG9zaXRpb25JbmRleCA9IDA7XHJcbiAgICB0aGlzLl9wcmV2UG9zaXRpb25JbmRleCA9IDA7XHJcblxyXG4gICAgLy8gVGhpcyB3aWxsIGZvcmNlIHJlY2FsY3VsYXRpb24gb2Ygc2l6ZSBvbiBuZXh0IHJlc2l6ZSgpXHJcbiAgICB0aGlzLnNsaWRlV2lkdGggPSAwO1xyXG5cclxuICAgIC8vIF9jb250YWluZXJTaGlmdEluZGV4KnZpZXdwb3J0U2l6ZSB3aWxsIGdpdmUgeW91IGFtb3VudCBvZiB0cmFuc2Zvcm0gb2YgdGhlIGN1cnJlbnQgc2xpZGVcclxuICAgIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggPSAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbmQgYXBwZW5kIGFycmF5IG9mIHRocmVlIGl0ZW1zXHJcbiAgICogdGhhdCBob2xkIGRhdGEgYWJvdXQgc2xpZGVzIGluIERPTVxyXG4gICAqL1xyXG4gIGFwcGVuZEhvbGRlcnMoKSB7XHJcbiAgICB0aGlzLml0ZW1Ib2xkZXJzID0gW107XHJcblxyXG4gICAgLy8gYXBwZW5kIG91ciB0aHJlZSBzbGlkZSBob2xkZXJzIC1cclxuICAgIC8vIHByZXZpb3VzLCBjdXJyZW50LCBhbmQgbmV4dFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgY29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19pdGVtJywgJ2RpdicsIHRoaXMucHN3cC5jb250YWluZXIpO1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXJvbGVkZXNjcmlwdGlvbicsICdzbGlkZScpO1xyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcclxuXHJcbiAgICAgIC8vIGhpZGUgbmVhcmJ5IGl0ZW0gaG9sZGVycyB1bnRpbCBpbml0aWFsIHpvb20gYW5pbWF0aW9uIGZpbmlzaGVzICh0byBhdm9pZCBleHRyYSBQYWludHMpXHJcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAoaSA9PT0gMSkgPyAnYmxvY2snIDogJ25vbmUnO1xyXG5cclxuICAgICAgdGhpcy5pdGVtSG9sZGVycy5wdXNoKHtcclxuICAgICAgICBlbCxcclxuICAgICAgICAvL2luZGV4OiAtMVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIG1haW4gc2Nyb2xsIGNhbiBiZSBob3Jpem9udGFsbHkgc3dpcGVkIHRvIHRoZSBuZXh0IG9yIHByZXZpb3VzIHNsaWRlLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGNhbkJlU3dpcGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHN3cC5nZXROdW1JdGVtcygpID4gMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmUgbWFpbiBzY3JvbGwgYnkgWCBhbW91bnQgb2Ygc2xpZGVzLlxyXG4gICAqIEZvciBleGFtcGxlOlxyXG4gICAqICAgYC0xYCB3aWxsIG1vdmUgdG8gdGhlIHByZXZpb3VzIHNsaWRlLFxyXG4gICAqICAgIGAwYCB3aWxsIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgc2xpZGUsXHJcbiAgICogICAgYDNgIHdpbGwgbW92ZSB0aHJlZSBzbGlkZXMgZm9yd2FyZFxyXG4gICAqXHJcbiAgICogSWYgbG9vcCBvcHRpb24gaXMgZW5hYmxlZCAtIGluZGV4IHdpbGwgYmUgYXV0b21hdGljYWxseSBsb29wZWQgdG9vLFxyXG4gICAqIChmb3IgZXhhbXBsZSBgLTFgIHdpbGwgbW92ZSB0byB0aGUgbGFzdCBzbGlkZSBvZiB0aGUgZ2FsbGVyeSkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FuaW1hdGVdXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eVhdXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgaW5kZXggd2FzIGNoYW5nZWQgb3Igbm90XHJcbiAgICovXHJcbiAgbW92ZUluZGV4QnkoZGlmZiwgYW5pbWF0ZSwgdmVsb2NpdHlYKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBsZXQgbmV3SW5kZXggPSBwc3dwLnBvdGVudGlhbEluZGV4ICsgZGlmZjtcclxuICAgIGNvbnN0IG51bVNsaWRlcyA9IHBzd3AuZ2V0TnVtSXRlbXMoKTtcclxuXHJcbiAgICBpZiAocHN3cC5jYW5Mb29wKCkpIHtcclxuICAgICAgbmV3SW5kZXggPSBwc3dwLmdldExvb3BlZEluZGV4KG5ld0luZGV4KTtcclxuICAgICAgY29uc3QgZGlzdGFuY2UgPSAoZGlmZiArIG51bVNsaWRlcykgJSBudW1TbGlkZXM7XHJcbiAgICAgIGlmIChkaXN0YW5jZSA8PSBudW1TbGlkZXMgLyAyKSB7XHJcbiAgICAgICAgLy8gZ28gZm9yd2FyZFxyXG4gICAgICAgIGRpZmYgPSBkaXN0YW5jZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBnbyBiYWNrd2FyZHNcclxuICAgICAgICBkaWZmID0gZGlzdGFuY2UgLSBudW1TbGlkZXM7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcclxuICAgICAgICBuZXdJbmRleCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAobmV3SW5kZXggPj0gbnVtU2xpZGVzKSB7XHJcbiAgICAgICAgbmV3SW5kZXggPSBudW1TbGlkZXMgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIGRpZmYgPSBuZXdJbmRleCAtIHBzd3AucG90ZW50aWFsSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHN3cC5wb3RlbnRpYWxJbmRleCA9IG5ld0luZGV4O1xyXG4gICAgdGhpcy5fY3VyclBvc2l0aW9uSW5kZXggLT0gZGlmZjtcclxuXHJcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RvcE1haW5TY3JvbGwoKTtcclxuXHJcbiAgICBjb25zdCBkZXN0aW5hdGlvblggPSB0aGlzLmdldEN1cnJTbGlkZVgoKTtcclxuICAgIGlmICghYW5pbWF0ZSkge1xyXG4gICAgICB0aGlzLm1vdmVUbyhkZXN0aW5hdGlvblgpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUN1cnJJdGVtKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwc3dwLmFuaW1hdGlvbnMuc3RhcnRTcHJpbmcoe1xyXG4gICAgICAgIGlzTWFpblNjcm9sbDogdHJ1ZSxcclxuICAgICAgICBzdGFydDogdGhpcy54LFxyXG4gICAgICAgIGVuZDogZGVzdGluYXRpb25YLFxyXG4gICAgICAgIHZlbG9jaXR5OiB2ZWxvY2l0eVggfHwgMCxcclxuICAgICAgICBuYXR1cmFsRnJlcXVlbmN5OiAzMCxcclxuICAgICAgICBkYW1waW5nUmF0aW86IDEsIC8vMC43LFxyXG4gICAgICAgIG9uVXBkYXRlOiAoeCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5tb3ZlVG8oeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJJdGVtKCk7XHJcbiAgICAgICAgICBwc3dwLmFwcGVuZEhlYXZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxldCBjdXJyRGlmZiA9IHBzd3AucG90ZW50aWFsSW5kZXggLSBwc3dwLmN1cnJJbmRleDtcclxuICAgICAgaWYgKHBzd3AuY2FuTG9vcCgpKSB7XHJcbiAgICAgICAgY29uc3QgY3VyckRpc3RhbmNlID0gKGN1cnJEaWZmICsgbnVtU2xpZGVzKSAlIG51bVNsaWRlcztcclxuICAgICAgICBpZiAoY3VyckRpc3RhbmNlIDw9IG51bVNsaWRlcyAvIDIpIHtcclxuICAgICAgICAgIC8vIGdvIGZvcndhcmRcclxuICAgICAgICAgIGN1cnJEaWZmID0gY3VyckRpc3RhbmNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBnbyBiYWNrd2FyZHNcclxuICAgICAgICAgIGN1cnJEaWZmID0gY3VyckRpc3RhbmNlIC0gbnVtU2xpZGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRm9yY2UtYXBwZW5kIG5ldyBzbGlkZXMgZHVyaW5nIHRyYW5zaXRpb25cclxuICAgICAgLy8gaWYgZGlmZmVyZW5jZSBiZXR3ZWVuIHNsaWRlcyBpcyBtb3JlIHRoYW4gMVxyXG4gICAgICBpZiAoTWF0aC5hYnMoY3VyckRpZmYpID4gMSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyckl0ZW0oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBCb29sZWFuKGRpZmYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogWCBwb3NpdGlvbiBvZiB0aGUgbWFpbiBzY3JvbGwgZm9yIHRoZSBjdXJyZW50IHNsaWRlXHJcbiAgICogKGlnbm9yZXMgcG9zaXRpb24gZHVyaW5nIGRyYWdnaW5nKVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0Q3VyclNsaWRlWCgpIHtcclxuICAgIHJldHVybiB0aGlzLnNsaWRlV2lkdGggKiB0aGlzLl9jdXJyUG9zaXRpb25JbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgc2Nyb2xsIHBvc2l0aW9uIGlzIHNoaWZ0ZWQuXHJcbiAgICogRm9yIGV4YW1wbGUsIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHNjcm9sbCBpcyBiZWluZyBkcmFnZ2VkIG9yIGFuaW1hdGVkLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGlzU2hpZnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnggIT09IHRoaXMuZ2V0Q3VyclNsaWRlWCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNsaWRlcyBYIHBvc2l0aW9ucyBhbmQgc2V0IHRoZWlyIGNvbnRlbnRcclxuICAgKi9cclxuICB1cGRhdGVDdXJySXRlbSgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHBvc2l0aW9uRGlmZmVyZW5jZSA9IHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4IC0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XHJcblxyXG4gICAgaWYgKCFwb3NpdGlvbkRpZmZlcmVuY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4ID0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XHJcblxyXG4gICAgcHN3cC5jdXJySW5kZXggPSBwc3dwLnBvdGVudGlhbEluZGV4O1xyXG5cclxuICAgIGxldCBkaWZmQWJzID0gTWF0aC5hYnMocG9zaXRpb25EaWZmZXJlbmNlKTtcclxuICAgIC8qKiBAdHlwZSB7SXRlbUhvbGRlciB8IHVuZGVmaW5lZH0gKi9cclxuICAgIGxldCB0ZW1wSG9sZGVyO1xyXG5cclxuICAgIGlmIChkaWZmQWJzID49IDMpIHtcclxuICAgICAgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCArPSBwb3NpdGlvbkRpZmZlcmVuY2UgKyAocG9zaXRpb25EaWZmZXJlbmNlID4gMCA/IC0zIDogMyk7XHJcbiAgICAgIGRpZmZBYnMgPSAzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZkFiczsgaSsrKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbkRpZmZlcmVuY2UgPiAwKSB7XHJcbiAgICAgICAgdGVtcEhvbGRlciA9IHRoaXMuaXRlbUhvbGRlcnMuc2hpZnQoKTtcclxuICAgICAgICBpZiAodGVtcEhvbGRlcikge1xyXG4gICAgICAgICAgdGhpcy5pdGVtSG9sZGVyc1syXSA9IHRlbXBIb2xkZXI7IC8vIG1vdmUgZmlyc3QgdG8gbGFzdFxyXG5cclxuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXgrKztcclxuXHJcbiAgICAgICAgICBzZXRUcmFuc2Zvcm0odGVtcEhvbGRlci5lbCwgKHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggKyAyKSAqIHRoaXMuc2xpZGVXaWR0aCk7XHJcblxyXG4gICAgICAgICAgcHN3cC5zZXRDb250ZW50KHRlbXBIb2xkZXIsIChwc3dwLmN1cnJJbmRleCAtIGRpZmZBYnMpICsgaSArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0ZW1wSG9sZGVyID0gdGhpcy5pdGVtSG9sZGVycy5wb3AoKTtcclxuICAgICAgICBpZiAodGVtcEhvbGRlcikge1xyXG4gICAgICAgICAgdGhpcy5pdGVtSG9sZGVycy51bnNoaWZ0KHRlbXBIb2xkZXIpOyAvLyBtb3ZlIGxhc3QgdG8gZmlyc3RcclxuXHJcbiAgICAgICAgICB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4LS07XHJcblxyXG4gICAgICAgICAgc2V0VHJhbnNmb3JtKHRlbXBIb2xkZXIuZWwsIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggKiB0aGlzLnNsaWRlV2lkdGgpO1xyXG5cclxuICAgICAgICAgIHBzd3Auc2V0Q29udGVudCh0ZW1wSG9sZGVyLCAocHN3cC5jdXJySW5kZXggKyBkaWZmQWJzKSAtIGkgLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCB0cmFuc2Zyb20gZXZlcnkgNTBpc2ggbmF2aWdhdGlvbnMgaW4gb25lIGRpcmVjdGlvbi5cclxuICAgIC8vXHJcbiAgICAvLyBPdGhlcndpc2UgdHJhbnNmb3JtIHdpbGwga2VlcCBncm93aW5nIGluZGVmaW5pdGVseSxcclxuICAgIC8vIHdoaWNoIG1pZ2h0IGNhdXNlIGlzc3VlcyBhcyBicm93c2VycyBoYXZlIGEgbWF4aW11bSB0cmFuc2Zvcm0gbGltaXQuXHJcbiAgICAvLyBJIHdhc24ndCBhYmxlIHRvIHJlYWNoIGl0LCBidXQganVzdCB0byBiZSBzYWZlLlxyXG4gICAgLy8gVGhpcyBzaG91bGQgbm90IGNhdXNlIG5vdGljYWJsZSBsYWcuXHJcbiAgICBpZiAoTWF0aC5hYnModGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCkgPiA1MCAmJiAhdGhpcy5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24oKTtcclxuICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYW4gdHJhbnNpdGlvbiBtaWdodCBiZSBydW5uaW5nIChhbmQgY29uc250YW50bHkgdXBkYXRpbmcgcGFuIHBvc2l0aW9uKVxyXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcclxuXHJcbiAgICB0aGlzLml0ZW1Ib2xkZXJzLmZvckVhY2goKGl0ZW1Ib2xkZXIsIGkpID0+IHtcclxuICAgICAgaWYgKGl0ZW1Ib2xkZXIuc2xpZGUpIHtcclxuICAgICAgICAvLyBTbGlkZSBpbiB0aGUgMm5kIGhvbGRlciBpcyBhbHdheXMgYWN0aXZlXHJcbiAgICAgICAgaXRlbUhvbGRlci5zbGlkZS5zZXRJc0FjdGl2ZShpID09PSAxKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcHN3cC5jdXJyU2xpZGUgPSB0aGlzLml0ZW1Ib2xkZXJzWzFdPy5zbGlkZTtcclxuICAgIHBzd3AuY29udGVudExvYWRlci51cGRhdGVMYXp5KHBvc2l0aW9uRGlmZmVyZW5jZSk7XHJcblxyXG4gICAgaWYgKHBzd3AuY3VyclNsaWRlKSB7XHJcbiAgICAgIHBzd3AuY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBwc3dwLmRpc3BhdGNoKCdjaGFuZ2UnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIFggcG9zaXRpb24gb2YgdGhlIG1haW4gc2Nyb2xsIGNvbnRhaW5lclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkcmFnZ2luZ11cclxuICAgKi9cclxuICBtb3ZlVG8oeCwgZHJhZ2dpbmcpIHtcclxuICAgIGlmICghdGhpcy5wc3dwLmNhbkxvb3AoKSAmJiBkcmFnZ2luZykge1xyXG4gICAgICAvLyBBcHBseSBmcmljdGlvblxyXG4gICAgICBsZXQgbmV3U2xpZGVJbmRleE9mZnNldCA9ICgodGhpcy5zbGlkZVdpZHRoICogdGhpcy5fY3VyclBvc2l0aW9uSW5kZXgpIC0geCkgLyB0aGlzLnNsaWRlV2lkdGg7XHJcbiAgICAgIG5ld1NsaWRlSW5kZXhPZmZzZXQgKz0gdGhpcy5wc3dwLmN1cnJJbmRleDtcclxuICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLnJvdW5kKHggLSB0aGlzLngpO1xyXG5cclxuICAgICAgaWYgKChuZXdTbGlkZUluZGV4T2Zmc2V0IDwgMCAmJiBkZWx0YSA+IDApXHJcbiAgICAgICAgICB8fCAobmV3U2xpZGVJbmRleE9mZnNldCA+PSB0aGlzLnBzd3AuZ2V0TnVtSXRlbXMoKSAtIDEgJiYgZGVsdGEgPCAwKSkge1xyXG4gICAgICAgIHggPSB0aGlzLnggKyAoZGVsdGEgKiBNQUlOX1NDUk9MTF9FTkRfRlJJQ1RJT04pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICBpZiAodGhpcy5wc3dwLmNvbnRhaW5lcikge1xyXG4gICAgICBzZXRUcmFuc2Zvcm0odGhpcy5wc3dwLmNvbnRhaW5lciwgeCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdtb3ZlTWFpblNjcm9sbCcsIHsgeCwgZHJhZ2dpbmc6IGRyYWdnaW5nID8/IGZhbHNlIH0pO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5NZXRob2RzPFQ+fSBNZXRob2RzPFQ+XHJcbiAqL1xyXG5cclxuY29uc3QgS2V5Ym9hcmRLZXlDb2Rlc01hcCA9IHtcclxuICBFc2NhcGU6IDI3LFxyXG4gIHo6IDkwLFxyXG4gIEFycm93TGVmdDogMzcsXHJcbiAgQXJyb3dVcDogMzgsXHJcbiAgQXJyb3dSaWdodDogMzksXHJcbiAgQXJyb3dEb3duOiA0MCxcclxuICBUYWI6IDksXHJcbn07XHJcblxyXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBLZXlib2FyZEtleUNvZGVzTWFwfSBUXHJcbiAqIEBwYXJhbSB7VH0ga2V5XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNLZXlTdXBwb3J0ZWRcclxuICogQHJldHVybnMge1QgfCBudW1iZXIgfCB1bmRlZmluZWR9XHJcbiAqL1xyXG5jb25zdCBnZXRLZXlib2FyZEV2ZW50S2V5ID0gKGtleSwgaXNLZXlTdXBwb3J0ZWQpID0+IHtcclxuICByZXR1cm4gaXNLZXlTdXBwb3J0ZWQgPyBrZXkgOiBLZXlib2FyZEtleUNvZGVzTWFwW2tleV07XHJcbn07XHJcblxyXG4vKipcclxuICogLSBNYW5hZ2VzIGtleWJvYXJkIHNob3J0Y3V0cy5cclxuICogLSBIZWxwcyB0cmFwIGZvY3VzIHdpdGhpbiBwaG90b3N3aXBlLlxyXG4gKi9cclxuY2xhc3MgS2V5Ym9hcmQge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3dhc0ZvY3VzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBwc3dwLm9uKCdiaW5kRXZlbnRzJywgKCkgPT4ge1xyXG4gICAgICAvLyBEaWFsb2cgd2FzIGxpa2VseSBvcGVuZWQgYnkga2V5Ym9hcmQgaWYgaW5pdGlhbCBwb2ludCBpcyBub3QgZGVmaW5lZFxyXG4gICAgICBpZiAoIXBzd3Aub3B0aW9ucy5pbml0aWFsUG9pbnRlclBvcykge1xyXG4gICAgICAgIC8vIGZvY3VzIGNhdXNlcyBsYXlvdXQsXHJcbiAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGxhZyBkdXJpbmcgdGhlIGFuaW1hdGlvbixcclxuICAgICAgICAvLyB0aGF0J3Mgd2h5IHdlIGRlbGF5IGl0IHVudGlsIHRoZSBvcGVuZXIgdHJhbnNpdGlvbiBlbmRzXHJcbiAgICAgICAgdGhpcy5fZm9jdXNSb290KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBzd3AuZXZlbnRzLmFkZChkb2N1bWVudCwgJ2ZvY3VzaW4nLCAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqLyh0aGlzLl9vbkZvY3VzSW4uYmluZCh0aGlzKSkpO1xyXG4gICAgICBwc3dwLmV2ZW50cy5hZGQoZG9jdW1lbnQsICdrZXlkb3duJywgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi8odGhpcy5fb25LZXlEb3duLmJpbmQodGhpcykpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGxhc3RBY3RpdmVFbGVtZW50ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgcHN3cC5vbignZGVzdHJveScsICgpID0+IHtcclxuICAgICAgaWYgKHBzd3Aub3B0aW9ucy5yZXR1cm5Gb2N1c1xyXG4gICAgICAgICAgJiYgbGFzdEFjdGl2ZUVsZW1lbnRcclxuICAgICAgICAgICYmIHRoaXMuX3dhc0ZvY3VzZWQpIHtcclxuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAcHJpdmF0ZSAqL1xyXG4gIF9mb2N1c1Jvb3QoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3dhc0ZvY3VzZWQgJiYgdGhpcy5wc3dwLmVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5wc3dwLmVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgdGhpcy5fd2FzRm9jdXNlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxyXG4gICAqL1xyXG4gIF9vbktleURvd24oZSkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmIChwc3dwLmRpc3BhdGNoKCdrZXlkb3duJywgeyBvcmlnaW5hbEV2ZW50OiBlIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGVjaWFsS2V5VXNlZChlKSkge1xyXG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBzcGVjaWFsIGtleSBwcmVzc2VkXHJcbiAgICAgIC8vIHRvIHByZXZlbnQgZnJvbSBvdmVycmlkaW5nIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zXHJcbiAgICAgIC8vIGZvciBleGFtcGxlLCBpbiBDaHJvbWUgb24gTWFjIGNtZCthcnJvdy1sZWZ0IHJldHVybnMgdG8gcHJldmlvdXMgcGFnZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEB0eXBlIHtNZXRob2RzPFBob3RvU3dpcGU+IHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgbGV0IGtleWRvd25BY3Rpb247XHJcbiAgICAvKiogQHR5cGUgeyd4JyB8ICd5JyB8IHVuZGVmaW5lZH0gKi9cclxuICAgIGxldCBheGlzO1xyXG4gICAgbGV0IGlzRm9yd2FyZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgaXNLZXlTdXBwb3J0ZWQgPSAna2V5JyBpbiBlO1xyXG5cclxuICAgIHN3aXRjaCAoaXNLZXlTdXBwb3J0ZWQgPyBlLmtleSA6IGUua2V5Q29kZSkge1xyXG4gICAgICBjYXNlIGdldEtleWJvYXJkRXZlbnRLZXkoJ0VzY2FwZScsIGlzS2V5U3VwcG9ydGVkKTpcclxuICAgICAgICBpZiAocHN3cC5vcHRpb25zLmVzY0tleSkge1xyXG4gICAgICAgICAga2V5ZG93bkFjdGlvbiA9ICdjbG9zZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGdldEtleWJvYXJkRXZlbnRLZXkoJ3onLCBpc0tleVN1cHBvcnRlZCk6XHJcbiAgICAgICAga2V5ZG93bkFjdGlvbiA9ICd0b2dnbGVab29tJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdBcnJvd0xlZnQnLCBpc0tleVN1cHBvcnRlZCk6XHJcbiAgICAgICAgYXhpcyA9ICd4JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdBcnJvd1VwJywgaXNLZXlTdXBwb3J0ZWQpOlxyXG4gICAgICAgIGF4aXMgPSAneSc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgZ2V0S2V5Ym9hcmRFdmVudEtleSgnQXJyb3dSaWdodCcsIGlzS2V5U3VwcG9ydGVkKTpcclxuICAgICAgICBheGlzID0gJ3gnO1xyXG4gICAgICAgIGlzRm9yd2FyZCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgZ2V0S2V5Ym9hcmRFdmVudEtleSgnQXJyb3dEb3duJywgaXNLZXlTdXBwb3J0ZWQpOlxyXG4gICAgICAgIGlzRm9yd2FyZCA9IHRydWU7XHJcbiAgICAgICAgYXhpcyA9ICd5JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdUYWInLCBpc0tleVN1cHBvcnRlZCk6XHJcbiAgICAgICAgdGhpcy5fZm9jdXNSb290KCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbGVmdC9yaWdodC90b3AvYm90dG9tIGtleVxyXG4gICAgaWYgKGF4aXMpIHtcclxuICAgICAgLy8gcHJldmVudCBwYWdlIHNjcm9sbFxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICBjb25zdCB7IGN1cnJTbGlkZSB9ID0gcHN3cDtcclxuXHJcbiAgICAgIGlmIChwc3dwLm9wdGlvbnMuYXJyb3dLZXlzXHJcbiAgICAgICAgICAmJiBheGlzID09PSAneCdcclxuICAgICAgICAgICYmIHBzd3AuZ2V0TnVtSXRlbXMoKSA+IDEpIHtcclxuICAgICAgICBrZXlkb3duQWN0aW9uID0gaXNGb3J3YXJkID8gJ25leHQnIDogJ3ByZXYnO1xyXG4gICAgICB9IGVsc2UgaWYgKGN1cnJTbGlkZSAmJiBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLmZpdCkge1xyXG4gICAgICAgIC8vIHVwL2Rvd24gYXJyb3cga2V5cyBwYW4gdGhlIGltYWdlIHZlcnRpY2FsbHlcclxuICAgICAgICAvLyBsZWZ0L3JpZ2h0IGFycm93IGtleXMgcGFuIGhvcml6b250YWxseS5cclxuICAgICAgICAvLyBVbmxlc3MgdGhlcmUgaXMgb25seSBvbmUgaW1hZ2UsXHJcbiAgICAgICAgLy8gb3IgYXJyb3dLZXlzIG9wdGlvbiBpcyBkaXNhYmxlZFxyXG4gICAgICAgIGN1cnJTbGlkZS5wYW5bYXhpc10gKz0gaXNGb3J3YXJkID8gLTgwIDogODA7XHJcbiAgICAgICAgY3VyclNsaWRlLnBhblRvKGN1cnJTbGlkZS5wYW4ueCwgY3VyclNsaWRlLnBhbi55KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXlkb3duQWN0aW9uKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBwc3dwW2tleWRvd25BY3Rpb25dKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFwIGZvY3VzIGluc2lkZSBwaG90b3N3aXBlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZVxyXG4gICAqL1xyXG4gIF9vbkZvY3VzSW4oZSkge1xyXG4gICAgY29uc3QgeyB0ZW1wbGF0ZSB9ID0gdGhpcy5wc3dwO1xyXG4gICAgaWYgKHRlbXBsYXRlXHJcbiAgICAgICAgJiYgZG9jdW1lbnQgIT09IGUudGFyZ2V0XHJcbiAgICAgICAgJiYgdGVtcGxhdGUgIT09IGUudGFyZ2V0XHJcbiAgICAgICAgJiYgIXRlbXBsYXRlLmNvbnRhaW5zKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGUudGFyZ2V0KSkpIHtcclxuICAgICAgLy8gZm9jdXMgcm9vdCBlbGVtZW50XHJcbiAgICAgIHRlbXBsYXRlLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfRUFTSU5HID0gJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSc7XHJcblxyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9hbmltYXRpb25zLmpzJykuU2hhcmVkQW5pbWF0aW9uUHJvcHN9IFNoYXJlZEFuaW1hdGlvblByb3BzICovXHJcblxyXG4vKiogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdENzc0FuaW1hdGlvblByb3BzXHJcbiAqXHJcbiAqIEBwcm9wIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAqIEBwcm9wIHtudW1iZXJ9IFtkdXJhdGlvbl1cclxuICogQHByb3Age3N0cmluZ30gW2Vhc2luZ11cclxuICogQHByb3Age3N0cmluZ30gW3RyYW5zZm9ybV1cclxuICogQHByb3Age3N0cmluZ30gW29wYWNpdHldXHJcbiAqICovXHJcblxyXG4vKiogQHR5cGVkZWYge1NoYXJlZEFuaW1hdGlvblByb3BzICYgRGVmYXVsdENzc0FuaW1hdGlvblByb3BzfSBDc3NBbmltYXRpb25Qcm9wcyAqL1xyXG5cclxuLyoqXHJcbiAqIFJ1bnMgQ1NTIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jbGFzcyBDU1NBbmltYXRpb24ge1xyXG4gIC8qKlxyXG4gICAqIG9uQ29tcGxldGUgY2FuIGJlIHVucHJlZGljdGFibGUsIGJlIGNhcmVmdWwgYWJvdXQgY3VycmVudCBzdGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDc3NBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIG9uQ29tcGxldGUsXHJcbiAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgb25GaW5pc2ggPSAoKSA9PiB7fSxcclxuICAgICAgZHVyYXRpb24gPSAzMzMsXHJcbiAgICAgIGVhc2luZyA9IERFRkFVTFRfRUFTSU5HLFxyXG4gICAgfSA9IHByb3BzO1xyXG5cclxuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDtcclxuXHJcbiAgICAvLyBzdXBwb3J0IG9ubHkgdHJhbnNmb3JtIGFuZCBvcGFjaXR5XHJcbiAgICBjb25zdCBwcm9wID0gdHJhbnNmb3JtID8gJ3RyYW5zZm9ybScgOiAnb3BhY2l0eSc7XHJcbiAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1twcm9wXSA/PyAnJztcclxuXHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fb25Db21wbGV0ZSA9IG9uQ29tcGxldGU7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9vblRyYW5zaXRpb25FbmQgPSB0aGlzLl9vblRyYW5zaXRpb25FbmQuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBVc2luZyB0aW1lb3V0IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgYW5pbWF0aW9uXHJcbiAgICAvLyBzdGFydHMgZXZlbiBpZiB0aGUgYW5pbWF0ZWQgcHJvcGVydHkgd2FzIGNoYW5nZWQgcmVjZW50bHksXHJcbiAgICAvLyBvdGhlcndpc2UgdHJhbnNpdGlvbmVuZCBtaWdodCBub3QgZmlyZSBvciB0cmFuc2l0aW9uIHdvbid0IHN0YXJ0LlxyXG4gICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy10cmFuc2l0aW9ucy8jc3RhcnRpbmdcclxuICAgIC8vXHJcbiAgICAvLyDCr1xcXyjjg4QpXy/Cr1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9oZWxwZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0YXJnZXQsIHByb3AsIGR1cmF0aW9uLCBlYXNpbmcpO1xyXG4gICAgICB0aGlzLl9oZWxwZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIGZhbHNlKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmNhbmNlbCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBTYWZhcmkgb2NjYXNpb25hbGx5IGRvZXMgbm90IGVtaXQgdHJhbnNpdGlvbmVuZCBldmVudFxyXG4gICAgICAgIC8vIGlmIGVsZW1lbnQgcHJvcGVydHkgd2FzIG1vZGlmaWVkIGR1cmluZyB0aGUgdHJhbnNpdGlvbixcclxuICAgICAgICAvLyB3aGljaCBtYXkgYmUgY2F1c2VkIGJ5IHJlc2l6ZSBvciB0aGlyZCBwYXJ0eSBjb21wb25lbnQsXHJcbiAgICAgICAgLy8gdXNpbmcgdGltZW91dCBhcyBhIHNhZmV0eSBmYWxsYmFja1xyXG4gICAgICAgIHRoaXMuX2hlbHBlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2ZpbmFsaXplQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgfSwgZHVyYXRpb24gKyA1MDApO1xyXG4gICAgICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IHByb3BWYWx1ZTtcclxuICAgICAgfSwgMzApOyAvLyBEbyBub3QgcmVkdWNlIHRoaXMgbnVtYmVyXHJcbiAgICB9LCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGVcclxuICAgKi9cclxuICBfb25UcmFuc2l0aW9uRW5kKGUpIHtcclxuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0KSB7XHJcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9maW5hbGl6ZUFuaW1hdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcclxuICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLm9uRmluaXNoKCk7XHJcbiAgICAgIGlmICh0aGlzLl9vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZXN0cm95IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IG9uRmluaXNoXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLl9oZWxwZXJUaW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oZWxwZXJUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRyYW5zaXRpb25TdHlsZSh0aGlzLl90YXJnZXQpO1xyXG4gICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIGZhbHNlKTtcclxuICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uY2FuY2VsJywgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCBmYWxzZSk7XHJcbiAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XHJcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfTkFUVVJBTF9GUkVRVUVOQ1kgPSAxMjtcclxuY29uc3QgREVGQVVMVF9EQU1QSU5HX1JBVElPID0gMC43NTtcclxuXHJcbi8qKlxyXG4gKiBTcHJpbmcgZWFzaW5nIGhlbHBlclxyXG4gKi9cclxuY2xhc3MgU3ByaW5nRWFzZXIge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsVmVsb2NpdHkgSW5pdGlhbCB2ZWxvY2l0eSwgcHggcGVyIG1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYW1waW5nUmF0aW9dXHJcbiAgICogRGV0ZXJtaW5lcyBob3cgYm91bmN5IGFuaW1hdGlvbiB3aWxsIGJlLlxyXG4gICAqIEZyb20gMCB0byAxLCAwIC0gYWx3YXlzIG92ZXJzaG9vdCwgMSAtIGRvIG5vdCBvdmVyc2hvb3QuXHJcbiAgICogXCJvdmVyc2hvb3RcIiByZWZlcnMgdG8gcGFydCBvZiBhbmltYXRpb24gdGhhdFxyXG4gICAqIGdvZXMgYmV5b25kIHRoZSBmaW5hbCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbmF0dXJhbEZyZXF1ZW5jeV1cclxuICAgKiBEZXRlcm1pbmVzIGhvdyBmYXN0IGFuaW1hdGlvbiB3aWxsIHNsb3cgZG93bi5cclxuICAgKiBUaGUgaGlnaGVyIHZhbHVlIC0gdGhlIHN0aWZmZXIgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSxcclxuICAgKiBhbmQgdGhlIGZhc3RlciBpdCB3aWxsIHNsb3cgZG93bi5cclxuICAgKiBSZWNvbW1lbmRlZCB2YWx1ZSBmcm9tIDEwIHRvIDUwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZlbG9jaXR5LCBkYW1waW5nUmF0aW8sIG5hdHVyYWxGcmVxdWVuY3kpIHtcclxuICAgIHRoaXMudmVsb2NpdHkgPSBpbml0aWFsVmVsb2NpdHkgKiAxMDAwOyAvLyBjb252ZXJ0IHRvIFwicGl4ZWxzIHBlciBzZWNvbmRcIlxyXG5cclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhbXBpbmdfcmF0aW9cclxuICAgIHRoaXMuX2RhbXBpbmdSYXRpbyA9IGRhbXBpbmdSYXRpbyB8fCBERUZBVUxUX0RBTVBJTkdfUkFUSU87XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmF0dXJhbF9mcmVxdWVuY3lcclxuICAgIHRoaXMuX25hdHVyYWxGcmVxdWVuY3kgPSBuYXR1cmFsRnJlcXVlbmN5IHx8IERFRkFVTFRfTkFUVVJBTF9GUkVRVUVOQ1k7XHJcblxyXG4gICAgdGhpcy5fZGFtcGVkRnJlcXVlbmN5ID0gdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGFtcGluZ1JhdGlvIDwgMSkge1xyXG4gICAgICB0aGlzLl9kYW1wZWRGcmVxdWVuY3kgKj0gTWF0aC5zcXJ0KDEgLSB0aGlzLl9kYW1waW5nUmF0aW8gKiB0aGlzLl9kYW1waW5nUmF0aW8pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhUG9zaXRpb24gRGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGVuZCBwb3NpdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSBGcmFtZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3BsYWNlbWVudCwgcmVsYXRpdmUgdG8gdGhlIGVuZCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBlYXNlRnJhbWUoZGVsdGFQb3NpdGlvbiwgZGVsdGFUaW1lKSB7XHJcbiAgICAvLyBJbnNwaXJlZCBieSBBcHBsZSBXZWJraXQgYW5kIEFuZHJvaWQgc3ByaW5nIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Pc2NpbGxhdGlvblxyXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFtcGluZ19yYXRpb1xyXG4gICAgLy8gd2UgaWdub3JlIG1hc3MgKGFzc3VtZSB0aGF0IGl0J3MgMWtnKVxyXG5cclxuICAgIGxldCBkaXNwbGFjZW1lbnQgPSAwO1xyXG4gICAgbGV0IGNvZWZmO1xyXG5cclxuICAgIGRlbHRhVGltZSAvPSAxMDAwO1xyXG5cclxuICAgIGNvbnN0IG5hdHVyYWxEdW1waW5nUG93ID0gTWF0aC5FICoqICgtdGhpcy5fZGFtcGluZ1JhdGlvICogdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeSAqIGRlbHRhVGltZSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhbXBpbmdSYXRpbyA9PT0gMSkge1xyXG4gICAgICBjb2VmZiA9IHRoaXMudmVsb2NpdHkgKyB0aGlzLl9uYXR1cmFsRnJlcXVlbmN5ICogZGVsdGFQb3NpdGlvbjtcclxuXHJcbiAgICAgIGRpc3BsYWNlbWVudCA9IChkZWx0YVBvc2l0aW9uICsgY29lZmYgKiBkZWx0YVRpbWUpICogbmF0dXJhbER1bXBpbmdQb3c7XHJcblxyXG4gICAgICB0aGlzLnZlbG9jaXR5ID0gZGlzcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICogKC10aGlzLl9uYXR1cmFsRnJlcXVlbmN5KSArIGNvZWZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICogbmF0dXJhbER1bXBpbmdQb3c7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhbXBpbmdSYXRpbyA8IDEpIHtcclxuICAgICAgY29lZmYgPSAoMSAvIHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSlcclxuICAgICAgICAgICAgICAgICogKHRoaXMuX2RhbXBpbmdSYXRpbyAqIHRoaXMuX25hdHVyYWxGcmVxdWVuY3kgKiBkZWx0YVBvc2l0aW9uICsgdGhpcy52ZWxvY2l0eSk7XHJcblxyXG4gICAgICBjb25zdCBkdW1wZWRGQ29zID0gTWF0aC5jb3ModGhpcy5fZGFtcGVkRnJlcXVlbmN5ICogZGVsdGFUaW1lKTtcclxuICAgICAgY29uc3QgZHVtcGVkRlNpbiA9IE1hdGguc2luKHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSAqIGRlbHRhVGltZSk7XHJcblxyXG4gICAgICBkaXNwbGFjZW1lbnQgPSBuYXR1cmFsRHVtcGluZ1Bvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICogKGRlbHRhUG9zaXRpb24gKiBkdW1wZWRGQ29zICsgY29lZmYgKiBkdW1wZWRGU2luKTtcclxuXHJcbiAgICAgIHRoaXMudmVsb2NpdHkgPSBkaXNwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoLXRoaXMuX25hdHVyYWxGcmVxdWVuY3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcy5fZGFtcGluZ1JhdGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgbmF0dXJhbER1bXBpbmdQb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoLXRoaXMuX2RhbXBlZEZyZXF1ZW5jeSAqIGRlbHRhUG9zaXRpb24gKiBkdW1wZWRGU2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgdGhpcy5fZGFtcGVkRnJlcXVlbmN5ICogY29lZmYgKiBkdW1wZWRGQ29zKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPdmVyZGFtcGVkICg+MSkgZGFtcGluZyByYXRpbyBpcyBub3Qgc3VwcG9ydGVkXHJcblxyXG4gICAgcmV0dXJuIGRpc3BsYWNlbWVudDtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vYW5pbWF0aW9ucy5qcycpLlNoYXJlZEFuaW1hdGlvblByb3BzfSBTaGFyZWRBbmltYXRpb25Qcm9wcyAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRTcHJpbmdBbmltYXRpb25Qcm9wc1xyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyfSBzdGFydFxyXG4gKiBAcHJvcCB7bnVtYmVyfSBlbmRcclxuICogQHByb3Age251bWJlcn0gdmVsb2NpdHlcclxuICogQHByb3Age251bWJlcn0gW2RhbXBpbmdSYXRpb11cclxuICogQHByb3Age251bWJlcn0gW25hdHVyYWxGcmVxdWVuY3ldXHJcbiAqIEBwcm9wIHsoZW5kOiBudW1iZXIpID0+IHZvaWR9IG9uVXBkYXRlXHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHtTaGFyZWRBbmltYXRpb25Qcm9wcyAmIERlZmF1bHRTcHJpbmdBbmltYXRpb25Qcm9wc30gU3ByaW5nQW5pbWF0aW9uUHJvcHMgKi9cclxuXHJcbmNsYXNzIFNwcmluZ0FuaW1hdGlvbiB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTcHJpbmdBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gICAgdGhpcy5fcmFmID0gMDtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHN0YXJ0LFxyXG4gICAgICBlbmQsXHJcbiAgICAgIHZlbG9jaXR5LFxyXG4gICAgICBvblVwZGF0ZSxcclxuICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgb25GaW5pc2ggPSAoKSA9PiB7fSxcclxuICAgICAgZGFtcGluZ1JhdGlvLFxyXG4gICAgICBuYXR1cmFsRnJlcXVlbmN5XHJcbiAgICB9ID0gcHJvcHM7XHJcblxyXG4gICAgdGhpcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xyXG5cclxuICAgIGNvbnN0IGVhc2VyID0gbmV3IFNwcmluZ0Vhc2VyKHZlbG9jaXR5LCBkYW1waW5nUmF0aW8sIG5hdHVyYWxGcmVxdWVuY3kpO1xyXG4gICAgbGV0IHByZXZUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBkZWx0YVBvc2l0aW9uID0gc3RhcnQgLSBlbmQ7XHJcblxyXG4gICAgY29uc3QgYW5pbWF0aW9uTG9vcCA9ICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX3JhZikge1xyXG4gICAgICAgIGRlbHRhUG9zaXRpb24gPSBlYXNlci5lYXNlRnJhbWUoZGVsdGFQb3NpdGlvbiwgRGF0ZS5ub3coKSAtIHByZXZUaW1lKTtcclxuXHJcbiAgICAgICAgLy8gU3RvcCB0aGUgYW5pbWF0aW9uIGlmIHZlbG9jaXR5IGlzIGxvdyBhbmQgcG9zaXRpb24gaXMgY2xvc2UgdG8gZW5kXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhUG9zaXRpb24pIDwgMSAmJiBNYXRoLmFicyhlYXNlci52ZWxvY2l0eSkgPCA1MCkge1xyXG4gICAgICAgICAgLy8gRmluYWxpemUgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgb25VcGRhdGUoZW5kKTtcclxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMub25GaW5pc2goKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJldlRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgb25VcGRhdGUoZGVsdGFQb3NpdGlvbiArIGVuZCk7XHJcbiAgICAgICAgICB0aGlzLl9yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uTG9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3JhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25Mb29wKTtcclxuICB9XHJcblxyXG4gIC8vIERlc3Ryb3kgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgb25GaW5pc2hcclxuICBkZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuX3JhZiA+PSAwKSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZik7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9yYWYgPSAwO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jc3MtYW5pbWF0aW9uLmpzJykuQ3NzQW5pbWF0aW9uUHJvcHN9IENzc0FuaW1hdGlvblByb3BzICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NwcmluZy1hbmltYXRpb24uanMnKS5TcHJpbmdBbmltYXRpb25Qcm9wc30gU3ByaW5nQW5pbWF0aW9uUHJvcHMgKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7T2JqZWN0fSBTaGFyZWRBbmltYXRpb25Qcm9wc1xyXG4gKiBAcHJvcCB7c3RyaW5nfSBbbmFtZV1cclxuICogQHByb3Age2Jvb2xlYW59IFtpc1Bhbl1cclxuICogQHByb3Age2Jvb2xlYW59IFtpc01haW5TY3JvbGxdXHJcbiAqIEBwcm9wIHtWb2lkRnVuY3Rpb259IFtvbkNvbXBsZXRlXVxyXG4gKiBAcHJvcCB7Vm9pZEZ1bmN0aW9ufSBbb25GaW5pc2hdXHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHtTcHJpbmdBbmltYXRpb24gfCBDU1NBbmltYXRpb259IEFuaW1hdGlvbiAqL1xyXG4vKiogQHR5cGVkZWYge1NwcmluZ0FuaW1hdGlvblByb3BzIHwgQ3NzQW5pbWF0aW9uUHJvcHN9IEFuaW1hdGlvblByb3BzICovXHJcblxyXG4vKipcclxuICogTWFuYWdlcyBhbmltYXRpb25zXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25zIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBAdHlwZSB7QW5pbWF0aW9uW119ICovXHJcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U3ByaW5nQW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICovXHJcbiAgc3RhcnRTcHJpbmcocHJvcHMpIHtcclxuICAgIHRoaXMuX3N0YXJ0KHByb3BzLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Q3NzQW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICovXHJcbiAgc3RhcnRUcmFuc2l0aW9uKHByb3BzKSB7XHJcbiAgICB0aGlzLl9zdGFydChwcm9wcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTcHJpbmddXHJcbiAgICogQHJldHVybnMge0FuaW1hdGlvbn1cclxuICAgKi9cclxuICBfc3RhcnQocHJvcHMsIGlzU3ByaW5nKSB7XHJcbiAgICBjb25zdCBhbmltYXRpb24gPSBpc1NwcmluZ1xyXG4gICAgICA/IG5ldyBTcHJpbmdBbmltYXRpb24oLyoqIEB0eXBlIFNwcmluZ0FuaW1hdGlvblByb3BzICovIChwcm9wcykpXHJcbiAgICAgIDogbmV3IENTU0FuaW1hdGlvbigvKiogQHR5cGUgQ3NzQW5pbWF0aW9uUHJvcHMgKi8gKHByb3BzKSk7XHJcblxyXG4gICAgdGhpcy5hY3RpdmVBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcclxuICAgIGFuaW1hdGlvbi5vbkZpbmlzaCA9ICgpID0+IHRoaXMuc3RvcChhbmltYXRpb24pO1xyXG5cclxuICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0FuaW1hdGlvbn0gYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgc3RvcChhbmltYXRpb24pIHtcclxuICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5pbmRleE9mKGFuaW1hdGlvbik7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0b3BBbGwoKSB7IC8vIF9zdG9wQWxsQW5pbWF0aW9uc1xyXG4gICAgdGhpcy5hY3RpdmVBbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4ge1xyXG4gICAgICBhbmltYXRpb24uZGVzdHJveSgpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgYWxsIHBhbiBvciB6b29tIHRyYW5zaXRpb25zXHJcbiAgICovXHJcbiAgc3RvcEFsbFBhbigpIHtcclxuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9ucyA9IHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5maWx0ZXIoKGFuaW1hdGlvbikgPT4ge1xyXG4gICAgICBpZiAoYW5pbWF0aW9uLnByb3BzLmlzUGFuKSB7XHJcbiAgICAgICAgYW5pbWF0aW9uLmRlc3Ryb3koKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzdG9wTWFpblNjcm9sbCgpIHtcclxuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9ucyA9IHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5maWx0ZXIoKGFuaW1hdGlvbikgPT4ge1xyXG4gICAgICBpZiAoYW5pbWF0aW9uLnByb3BzLmlzTWFpblNjcm9sbCkge1xyXG4gICAgICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIG1haW4gc2Nyb2xsIHRyYW5zaXRpb24gaXMgcnVubmluZ1xyXG4gICAqL1xyXG4gIC8vIGlzTWFpblNjcm9sbFJ1bm5pbmcoKSB7XHJcbiAgLy8gICByZXR1cm4gdGhpcy5hY3RpdmVBbmltYXRpb25zLnNvbWUoKGFuaW1hdGlvbikgPT4ge1xyXG4gIC8vICAgICByZXR1cm4gYW5pbWF0aW9uLnByb3BzLmlzTWFpblNjcm9sbDtcclxuICAvLyAgIH0pO1xyXG4gIC8vIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFueSBwYW4gb3Igem9vbSB0cmFuc2l0aW9uIGlzIHJ1bm5pbmdcclxuICAgKi9cclxuICBpc1BhblJ1bm5pbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBbmltYXRpb25zLnNvbWUoKGFuaW1hdGlvbikgPT4ge1xyXG4gICAgICByZXR1cm4gYW5pbWF0aW9uLnByb3BzLmlzUGFuO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcblxyXG4vKipcclxuICogSGFuZGxlcyBzY3JvbGwgd2hlZWwuXHJcbiAqIENhbiBwYW4gYW5kIHpvb20gY3VycmVudCBzbGlkZSBpbWFnZS5cclxuICovXHJcbmNsYXNzIFNjcm9sbFdoZWVsIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XHJcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xyXG4gICAgcHN3cC5ldmVudHMuYWRkKHBzd3AuZWxlbWVudCwgJ3doZWVsJywgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi8odGhpcy5fb25XaGVlbC5iaW5kKHRoaXMpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gZVxyXG4gICAqL1xyXG4gIF9vbldoZWVsKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSB0aGlzLnBzd3A7XHJcbiAgICBsZXQgeyBkZWx0YVgsIGRlbHRhWSB9ID0gZTtcclxuXHJcbiAgICBpZiAoIWN1cnJTbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgnd2hlZWwnLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGUuY3RybEtleSB8fCB0aGlzLnBzd3Aub3B0aW9ucy53aGVlbFRvWm9vbSkge1xyXG4gICAgICAvLyB6b29tXHJcbiAgICAgIGlmIChjdXJyU2xpZGUuaXNab29tYWJsZSgpKSB7XHJcbiAgICAgICAgbGV0IHpvb21GYWN0b3IgPSAtZGVsdGFZO1xyXG4gICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xyXG4gICAgICAgICAgem9vbUZhY3RvciAqPSAwLjA1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB6b29tRmFjdG9yICo9IGUuZGVsdGFNb2RlID8gMSA6IDAuMDAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6b29tRmFjdG9yID0gMiAqKiB6b29tRmFjdG9yO1xyXG5cclxuICAgICAgICBjb25zdCBkZXN0Wm9vbUxldmVsID0gY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgKiB6b29tRmFjdG9yO1xyXG4gICAgICAgIGN1cnJTbGlkZS56b29tVG8oZGVzdFpvb21MZXZlbCwge1xyXG4gICAgICAgICAgeDogZS5jbGllbnRYLFxyXG4gICAgICAgICAgeTogZS5jbGllbnRZXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHBhblxyXG4gICAgICBpZiAoY3VyclNsaWRlLmlzUGFubmFibGUoKSkge1xyXG4gICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xyXG4gICAgICAgICAgLy8gMTggLSBhdmVyYWdlIGxpbmUgaGVpZ2h0XHJcbiAgICAgICAgICBkZWx0YVggKj0gMTg7XHJcbiAgICAgICAgICBkZWx0YVkgKj0gMTg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyU2xpZGUucGFuVG8oXHJcbiAgICAgICAgICBjdXJyU2xpZGUucGFuLnggLSBkZWx0YVgsXHJcbiAgICAgICAgICBjdXJyU2xpZGUucGFuLnkgLSBkZWx0YVlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTWV0aG9kczxUPn0gTWV0aG9kczxUPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVSUVsZW1lbnRNYXJrdXBQcm9wc1xyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW2lzQ3VzdG9tU1ZHXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBpbm5lclxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbb3V0bGluZUlEXVxyXG4gKiBAcHJvcCB7bnVtYmVyIHwgc3RyaW5nfSBbc2l6ZV1cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gVUlFbGVtZW50RGF0YVxyXG4gKiBAcHJvcCB7RGVmYXVsdFVJRWxlbWVudHMgfCBzdHJpbmd9IFtuYW1lXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbY2xhc3NOYW1lXVxyXG4gKiBAcHJvcCB7VUlFbGVtZW50TWFya3VwfSBbaHRtbF1cclxuICogQHByb3Age2Jvb2xlYW59IFtpc0J1dHRvbl1cclxuICogQHByb3Age2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gW3RhZ05hbWVdXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFt0aXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW2FyaWFMYWJlbF1cclxuICogQHByb3AgeyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHN3cDogUGhvdG9Td2lwZSkgPT4gdm9pZH0gW29uSW5pdF1cclxuICogQHByb3Age01ldGhvZHM8UGhvdG9Td2lwZT4gfCAoKGU6IE1vdXNlRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwc3dwOiBQaG90b1N3aXBlKSA9PiB2b2lkKX0gW29uQ2xpY2tdXHJcbiAqIEBwcm9wIHsnYmFyJyB8ICd3cmFwcGVyJyB8ICdyb290J30gW2FwcGVuZFRvXVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBbb3JkZXJdXHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHsnYXJyb3dQcmV2JyB8ICdhcnJvd05leHQnIHwgJ2Nsb3NlJyB8ICd6b29tJyB8ICdjb3VudGVyJ30gRGVmYXVsdFVJRWxlbWVudHMgKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7c3RyaW5nIHwgVUlFbGVtZW50TWFya3VwUHJvcHN9IFVJRWxlbWVudE1hcmt1cCAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7VUlFbGVtZW50TWFya3VwfSBbaHRtbERhdGFdXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRFbGVtZW50SFRNTChodG1sRGF0YSkge1xyXG4gIGlmICh0eXBlb2YgaHRtbERhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAvLyBBbGxvdyBkZXZlbG9wZXJzIHRvIHByb3ZpZGUgZnVsbCBzdmcsXHJcbiAgICAvLyBGb3IgZXhhbXBsZTpcclxuICAgIC8vIDxzdmcgdmlld0JveD1cIjAgMCAzMiAzMlwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwicHN3cF9faWNuXCI+XHJcbiAgICAvLyAgIDxwYXRoIGQ9XCIuLi5cIiAvPlxyXG4gICAgLy8gICA8Y2lyY2xlIC4uLiAvPlxyXG4gICAgLy8gPC9zdmc+XHJcbiAgICAvLyBDYW4gYWxzbyBiZSBhbnkgSFRNTCBzdHJpbmcuXHJcbiAgICByZXR1cm4gaHRtbERhdGE7XHJcbiAgfVxyXG5cclxuICBpZiAoIWh0bWxEYXRhIHx8ICFodG1sRGF0YS5pc0N1c3RvbVNWRykge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3ZnRGF0YSA9IGh0bWxEYXRhO1xyXG4gIGxldCBvdXQgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInBzd3BfX2ljblwiIHZpZXdCb3g9XCIwIDAgJWQgJWRcIiB3aWR0aD1cIiVkXCIgaGVpZ2h0PVwiJWRcIj4nO1xyXG4gIC8vIHJlcGxhY2UgYWxsICVkIHdpdGggc2l6ZVxyXG4gIG91dCA9IG91dC5zcGxpdCgnJWQnKS5qb2luKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc3ZnRGF0YS5zaXplIHx8IDMyKSk7XHJcblxyXG4gIC8vIEljb25zIG1heSBjb250YWluIG91dGxpbmUvc2hhZG93LFxyXG4gIC8vIHRvIG1ha2UgaXQgd2UgXCJjbG9uZVwiIGJhc2UgaWNvbiBzaGFwZSBhbmQgYWRkIGJvcmRlciB0byBpdC5cclxuICAvLyBJY29uIGl0c2VsZiBhbmQgYm9yZGVyIGFyZSBzdHlsZWQgdmlhIENTUy5cclxuICAvL1xyXG4gIC8vIFByb3BlcnR5IHNoYWRvd0lEIGRlZmluZXMgSUQgb2YgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBjbG9uZWQuXHJcbiAgaWYgKHN2Z0RhdGEub3V0bGluZUlEKSB7XHJcbiAgICBvdXQgKz0gJzx1c2UgY2xhc3M9XCJwc3dwX19pY24tc2hhZG93XCIgeGxpbms6aHJlZj1cIiMnICsgc3ZnRGF0YS5vdXRsaW5lSUQgKyAnXCIvPic7XHJcbiAgfVxyXG5cclxuICBvdXQgKz0gc3ZnRGF0YS5pbm5lcjtcclxuXHJcbiAgb3V0ICs9ICc8L3N2Zz4nO1xyXG5cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5jbGFzcyBVSUVsZW1lbnQge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqIEBwYXJhbSB7VUlFbGVtZW50RGF0YX0gZGF0YVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3AsIGRhdGEpIHtcclxuICAgIGNvbnN0IG5hbWUgPSBkYXRhLm5hbWUgfHwgZGF0YS5jbGFzc05hbWU7XHJcbiAgICBsZXQgZWxlbWVudEhUTUwgPSBkYXRhLmh0bWw7XHJcblxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rdXAgb25seSBieSBgZGF0YS5uYW1lYCBtYXliZT9cclxuICAgIGlmIChwc3dwLm9wdGlvbnNbbmFtZV0gPT09IGZhbHNlKSB7XHJcbiAgICAgIC8vIGV4aXQgaWYgZWxlbWVudCBpcyBkaXNhYmxlZCBmcm9tIG9wdGlvbnNcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsbG93IHRvIG92ZXJyaWRlIFNWRyBpY29ucyBmcm9tIG9wdGlvbnNcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XHJcbiAgICBpZiAodHlwZW9mIHBzd3Aub3B0aW9uc1tuYW1lICsgJ1NWRyddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBhcnJvd1ByZXZTVkdcclxuICAgICAgLy8gYXJyb3dOZXh0U1ZHXHJcbiAgICAgIC8vIGNsb3NlU1ZHXHJcbiAgICAgIC8vIHpvb21TVkdcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rdXAgb25seSBieSBgZGF0YS5uYW1lYCBtYXliZT9cclxuICAgICAgZWxlbWVudEhUTUwgPSBwc3dwLm9wdGlvbnNbbmFtZSArICdTVkcnXTtcclxuICAgIH1cclxuXHJcbiAgICBwc3dwLmRpc3BhdGNoKCd1aUVsZW1lbnRDcmVhdGUnLCB7IGRhdGEgfSk7XHJcblxyXG4gICAgbGV0IGNsYXNzTmFtZSA9ICcnO1xyXG4gICAgaWYgKGRhdGEuaXNCdXR0b24pIHtcclxuICAgICAgY2xhc3NOYW1lICs9ICdwc3dwX19idXR0b24gJztcclxuICAgICAgY2xhc3NOYW1lICs9IChkYXRhLmNsYXNzTmFtZSB8fCBgcHN3cF9fYnV0dG9uLS0ke2RhdGEubmFtZX1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNsYXNzTmFtZSArPSAoZGF0YS5jbGFzc05hbWUgfHwgYHBzd3BfXyR7ZGF0YS5uYW1lfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB0YWdOYW1lID0gZGF0YS5pc0J1dHRvbiA/IChkYXRhLnRhZ05hbWUgfHwgJ2J1dHRvbicpIDogKGRhdGEudGFnTmFtZSB8fCAnZGl2Jyk7XHJcbiAgICB0YWdOYW1lID0gLyoqIEB0eXBlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9ICovICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cclxuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgdGFnTmFtZSk7XHJcblxyXG4gICAgaWYgKGRhdGEuaXNCdXR0b24pIHtcclxuICAgICAgaWYgKHRhZ05hbWUgPT09ICdidXR0b24nKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MQnV0dG9uRWxlbWVudH0gKi8gKGVsZW1lbnQpLnR5cGUgPSAnYnV0dG9uJztcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHsgdGl0bGUgfSA9IGRhdGE7XHJcbiAgICAgIGNvbnN0IHsgYXJpYUxhYmVsIH0gPSBkYXRhO1xyXG5cclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rdXAgb25seSBieSBgZGF0YS5uYW1lYCBtYXliZT9cclxuICAgICAgaWYgKHR5cGVvZiBwc3dwLm9wdGlvbnNbbmFtZSArICdUaXRsZSddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XHJcbiAgICAgICAgdGl0bGUgPSBwc3dwLm9wdGlvbnNbbmFtZSArICdUaXRsZSddO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGl0bGUpIHtcclxuICAgICAgICBlbGVtZW50LnRpdGxlID0gdGl0bGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGFyaWFUZXh0ID0gYXJpYUxhYmVsIHx8IHRpdGxlO1xyXG4gICAgICBpZiAoYXJpYVRleHQpIHtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGFyaWFUZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gYWRkRWxlbWVudEhUTUwoZWxlbWVudEhUTUwpO1xyXG5cclxuICAgIGlmIChkYXRhLm9uSW5pdCkge1xyXG4gICAgICBkYXRhLm9uSW5pdChlbGVtZW50LCBwc3dwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YS5vbkNsaWNrKSB7XHJcbiAgICAgIGVsZW1lbnQub25jbGljayA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLm9uQ2xpY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICBwc3dwW2RhdGEub25DbGlja10oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGRhdGEub25DbGljayhlLCBlbGVtZW50LCBwc3dwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG9wIGJhciBpcyBkZWZhdWx0IHBvc2l0aW9uXHJcbiAgICBjb25zdCBhcHBlbmRUbyA9IGRhdGEuYXBwZW5kVG8gfHwgJ2Jhcic7XHJcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfSByb290IGVsZW1lbnQgYnkgZGVmYXVsdCAqL1xyXG4gICAgbGV0IGNvbnRhaW5lciA9IHBzd3AuZWxlbWVudDtcclxuICAgIGlmIChhcHBlbmRUbyA9PT0gJ2JhcicpIHtcclxuICAgICAgaWYgKCFwc3dwLnRvcEJhcikge1xyXG4gICAgICAgIHBzd3AudG9wQmFyID0gY3JlYXRlRWxlbWVudCgncHN3cF9fdG9wLWJhciBwc3dwX19oaWRlLW9uLWNsb3NlJywgJ2RpdicsIHBzd3Auc2Nyb2xsV3JhcCk7XHJcbiAgICAgIH1cclxuICAgICAgY29udGFpbmVyID0gcHN3cC50b3BCYXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlbGVtZW50IG91dHNpZGUgb2YgdG9wIGJhciBnZXRzIGEgc2Vjb25kYXJ5IGNsYXNzXHJcbiAgICAgIC8vIHRoYXQgbWFrZXMgZWxlbWVudCBmYWRlIG91dCBvbiBjbG9zZVxyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Bzd3BfX2hpZGUtb24tY2xvc2UnKTtcclxuXHJcbiAgICAgIGlmIChhcHBlbmRUbyA9PT0gJ3dyYXBwZXInKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gcHN3cC5zY3JvbGxXcmFwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbmVyPy5hcHBlbmRDaGlsZChwc3dwLmFwcGx5RmlsdGVycygndWlFbGVtZW50JywgZWxlbWVudCwgZGF0YSkpO1xyXG4gIH1cclxufVxuXG4vKlxyXG4gIEJhY2t3YXJkIGFuZCBmb3J3YXJkIGFycm93IGJ1dHRvbnNcclxuICovXHJcblxyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc05leHRCdXR0b25dXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QXJyb3dCdXR0b24oZWxlbWVudCwgcHN3cCwgaXNOZXh0QnV0dG9uKSB7XHJcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwc3dwX19idXR0b24tLWFycm93Jyk7XHJcbiAgLy8gVE9ETzogdGhpcyBzaG91bGQgcG9pbnQgdG8gYSB1bmlxdWUgaWQgZm9yIHRoaXMgaW5zdGFuY2VcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsICdwc3dwX19pdGVtcycpO1xyXG4gIHBzd3Aub24oJ2NoYW5nZScsICgpID0+IHtcclxuICAgIGlmICghcHN3cC5vcHRpb25zLmxvb3ApIHtcclxuICAgICAgaWYgKGlzTmV4dEJ1dHRvbikge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovXHJcbiAgICAgICAgKGVsZW1lbnQpLmRpc2FibGVkID0gIShwc3dwLmN1cnJJbmRleCA8IHBzd3AuZ2V0TnVtSXRlbXMoKSAtIDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovXHJcbiAgICAgICAgKGVsZW1lbnQpLmRpc2FibGVkID0gIShwc3dwLmN1cnJJbmRleCA+IDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiBAdHlwZSB7VUlFbGVtZW50RGF0YX0gKi9cclxuY29uc3QgYXJyb3dQcmV2ID0ge1xyXG4gIG5hbWU6ICdhcnJvd1ByZXYnLFxyXG4gIGNsYXNzTmFtZTogJ3Bzd3BfX2J1dHRvbi0tYXJyb3ctLXByZXYnLFxyXG4gIHRpdGxlOiAnUHJldmlvdXMnLFxyXG4gIG9yZGVyOiAxMCxcclxuICBpc0J1dHRvbjogdHJ1ZSxcclxuICBhcHBlbmRUbzogJ3dyYXBwZXInLFxyXG4gIGh0bWw6IHtcclxuICAgIGlzQ3VzdG9tU1ZHOiB0cnVlLFxyXG4gICAgc2l6ZTogNjAsXHJcbiAgICBpbm5lcjogJzxwYXRoIGQ9XCJNMjkgNDNsLTMgMy0xNi0xNiAxNi0xNiAzIDMtMTMgMTMgMTMgMTN6XCIgaWQ9XCJwc3dwX19pY24tYXJyb3dcIi8+JyxcclxuICAgIG91dGxpbmVJRDogJ3Bzd3BfX2ljbi1hcnJvdydcclxuICB9LFxyXG4gIG9uQ2xpY2s6ICdwcmV2JyxcclxuICBvbkluaXQ6IGluaXRBcnJvd0J1dHRvblxyXG59O1xyXG5cclxuLyoqIEB0eXBlIHtVSUVsZW1lbnREYXRhfSAqL1xyXG5jb25zdCBhcnJvd05leHQgPSB7XHJcbiAgbmFtZTogJ2Fycm93TmV4dCcsXHJcbiAgY2xhc3NOYW1lOiAncHN3cF9fYnV0dG9uLS1hcnJvdy0tbmV4dCcsXHJcbiAgdGl0bGU6ICdOZXh0JyxcclxuICBvcmRlcjogMTEsXHJcbiAgaXNCdXR0b246IHRydWUsXHJcbiAgYXBwZW5kVG86ICd3cmFwcGVyJyxcclxuICBodG1sOiB7XHJcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcclxuICAgIHNpemU6IDYwLFxyXG4gICAgaW5uZXI6ICc8dXNlIHhsaW5rOmhyZWY9XCIjcHN3cF9faWNuLWFycm93XCIvPicsXHJcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tYXJyb3cnXHJcbiAgfSxcclxuICBvbkNsaWNrOiAnbmV4dCcsXHJcbiAgb25Jbml0OiAoZWwsIHBzd3ApID0+IHtcclxuICAgIGluaXRBcnJvd0J1dHRvbihlbCwgcHN3cCwgdHJ1ZSk7XHJcbiAgfVxyXG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xyXG5jb25zdCBjbG9zZUJ1dHRvbiA9IHtcclxuICBuYW1lOiAnY2xvc2UnLFxyXG4gIHRpdGxlOiAnQ2xvc2UnLFxyXG4gIG9yZGVyOiAyMCxcclxuICBpc0J1dHRvbjogdHJ1ZSxcclxuICBodG1sOiB7XHJcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcclxuICAgIGlubmVyOiAnPHBhdGggZD1cIk0yNCAxMGwtMi0yLTYgNi02LTYtMiAyIDYgNi02IDYgMiAyIDYtNiA2IDYgMi0yLTYtNnpcIiBpZD1cInBzd3BfX2ljbi1jbG9zZVwiLz4nLFxyXG4gICAgb3V0bGluZUlEOiAncHN3cF9faWNuLWNsb3NlJ1xyXG4gIH0sXHJcbiAgb25DbGljazogJ2Nsb3NlJ1xyXG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xyXG5jb25zdCB6b29tQnV0dG9uID0ge1xyXG4gIG5hbWU6ICd6b29tJyxcclxuICB0aXRsZTogJ1pvb20nLFxyXG4gIG9yZGVyOiAxMCxcclxuICBpc0J1dHRvbjogdHJ1ZSxcclxuICBodG1sOiB7XHJcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICBpbm5lcjogJzxwYXRoIGQ9XCJNMTcuNDI2IDE5LjkyNmE2IDYgMCAxIDEgMS41LTEuNUwyMyAyMi41IDIxLjUgMjRsLTQuMDc0LTQuMDc0elwiIGlkPVwicHN3cF9faWNuLXpvb21cIi8+J1xyXG4gICAgICAgICAgKyAnPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwicHN3cF9fem9vbS1pY24tYmFyLWhcIiBkPVwiTTExIDE2di0yaDZ2MnpcIi8+J1xyXG4gICAgICAgICAgKyAnPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwicHN3cF9fem9vbS1pY24tYmFyLXZcIiBkPVwiTTEzIDEyaDJ2NmgtMnpcIi8+JyxcclxuICAgIG91dGxpbmVJRDogJ3Bzd3BfX2ljbi16b29tJ1xyXG4gIH0sXHJcbiAgb25DbGljazogJ3RvZ2dsZVpvb20nXHJcbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcbmNvbnN0IGxvYWRpbmdJbmRpY2F0b3IgPSB7XHJcbiAgbmFtZTogJ3ByZWxvYWRlcicsXHJcbiAgYXBwZW5kVG86ICdiYXInLFxyXG4gIG9yZGVyOiA3LFxyXG4gIGh0bWw6IHtcclxuICAgIGlzQ3VzdG9tU1ZHOiB0cnVlLFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cclxuICAgIGlubmVyOiAnPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTIxLjIgMTZhNS4yIDUuMiAwIDEgMS01LjItNS4yVjhhOCA4IDAgMSAwIDggOGgtMi44WlwiIGlkPVwicHN3cF9faWNuLWxvYWRpbmdcIi8+JyxcclxuICAgIG91dGxpbmVJRDogJ3Bzd3BfX2ljbi1sb2FkaW5nJ1xyXG4gIH0sXHJcbiAgb25Jbml0OiAoaW5kaWNhdG9yRWxlbWVudCwgcHN3cCkgPT4ge1xyXG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgbGV0IGlzVmlzaWJsZTtcclxuICAgIC8qKiBAdHlwZSB7Tm9kZUpTLlRpbWVvdXQgfCBudWxsfSAqL1xyXG4gICAgbGV0IGRlbGF5VGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFkZFxyXG4gICAgICovXHJcbiAgICBjb25zdCB0b2dnbGVJbmRpY2F0b3JDbGFzcyA9IChjbGFzc05hbWUsIGFkZCkgPT4ge1xyXG4gICAgICBpbmRpY2F0b3JFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ3Bzd3BfX3ByZWxvYWRlci0tJyArIGNsYXNzTmFtZSwgYWRkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGVcclxuICAgICAqL1xyXG4gICAgY29uc3Qgc2V0SW5kaWNhdG9yVmlzaWJpbGl0eSA9ICh2aXNpYmxlKSA9PiB7XHJcbiAgICAgIGlmIChpc1Zpc2libGUgIT09IHZpc2libGUpIHtcclxuICAgICAgICBpc1Zpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIHRvZ2dsZUluZGljYXRvckNsYXNzKCdhY3RpdmUnLCB2aXNpYmxlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5ID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIXBzd3AuY3VyclNsaWRlPy5jb250ZW50LmlzTG9hZGluZygpKSB7XHJcbiAgICAgICAgc2V0SW5kaWNhdG9yVmlzaWJpbGl0eShmYWxzZSk7XHJcbiAgICAgICAgaWYgKGRlbGF5VGltZW91dCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGRlbGF5VGltZW91dCk7XHJcbiAgICAgICAgICBkZWxheVRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGVsYXlUaW1lb3V0KSB7XHJcbiAgICAgICAgLy8gZGlzcGxheSBsb2FkaW5nIGluZGljYXRvciB3aXRoIGRlbGF5XHJcbiAgICAgICAgZGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBzZXRJbmRpY2F0b3JWaXNpYmlsaXR5KEJvb2xlYW4ocHN3cC5jdXJyU2xpZGU/LmNvbnRlbnQuaXNMb2FkaW5nKCkpKTtcclxuICAgICAgICAgIGRlbGF5VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfSwgcHN3cC5vcHRpb25zLnByZWxvYWRlckRlbGF5KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwc3dwLm9uKCdjaGFuZ2UnLCB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KTtcclxuXHJcbiAgICBwc3dwLm9uKCdsb2FkQ29tcGxldGUnLCAoZSkgPT4ge1xyXG4gICAgICBpZiAocHN3cC5jdXJyU2xpZGUgPT09IGUuc2xpZGUpIHtcclxuICAgICAgICB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGV4cG9zZSB0aGUgbWV0aG9kXHJcbiAgICBpZiAocHN3cC51aSkge1xyXG4gICAgICBwc3dwLnVpLnVwZGF0ZVByZWxvYWRlclZpc2liaWxpdHkgPSB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5O1xyXG4gICAgfVxyXG4gIH1cclxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdWktZWxlbWVudC5qcycpLlVJRWxlbWVudERhdGF9IFVJRWxlbWVudERhdGEgKi9cclxuY29uc3QgY291bnRlckluZGljYXRvciA9IHtcclxuICBuYW1lOiAnY291bnRlcicsXHJcbiAgb3JkZXI6IDUsXHJcbiAgb25Jbml0OiAoY291bnRlckVsZW1lbnQsIHBzd3ApID0+IHtcclxuICAgIHBzd3Aub24oJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgY291bnRlckVsZW1lbnQuaW5uZXJUZXh0ID0gKHBzd3AuY3VyckluZGV4ICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgcHN3cC5vcHRpb25zLmluZGV4SW5kaWNhdG9yU2VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHBzd3AuZ2V0TnVtSXRlbXMoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcblxyXG4vKipcclxuICogU2V0IHNwZWNpYWwgY2xhc3Mgb24gZWxlbWVudCB3aGVuIGltYWdlIGlzIHpvb21lZC5cclxuICpcclxuICogQnkgZGVmYXVsdCwgaXQgaXMgdXNlZCB0byBhZGp1c3RcclxuICogem9vbSBpY29uIGFuZCB6b29tIGN1cnNvciB2aWEgQ1NTLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzWm9vbWVkSW5cclxuICovXHJcbmZ1bmN0aW9uIHNldFpvb21lZEluKGVsLCBpc1pvb21lZEluKSB7XHJcbiAgZWwuY2xhc3NMaXN0LnRvZ2dsZSgncHN3cC0tem9vbWVkLWluJywgaXNab29tZWRJbik7XHJcbn1cclxuXHJcbmNsYXNzIFVJIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XHJcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xyXG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuICAgIC8qKiBAdHlwZSB7VUlFbGVtZW50RGF0YVtdfSAqL1xyXG4gICAgdGhpcy51aUVsZW1lbnRzRGF0YSA9IFtdO1xyXG4gICAgLyoqIEB0eXBlIHsoVUlFbGVtZW50IHwgVUlFbGVtZW50RGF0YSlbXX0gKi9cclxuICAgIHRoaXMuaXRlbXMgPSBbXTtcclxuICAgIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi9cclxuICAgIHRoaXMudXBkYXRlUHJlbG9hZGVyVmlzaWJpbGl0eSA9ICgpID0+IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xhc3RVcGRhdGVkWm9vbUxldmVsID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaW5pdCgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhID0gW1xyXG4gICAgICBjbG9zZUJ1dHRvbixcclxuICAgICAgYXJyb3dQcmV2LFxyXG4gICAgICBhcnJvd05leHQsXHJcbiAgICAgIHpvb21CdXR0b24sXHJcbiAgICAgIGxvYWRpbmdJbmRpY2F0b3IsXHJcbiAgICAgIGNvdW50ZXJJbmRpY2F0b3JcclxuICAgIF07XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaCgndWlSZWdpc3RlcicpO1xyXG5cclxuICAgIC8vIHNvcnQgYnkgb3JkZXJcclxuICAgIHRoaXMudWlFbGVtZW50c0RhdGEuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAvLyBkZWZhdWx0IG9yZGVyIGlzIDBcclxuICAgICAgcmV0dXJuIChhLm9yZGVyIHx8IDApIC0gKGIub3JkZXIgfHwgMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLml0ZW1zID0gW107XHJcblxyXG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgdGhpcy51aUVsZW1lbnRzRGF0YS5mb3JFYWNoKCh1aUVsZW1lbnREYXRhKSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJFbGVtZW50KHVpRWxlbWVudERhdGEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcHN3cC5vbignY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICBwc3dwLmVsZW1lbnQ/LmNsYXNzTGlzdC50b2dnbGUoJ3Bzd3AtLW9uZS1zbGlkZScsIHBzd3AuZ2V0TnVtSXRlbXMoKSA9PT0gMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBwc3dwLm9uKCd6b29tUGFuVXBkYXRlJywgKCkgPT4gdGhpcy5fb25ab29tUGFuVXBkYXRlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtVSUVsZW1lbnREYXRhfSBlbGVtZW50RGF0YVxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyRWxlbWVudChlbGVtZW50RGF0YSkge1xyXG4gICAgaWYgKHRoaXMuaXNSZWdpc3RlcmVkKSB7XHJcbiAgICAgIHRoaXMuaXRlbXMucHVzaChcclxuICAgICAgICBuZXcgVUlFbGVtZW50KHRoaXMucHN3cCwgZWxlbWVudERhdGEpXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnVpRWxlbWVudHNEYXRhLnB1c2goZWxlbWVudERhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZWQgZWFjaCB0aW1lIHpvb20gb3IgcGFuIHBvc2l0aW9uIGlzIGNoYW5nZWQuXHJcbiAgICogVXBkYXRlIGNsYXNzZXMgdGhhdCBjb250cm9sIHZpc2liaWxpdHkgb2Ygem9vbSBidXR0b24gYW5kIGN1cnNvciBpY29uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25ab29tUGFuVXBkYXRlKCkge1xyXG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgY3VyclNsaWRlLCBvcHRpb25zIH0gPSB0aGlzLnBzd3A7XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5vcGVuZXIuaXNDbG9zaW5nIHx8ICF0ZW1wbGF0ZSB8fCAhY3VyclNsaWRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgeyBjdXJyWm9vbUxldmVsIH0gPSBjdXJyU2xpZGU7XHJcblxyXG4gICAgLy8gaWYgbm90IG9wZW4geWV0IC0gY2hlY2sgYWdhaW5zdCBpbml0aWFsIHpvb20gbGV2ZWxcclxuICAgIGlmICghdGhpcy5wc3dwLm9wZW5lci5pc09wZW4pIHtcclxuICAgICAgY3Vyclpvb21MZXZlbCA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPT09IHRoaXMuX2xhc3RVcGRhdGVkWm9vbUxldmVsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2xhc3RVcGRhdGVkWm9vbUxldmVsID0gY3Vyclpvb21MZXZlbDtcclxuXHJcbiAgICBjb25zdCBjdXJyWm9vbUxldmVsRGlmZiA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwgLSBjdXJyU2xpZGUuem9vbUxldmVscy5zZWNvbmRhcnk7XHJcblxyXG4gICAgLy8gSW5pdGlhbCBhbmQgc2Vjb25kYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbG1vc3QgZXF1YWxcclxuICAgIGlmIChNYXRoLmFicyhjdXJyWm9vbUxldmVsRGlmZikgPCAwLjAxIHx8ICFjdXJyU2xpZGUuaXNab29tYWJsZSgpKSB7XHJcbiAgICAgIC8vIGRpc2FibGUgem9vbVxyXG4gICAgICBzZXRab29tZWRJbih0ZW1wbGF0ZSwgZmFsc2UpO1xyXG4gICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKCdwc3dwLS16b29tLWFsbG93ZWQnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRlbXBsYXRlLmNsYXNzTGlzdC5hZGQoJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xyXG5cclxuICAgIGNvbnN0IHBvdGVudGlhbFpvb21MZXZlbCA9IGN1cnJab29tTGV2ZWwgPT09IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWxcclxuICAgICAgPyBjdXJyU2xpZGUuem9vbUxldmVscy5zZWNvbmRhcnkgOiBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsO1xyXG5cclxuICAgIHNldFpvb21lZEluKHRlbXBsYXRlLCBwb3RlbnRpYWxab29tTGV2ZWwgPD0gY3Vyclpvb21MZXZlbCk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaW1hZ2VDbGlja0FjdGlvbiA9PT0gJ3pvb20nXHJcbiAgICAgICAgfHwgb3B0aW9ucy5pbWFnZUNsaWNrQWN0aW9uID09PSAnem9vbS1vci1jbG9zZScpIHtcclxuICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHN3cC0tY2xpY2stdG8tem9vbScpO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB3OiBudW1iZXI7IGlubmVyUmVjdD86IHsgdzogbnVtYmVyOyBoOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfX0gQm91bmRzICovXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHJldHVybnMgQm91bmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3VuZHNCeUVsZW1lbnQoZWwpIHtcclxuICBjb25zdCB0aHVtYkFyZWFSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHRodW1iQXJlYVJlY3QubGVmdCxcclxuICAgIHk6IHRodW1iQXJlYVJlY3QudG9wLFxyXG4gICAgdzogdGh1bWJBcmVhUmVjdC53aWR0aFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW1hZ2VXaWR0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW1hZ2VIZWlnaHRcclxuICogQHJldHVybnMgQm91bmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDcm9wcGVkQm91bmRzQnlFbGVtZW50KGVsLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCkge1xyXG4gIGNvbnN0IHRodW1iQXJlYVJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgLy8gZmlsbCBpbWFnZSBpbnRvIHRoZSBhcmVhXHJcbiAgLy8gKGRvIHRoZXkgc2FtZSBhcyBvYmplY3QtZml0OmNvdmVyIGRvZXMgdG8gcmV0cmlldmUgY29vcmRpbmF0ZXMpXHJcbiAgY29uc3QgaFJhdGlvID0gdGh1bWJBcmVhUmVjdC53aWR0aCAvIGltYWdlV2lkdGg7XHJcbiAgY29uc3QgdlJhdGlvID0gdGh1bWJBcmVhUmVjdC5oZWlnaHQgLyBpbWFnZUhlaWdodDtcclxuICBjb25zdCBmaWxsWm9vbUxldmVsID0gaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvO1xyXG5cclxuICBjb25zdCBvZmZzZXRYID0gKHRodW1iQXJlYVJlY3Qud2lkdGggLSBpbWFnZVdpZHRoICogZmlsbFpvb21MZXZlbCkgLyAyO1xyXG4gIGNvbnN0IG9mZnNldFkgPSAodGh1bWJBcmVhUmVjdC5oZWlnaHQgLSBpbWFnZUhlaWdodCAqIGZpbGxab29tTGV2ZWwpIC8gMjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlLFxyXG4gICAqIGFzIGlmIGl0IHdhcyBub3QgY3JvcHBlZCxcclxuICAgKiBoZWlnaHQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5XHJcbiAgICpcclxuICAgKiBAdHlwZSB7Qm91bmRzfVxyXG4gICAqL1xyXG4gIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgIHg6IHRodW1iQXJlYVJlY3QubGVmdCArIG9mZnNldFgsXHJcbiAgICB5OiB0aHVtYkFyZWFSZWN0LnRvcCArIG9mZnNldFksXHJcbiAgICB3OiBpbWFnZVdpZHRoICogZmlsbFpvb21MZXZlbFxyXG4gIH07XHJcblxyXG4gIC8vIENvb3JkaW5hdGVzIG9mIGlubmVyIGNyb3AgYXJlYVxyXG4gIC8vIHJlbGF0aXZlIHRvIHRoZSBpbWFnZVxyXG4gIGJvdW5kcy5pbm5lclJlY3QgPSB7XHJcbiAgICB3OiB0aHVtYkFyZWFSZWN0LndpZHRoLFxyXG4gICAgaDogdGh1bWJBcmVhUmVjdC5oZWlnaHQsXHJcbiAgICB4OiBvZmZzZXRYLFxyXG4gICAgeTogb2Zmc2V0WVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBib3VuZHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGltZW5zaW9ucyBvZiB0aHVtYm5haWwgaW1hZ2VcclxuICogKGNsaWNrIG9uIHdoaWNoIG9wZW5zIHBob3Rvc3dpcGUgb3IgY2xvc2VzIHBob3Rvc3dpcGUgdG8pXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGFcclxuICogQHBhcmFtIHtQaG90b1N3aXBlfSBpbnN0YW5jZSBQaG90b1N3aXBlIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtCb3VuZHMgfCB1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUaHVtYkJvdW5kcyhpbmRleCwgaXRlbURhdGEsIGluc3RhbmNlKSB7XHJcbiAgLy8gbGVnYWN5IGV2ZW50LCBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICBjb25zdCBldmVudCA9IGluc3RhbmNlLmRpc3BhdGNoKCd0aHVtYkJvdW5kcycsIHtcclxuICAgIGluZGV4LFxyXG4gICAgaXRlbURhdGEsXHJcbiAgICBpbnN0YW5jZVxyXG4gIH0pO1xyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICBpZiAoZXZlbnQudGh1bWJCb3VuZHMpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHJldHVybiBldmVudC50aHVtYkJvdW5kcztcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZWxlbWVudCB9ID0gaXRlbURhdGE7XHJcbiAgLyoqIEB0eXBlIHtCb3VuZHMgfCB1bmRlZmluZWR9ICovXHJcbiAgbGV0IHRodW1iQm91bmRzO1xyXG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xyXG4gIGxldCB0aHVtYm5haWw7XHJcblxyXG4gIGlmIChlbGVtZW50ICYmIGluc3RhbmNlLm9wdGlvbnMudGh1bWJTZWxlY3RvciAhPT0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRodW1iU2VsZWN0b3IgPSBpbnN0YW5jZS5vcHRpb25zLnRodW1iU2VsZWN0b3IgfHwgJ2ltZyc7XHJcbiAgICB0aHVtYm5haWwgPSBlbGVtZW50Lm1hdGNoZXModGh1bWJTZWxlY3RvcilcclxuICAgICAgPyBlbGVtZW50IDogLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9ICovIChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGh1bWJTZWxlY3RvcikpO1xyXG4gIH1cclxuXHJcbiAgdGh1bWJuYWlsID0gaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKCd0aHVtYkVsJywgdGh1bWJuYWlsLCBpdGVtRGF0YSwgaW5kZXgpO1xyXG5cclxuICBpZiAodGh1bWJuYWlsKSB7XHJcbiAgICBpZiAoIWl0ZW1EYXRhLnRodW1iQ3JvcHBlZCkge1xyXG4gICAgICB0aHVtYkJvdW5kcyA9IGdldEJvdW5kc0J5RWxlbWVudCh0aHVtYm5haWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGh1bWJCb3VuZHMgPSBnZXRDcm9wcGVkQm91bmRzQnlFbGVtZW50KFxyXG4gICAgICAgIHRodW1ibmFpbCxcclxuICAgICAgICBpdGVtRGF0YS53aWR0aCB8fCBpdGVtRGF0YS53IHx8IDAsXHJcbiAgICAgICAgaXRlbURhdGEuaGVpZ2h0IHx8IGl0ZW1EYXRhLmggfHwgMFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluc3RhbmNlLmFwcGx5RmlsdGVycygndGh1bWJCb3VuZHMnLCB0aHVtYkJvdW5kcywgaXRlbURhdGEsIGluZGV4KTtcclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vbGlnaHRib3gvbGlnaHRib3guanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlTGlnaHRib3ggKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUGhvdG9Td2lwZU9wdGlvbnN9IFBob3RvU3dpcGVPcHRpb25zICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuRGF0YVNvdXJjZX0gRGF0YVNvdXJjZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vdWkvdWktZWxlbWVudC5qcycpLlVJRWxlbWVudERhdGF9IFVJRWxlbWVudERhdGEgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL2NvbnRlbnQuanMnKS5kZWZhdWx0fSBDb250ZW50RGVmYXVsdCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvem9vbS1sZXZlbC5qcycpLmRlZmF1bHR9IFpvb21MZXZlbCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvZ2V0LXRodW1iLWJvdW5kcy5qcycpLkJvdW5kc30gQm91bmRzICovXHJcblxyXG4vKipcclxuICogQWxsb3cgYWRkaW5nIGFuIGFyYml0cmFyeSBwcm9wcyB0byB0aGUgQ29udGVudFxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2N1c3RvbS1jb250ZW50LyN1c2luZy13ZWJwLWltYWdlLWZvcm1hdFxyXG4gKiBAdHlwZWRlZiB7Q29udGVudERlZmF1bHQgJiBSZWNvcmQ8c3RyaW5nLCBhbnk+fSBDb250ZW50XHJcbiAqL1xyXG4vKiogQHR5cGVkZWYge3sgeD86IG51bWJlcjsgeT86IG51bWJlciB9fSBQb2ludCAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBob3RvU3dpcGVFdmVudHNNYXAgaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9ldmVudHMvXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vYWRkaW5nLXVpLWVsZW1lbnRzL1xyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSB1aVJlZ2lzdGVyXHJcbiAqIEBwcm9wIHt7IGRhdGE6IFVJRWxlbWVudERhdGEgfX0gdWlFbGVtZW50Q3JlYXRlXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNpbml0aWFsaXphdGlvbi1ldmVudHNcclxuICpcclxuICogQHByb3Age3VuZGVmaW5lZH0gYmVmb3JlT3BlblxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBmaXJzdFVwZGF0ZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0aWFsTGF5b3V0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGNoYW5nZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBhZnRlckluaXRcclxuICogQHByb3Age3VuZGVmaW5lZH0gYmluZEV2ZW50c1xyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2V2ZW50cy8jb3BlbmluZy1vci1jbG9zaW5nLXRyYW5zaXRpb24tZXZlbnRzXHJcbiAqXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IG9wZW5pbmdBbmltYXRpb25TdGFydFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBvcGVuaW5nQW5pbWF0aW9uRW5kXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGNsb3NpbmdBbmltYXRpb25TdGFydFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjbG9zaW5nQW5pbWF0aW9uRW5kXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNjbG9zaW5nLWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjbG9zZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBkZXN0cm95XHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNwb2ludGVyLWFuZC1nZXN0dXJlLWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7eyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gcG9pbnRlckRvd25cclxuICogQHByb3Age3sgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IHBvaW50ZXJNb3ZlXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB9fSBwb2ludGVyVXBcclxuICogQHByb3Age3sgYmdPcGFjaXR5OiBudW1iZXIgfX0gcGluY2hDbG9zZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcGFuWTogbnVtYmVyIH19IHZlcnRpY2FsRHJhZyBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICpcclxuICpcclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9ldmVudHMvI3NsaWRlLWNvbnRlbnQtZXZlbnRzXHJcbiAqXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudEluaXRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgaXNMYXp5OiBib29sZWFuIH19IGNvbnRlbnRMb2FkIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyBpc0xhenk6IGJvb2xlYW4gfX0gY29udGVudExvYWRJbWFnZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgc2xpZGU6IFNsaWRlOyBpc0Vycm9yPzogYm9vbGVhbiB9fSBsb2FkQ29tcGxldGVcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgc2xpZGU6IFNsaWRlIH19IGxvYWRFcnJvclxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9fSBjb250ZW50UmVzaXplIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlcjsgc2xpZGU6IFNsaWRlIH19IGltYWdlU2l6ZUNoYW5nZVxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnRMYXp5TG9hZCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50QXBwZW5kIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnRBY3RpdmF0ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50RGVhY3RpdmF0ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50UmVtb3ZlIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnREZXN0cm95IGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKlxyXG4gKlxyXG4gKiB1bmRvY3VtZW50ZWRcclxuICpcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gaW1hZ2VDbGlja0FjdGlvbiBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gYmdDbGlja0FjdGlvbiBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gdGFwQWN0aW9uIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBwb2ludDogUG9pbnQ7IG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB9fSBkb3VibGVUYXBBY3Rpb24gY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IEtleWJvYXJkRXZlbnQgfX0ga2V5ZG93biBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgeDogbnVtYmVyOyBkcmFnZ2luZzogYm9vbGVhbiB9fSBtb3ZlTWFpblNjcm9sbFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gZmlyc3Rab29tUGFuXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB8IHVuZGVmaW5lZCwgZGF0YTogU2xpZGVEYXRhLCBpbmRleDogbnVtYmVyIH19IGdldHRpbmdEYXRhXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGJlZm9yZVJlc2l6ZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSByZXNpemVcclxuICogQHByb3Age3VuZGVmaW5lZH0gdmlld3BvcnRTaXplXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IHVwZGF0ZVNjcm9sbE9mZnNldFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gc2xpZGVJbml0XHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBhZnRlclNldENvbnRlbnRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlTG9hZFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gYXBwZW5kSGVhdnkgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBhcHBlbmRIZWF2eUNvbnRlbnRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlQWN0aXZhdGVcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlRGVhY3RpdmF0ZVxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gc2xpZGVEZXN0cm95XHJcbiAqIEBwcm9wIHt7IGRlc3Rab29tTGV2ZWw6IG51bWJlciwgY2VudGVyUG9pbnQ6IFBvaW50IHwgdW5kZWZpbmVkLCB0cmFuc2l0aW9uRHVyYXRpb246IG51bWJlciB8IGZhbHNlIHwgdW5kZWZpbmVkIH19IGJlZm9yZVpvb21Ub1xyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gem9vbVBhblVwZGF0ZVxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gaW5pdGlhbFpvb21QYW5cclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGNhbGNTbGlkZVNpemVcclxuICogQHByb3Age3VuZGVmaW5lZH0gcmVzb2x1dGlvbkNoYW5nZWRcclxuICogQHByb3Age3sgb3JpZ2luYWxFdmVudDogV2hlZWxFdmVudCB9fSB3aGVlbCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50QXBwZW5kSW1hZ2UgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGluZGV4OiBudW1iZXI7IGl0ZW1EYXRhOiBTbGlkZURhdGEgfX0gbGF6eUxvYWRTbGlkZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3VuZGVmaW5lZH0gbGF6eUxvYWRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGNhbGNCb3VuZHNcclxuICogQHByb3Age3sgem9vbUxldmVsczogWm9vbUxldmVsLCBzbGlkZURhdGE6IFNsaWRlRGF0YSB9fSB6b29tTGV2ZWxzVXBkYXRlXHJcbiAqXHJcbiAqXHJcbiAqIGxlZ2FjeVxyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGluaXRpYWxab29tSW5cclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbFpvb21PdXRcclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbFpvb21JbkVuZFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0aWFsWm9vbU91dEVuZFxyXG4gKiBAcHJvcCB7eyBkYXRhU291cmNlOiBEYXRhU291cmNlIHwgdW5kZWZpbmVkLCBudW1JdGVtczogbnVtYmVyIH19IG51bUl0ZW1zXHJcbiAqIEBwcm9wIHt7IGl0ZW1EYXRhOiBTbGlkZURhdGE7IGluZGV4OiBudW1iZXIgfX0gaXRlbURhdGFcclxuICogQHByb3Age3sgaW5kZXg6IG51bWJlciwgaXRlbURhdGE6IFNsaWRlRGF0YSwgaW5zdGFuY2U6IFBob3RvU3dpcGUgfX0gdGh1bWJCb3VuZHNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gUGhvdG9Td2lwZUZpbHRlcnNNYXAgaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzL1xyXG4gKlxyXG4gKiBAcHJvcCB7KG51bUl0ZW1zOiBudW1iZXIsIGRhdGFTb3VyY2U6IERhdGFTb3VyY2UgfCB1bmRlZmluZWQpID0+IG51bWJlcn0gbnVtSXRlbXNcclxuICogTW9kaWZ5IHRoZSB0b3RhbCBhbW91bnQgb2Ygc2xpZGVzLiBFeGFtcGxlIG9uIERhdGEgc291cmNlcyBwYWdlLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI251bWl0ZW1zXHJcbiAqXHJcbiAqIEBwcm9wIHsoaXRlbURhdGE6IFNsaWRlRGF0YSwgaW5kZXg6IG51bWJlcikgPT4gU2xpZGVEYXRhfSBpdGVtRGF0YVxyXG4gKiBNb2RpZnkgc2xpZGUgaXRlbSBkYXRhLiBFeGFtcGxlIG9uIERhdGEgc291cmNlcyBwYWdlLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2l0ZW1kYXRhXHJcbiAqXHJcbiAqIEBwcm9wIHsoaXRlbURhdGE6IFNsaWRlRGF0YSwgZWxlbWVudDogSFRNTEVsZW1lbnQsIGxpbmtFbDogSFRNTEFuY2hvckVsZW1lbnQpID0+IFNsaWRlRGF0YX0gZG9tSXRlbURhdGFcclxuICogTW9kaWZ5IGl0ZW0gZGF0YSB3aGVuIGl0J3MgcGFyc2VkIGZyb20gRE9NIGVsZW1lbnQuIEV4YW1wbGUgb24gRGF0YSBzb3VyY2VzIHBhZ2UuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jZG9taXRlbWRhdGFcclxuICpcclxuICogQHByb3AgeyhjbGlja2VkSW5kZXg6IG51bWJlciwgZTogTW91c2VFdmVudCwgaW5zdGFuY2U6IFBob3RvU3dpcGVMaWdodGJveCkgPT4gbnVtYmVyfSBjbGlja2VkSW5kZXhcclxuICogTW9kaWZ5IGNsaWNrZWQgZ2FsbGVyeSBpdGVtIGluZGV4LlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2NsaWNrZWRpbmRleFxyXG4gKlxyXG4gKiBAcHJvcCB7KHBsYWNlaG9sZGVyU3JjOiBzdHJpbmcgfCBmYWxzZSwgY29udGVudDogQ29udGVudCkgPT4gc3RyaW5nIHwgZmFsc2V9IHBsYWNlaG9sZGVyU3JjXHJcbiAqIE1vZGlmeSBwbGFjZWhvbGRlciBpbWFnZSBzb3VyY2UuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jcGxhY2Vob2xkZXJzcmNcclxuICpcclxuICogQHByb3Ageyhpc0NvbnRlbnRMb2FkaW5nOiBib29sZWFuLCBjb250ZW50OiBDb250ZW50KSA9PiBib29sZWFufSBpc0NvbnRlbnRMb2FkaW5nXHJcbiAqIE1vZGlmeSBpZiB0aGUgY29udGVudCBpcyBjdXJyZW50bHkgbG9hZGluZy5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNpc2NvbnRlbnRsb2FkaW5nXHJcbiAqXHJcbiAqIEBwcm9wIHsoaXNDb250ZW50Wm9vbWFibGU6IGJvb2xlYW4sIGNvbnRlbnQ6IENvbnRlbnQpID0+IGJvb2xlYW59IGlzQ29udGVudFpvb21hYmxlXHJcbiAqIE1vZGlmeSBpZiB0aGUgY29udGVudCBjYW4gYmUgem9vbWVkLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2lzY29udGVudHpvb21hYmxlXHJcbiAqXHJcbiAqIEBwcm9wIHsodXNlQ29udGVudFBsYWNlaG9sZGVyOiBib29sZWFuLCBjb250ZW50OiBDb250ZW50KSA9PiBib29sZWFufSB1c2VDb250ZW50UGxhY2Vob2xkZXJcclxuICogTW9kaWZ5IGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGNvbnRlbnQuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jdXNlY29udGVudHBsYWNlaG9sZGVyXHJcbiAqXHJcbiAqIEBwcm9wIHsoaXNLZWVwaW5nUGxhY2Vob2xkZXI6IGJvb2xlYW4sIGNvbnRlbnQ6IENvbnRlbnQpID0+IGJvb2xlYW59IGlzS2VlcGluZ1BsYWNlaG9sZGVyXHJcbiAqIE1vZGlmeSBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIGtlcHQgYWZ0ZXIgdGhlIGNvbnRlbnQgaXMgbG9hZGVkLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2lza2VlcGluZ3BsYWNlaG9sZGVyXHJcbiAqXHJcbiAqXHJcbiAqIEBwcm9wIHsoY29udGVudEVycm9yRWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbnRlbnQ6IENvbnRlbnQpID0+IEhUTUxFbGVtZW50fSBjb250ZW50RXJyb3JFbGVtZW50XHJcbiAqIE1vZGlmeSBhbiBlbGVtZW50IHdoZW4gdGhlIGNvbnRlbnQgaGFzIGVycm9yIHN0YXRlIChmb3IgZXhhbXBsZSwgaWYgaW1hZ2UgY2Fubm90IGJlIGxvYWRlZCkuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jY29udGVudGVycm9yZWxlbWVudFxyXG4gKlxyXG4gKiBAcHJvcCB7KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkYXRhOiBVSUVsZW1lbnREYXRhKSA9PiBIVE1MRWxlbWVudH0gdWlFbGVtZW50XHJcbiAqIE1vZGlmeSBhIFVJIGVsZW1lbnQgdGhhdCdzIGJlaW5nIGNyZWF0ZWQuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jdWllbGVtZW50XHJcbiAqXHJcbiAqIEBwcm9wIHsodGh1bWJuYWlsOiBIVE1MRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IEhUTUxFbGVtZW50fSB0aHVtYkVsXHJcbiAqIE1vZGlmeSB0aGUgdGh1Ym1uYWlsIGVsZW1lbnQgZnJvbSB3aGljaCBvcGVuaW5nIHpvb20gYW5pbWF0aW9uIHN0YXJ0cyBvciBlbmRzLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI3RodW1iZWxcclxuICpcclxuICogQHByb3Ageyh0aHVtYkJvdW5kczogQm91bmRzIHwgdW5kZWZpbmVkLCBpdGVtRGF0YTogU2xpZGVEYXRhLCBpbmRleDogbnVtYmVyKSA9PiBCb3VuZHN9IHRodW1iQm91bmRzXHJcbiAqIE1vZGlmeSB0aGUgdGh1Ym1uYWlsIGJvdW5kcyBmcm9tIHdoaWNoIG9wZW5pbmcgem9vbSBhbmltYXRpb24gc3RhcnRzIG9yIGVuZHMuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jdGh1bWJib3VuZHNcclxuICpcclxuICogQHByb3AgeyhzcmNzZXRTaXplc1dpZHRoOiBudW1iZXIsIGNvbnRlbnQ6IENvbnRlbnQpID0+IG51bWJlcn0gc3Jjc2V0U2l6ZXNXaWR0aFxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHt7IGZuOiBQaG90b1N3aXBlRmlsdGVyc01hcFtUXSwgcHJpb3JpdHk6IG51bWJlciB9fSBGaWx0ZXJcclxuICovXHJcblxyXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHtQaG90b1N3aXBlRXZlbnRzTWFwW1RdIGV4dGVuZHMgdW5kZWZpbmVkID8gUGhvdG9Td2lwZUV2ZW50PFQ+IDogUGhvdG9Td2lwZUV2ZW50PFQ+ICYgUGhvdG9Td2lwZUV2ZW50c01hcFtUXX0gQXVnbWVudGVkRXZlbnRcclxuICovXHJcblxyXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHsoZXZlbnQ6IEF1Z21lbnRlZEV2ZW50PFQ+KSA9PiB2b2lkfSBFdmVudENhbGxiYWNrXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgUGhvdG9Td2lwZSBldmVudCBvYmplY3RcclxuICpcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqL1xyXG5jbGFzcyBQaG90b1N3aXBlRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7VH0gdHlwZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUV2ZW50c01hcFtUXX0gW2RldGFpbHNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZSwgZGV0YWlscykge1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gICAgaWYgKGRldGFpbHMpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZXRhaWxzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByZXZlbnREZWZhdWx0KCkge1xyXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQaG90b1N3aXBlIGJhc2UgY2xhc3MgdGhhdCBjYW4gbGlzdGVuIGFuZCBkaXNwYXRjaCBmb3IgZXZlbnRzLlxyXG4gKiBTaGFyZWQgYnkgUGhvdG9Td2lwZSBDb3JlIGFuZCBQaG90b1N3aXBlIExpZ2h0Ym94LCBleHRlbmRlZCBieSBiYXNlLmpzXHJcbiAqL1xyXG5jbGFzcyBFdmVudGFibGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7eyBbVCBpbiBrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwXT86ICgoZXZlbnQ6IEF1Z21lbnRlZEV2ZW50PFQ+KSA9PiB2b2lkKVtdIH19XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge3sgW1QgaW4ga2V5b2YgUGhvdG9Td2lwZUZpbHRlcnNNYXBdPzogRmlsdGVyPFQ+W10gfX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZmlsdGVycyA9IHt9O1xyXG5cclxuICAgIC8qKiBAdHlwZSB7UGhvdG9Td2lwZSB8IHVuZGVmaW5lZH0gKi9cclxuICAgIHRoaXMucHN3cCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKiogQHR5cGUge1Bob3RvU3dpcGVPcHRpb25zIHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRmlsdGVyc01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUZpbHRlcnNNYXBbVF19IGZuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5XHJcbiAgICovXHJcbiAgYWRkRmlsdGVyKG5hbWUsIGZuLCBwcmlvcml0eSA9IDEwMCkge1xyXG4gICAgaWYgKCF0aGlzLl9maWx0ZXJzW25hbWVdKSB7XHJcbiAgICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9maWx0ZXJzW25hbWVdPy5wdXNoKHsgZm4sIHByaW9yaXR5IH0pO1xyXG4gICAgdGhpcy5fZmlsdGVyc1tuYW1lXT8uc29ydCgoZjEsIGYyKSA9PiBmMS5wcmlvcml0eSAtIGYyLnByaW9yaXR5KTtcclxuXHJcbiAgICB0aGlzLnBzd3A/LmFkZEZpbHRlcihuYW1lLCBmbiwgcHJpb3JpdHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRmlsdGVyc01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUZpbHRlcnNNYXBbVF19IGZuXHJcbiAgICovXHJcbiAgcmVtb3ZlRmlsdGVyKG5hbWUsIGZuKSB7XHJcbiAgICBpZiAodGhpcy5fZmlsdGVyc1tuYW1lXSkge1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0gPSB0aGlzLl9maWx0ZXJzW25hbWVdLmZpbHRlcihmaWx0ZXIgPT4gKGZpbHRlci5mbiAhPT0gZm4pKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wc3dwKSB7XHJcbiAgICAgIHRoaXMucHN3cC5yZW1vdmVGaWx0ZXIobmFtZSwgZm4pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRmlsdGVyc01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGFyYW1ldGVyczxQaG90b1N3aXBlRmlsdGVyc01hcFtUXT59IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7UGFyYW1ldGVyczxQaG90b1N3aXBlRmlsdGVyc01hcFtUXT5bMF19XHJcbiAgICovXHJcbiAgYXBwbHlGaWx0ZXJzKG5hbWUsIC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0/LmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgIGFyZ3NbMF0gPSBmaWx0ZXIuZm4uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhcmdzWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAgICogQHBhcmFtIHtUfSBuYW1lXHJcbiAgICogQHBhcmFtIHtFdmVudENhbGxiYWNrPFQ+fSBmblxyXG4gICAqL1xyXG4gIG9uKG5hbWUsIGZuKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tuYW1lXSkge1xyXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXT8ucHVzaChmbik7XHJcblxyXG4gICAgLy8gV2hlbiBiaW5kaW5nIGV2ZW50cyB0byBsaWdodGJveCxcclxuICAgIC8vIGFsc28gYmluZCBldmVudHMgdG8gUGhvdG9Td2lwZSBDb3JlLFxyXG4gICAgLy8gaWYgaXQncyBvcGVuLlxyXG4gICAgdGhpcy5wc3dwPy5vbihuYW1lLCBmbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVFdmVudHNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge0V2ZW50Q2FsbGJhY2s8VD59IGZuXHJcbiAgICovXHJcbiAgb2ZmKG5hbWUsIGZuKSB7XHJcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gdGhpcy5fbGlzdGVuZXJzW25hbWVdLmZpbHRlcihsaXN0ZW5lciA9PiAoZm4gIT09IGxpc3RlbmVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wc3dwPy5vZmYobmFtZSwgZm4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAgICogQHBhcmFtIHtUfSBuYW1lXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlRXZlbnRzTWFwW1RdfSBbZGV0YWlsc11cclxuICAgKiBAcmV0dXJucyB7QXVnbWVudGVkRXZlbnQ8VD59XHJcbiAgICovXHJcbiAgZGlzcGF0Y2gobmFtZSwgZGV0YWlscykge1xyXG4gICAgaWYgKHRoaXMucHN3cCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wc3dwLmRpc3BhdGNoKG5hbWUsIGRldGFpbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV2ZW50ID0gLyoqIEB0eXBlIHtBdWdtZW50ZWRFdmVudDxUPn0gKi8gKG5ldyBQaG90b1N3aXBlRXZlbnQobmFtZSwgZGV0YWlscykpO1xyXG5cclxuICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbiAgfVxyXG59XG5cbmNsYXNzIFBsYWNlaG9sZGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZyB8IGZhbHNlfSBpbWFnZVNyY1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGltYWdlU3JjLCBjb250YWluZXIpIHtcclxuICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlclxyXG4gICAgLy8gKHN0cmV0Y2hlZCB0aHVtYm5haWwgb3Igc2ltcGxlIGRpdiBiZWhpbmQgdGhlIG1haW4gaW1hZ2UpXHJcbiAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MRGl2RWxlbWVudCB8IG51bGx9ICovXHJcbiAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFxyXG4gICAgICAncHN3cF9faW1nIHBzd3BfX2ltZy0tcGxhY2Vob2xkZXInLFxyXG4gICAgICBpbWFnZVNyYyA/ICdpbWcnIDogJ2RpdicsXHJcbiAgICAgIGNvbnRhaW5lclxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoaW1hZ2VTcmMpIHtcclxuICAgICAgY29uc3QgaW1nRWwgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICBpbWdFbC5kZWNvZGluZyA9ICdhc3luYyc7XHJcbiAgICAgIGltZ0VsLmFsdCA9ICcnO1xyXG4gICAgICBpbWdFbC5zcmMgPSBpbWFnZVNyYztcclxuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKi9cclxuICBzZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICghdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgICAgIC8vIFVzZSB0cmFuc2Zvcm0gc2NhbGUoKSB0byBtb2RpZnkgaW1nIHBsYWNlaG9sZGVyIHNpemVcclxuICAgICAgLy8gKGluc3RlYWQgb2YgY2hhbmdpbmcgd2lkdGgvaGVpZ2h0IGRpcmVjdGx5KS5cclxuICAgICAgLy8gVGhpcyBoZWxwcyB3aXRoIHBlcmZvcm1hbmNlLCBzcGVjaWZpY2FsbHkgaW4gaU9TMTUgU2FmYXJpLlxyXG4gICAgICBzZXRXaWR0aEhlaWdodCh0aGlzLmVsZW1lbnQsIDI1MCwgJ2F1dG8nKTtcclxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2Zvcm1TdHJpbmcoMCwgMCwgd2lkdGggLyAyNTApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0V2lkdGhIZWlnaHQodGhpcy5lbGVtZW50LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50Py5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlLmpzJykuZGVmYXVsdH0gU2xpZGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vY29yZS9iYXNlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZUJhc2UgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3V0aWwvdXRpbC5qcycpLkxvYWRTdGF0ZX0gTG9hZFN0YXRlICovXHJcblxyXG5jbGFzcyBDb250ZW50IHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgU2xpZGUgZGF0YVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUJhc2V9IGluc3RhbmNlIFBob3RvU3dpcGUgb3IgUGhvdG9Td2lwZUxpZ2h0Ym94IGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaXRlbURhdGEsIGluc3RhbmNlLCBpbmRleCkge1xyXG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgdGhpcy5kYXRhID0gaXRlbURhdGE7XHJcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWR9ICovXHJcbiAgICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAvKiogQHR5cGUge1BsYWNlaG9sZGVyIHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHVuZGVmaW5lZDtcclxuICAgIC8qKiBAdHlwZSB7U2xpZGUgfCB1bmRlZmluZWR9ICovXHJcbiAgICB0aGlzLnNsaWRlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCA9IDA7XHJcbiAgICB0aGlzLmRpc3BsYXllZEltYWdlSGVpZ2h0ID0gMDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuZGF0YS53KSB8fCBOdW1iZXIodGhpcy5kYXRhLndpZHRoKSB8fCAwO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5kYXRhLmgpIHx8IE51bWJlcih0aGlzLmRhdGEuaGVpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNTbGlkZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc0RlY29kaW5nID0gZmFsc2U7XHJcbiAgICAvKiogQHR5cGUge0xvYWRTdGF0ZX0gKi9cclxuICAgIHRoaXMuc3RhdGUgPSBMT0FEX1NUQVRFLklETEU7XHJcblxyXG4gICAgaWYgKHRoaXMuZGF0YS50eXBlKSB7XHJcbiAgICAgIHRoaXMudHlwZSA9IHRoaXMuZGF0YS50eXBlO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuc3JjKSB7XHJcbiAgICAgIHRoaXMudHlwZSA9ICdpbWFnZSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnR5cGUgPSAnaHRtbCc7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudEluaXQnLCB7IGNvbnRlbnQ6IHRoaXMgfSk7XHJcbiAgfVxyXG5cclxuICByZW1vdmVQbGFjZWhvbGRlcigpIHtcclxuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyICYmICF0aGlzLmtlZXBQbGFjZWhvbGRlcigpKSB7XHJcbiAgICAgIC8vIFdpdGggZGVsYXksIGFzIGltYWdlIG1pZ2h0IGJlIGxvYWRlZCwgYnV0IG5vdCByZW5kZXJlZFxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgMTAwMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVsb2FkIGNvbnRlbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMYXp5XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVsb2FkXVxyXG4gICAqL1xyXG4gIGxvYWQoaXNMYXp5LCByZWxvYWQpIHtcclxuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMudXNlUGxhY2Vob2xkZXIoKSkge1xyXG4gICAgICBpZiAoIXRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlclNyYyA9IHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKFxyXG4gICAgICAgICAgJ3BsYWNlaG9sZGVyU3JjJyxcclxuICAgICAgICAgIC8vIHVzZSAgaW1hZ2UtYmFzZWQgcGxhY2Vob2xkZXIgb25seSBmb3IgdGhlIGZpcnN0IHNsaWRlLFxyXG4gICAgICAgICAgLy8gYXMgcmVuZGVyaW5nIChldmVuIHNtYWxsIHN0cmV0Y2hlZCB0aHVtYm5haWwpIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb25cclxuICAgICAgICAgICh0aGlzLmRhdGEubXNyYyAmJiB0aGlzLnNsaWRlLmlzRmlyc3RTbGlkZSkgPyB0aGlzLmRhdGEubXNyYyA6IGZhbHNlLFxyXG4gICAgICAgICAgdGhpc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG5ldyBQbGFjZWhvbGRlcihcclxuICAgICAgICAgIHBsYWNlaG9sZGVyU3JjLFxyXG4gICAgICAgICAgdGhpcy5zbGlkZS5jb250YWluZXJcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRWwgPSB0aGlzLnBsYWNlaG9sZGVyLmVsZW1lbnQ7XHJcbiAgICAgICAgLy8gQWRkIHBsYWNlaG9sZGVyIHRvIERPTSBpZiBpdCB3YXMgYWxyZWFkeSBjcmVhdGVkXHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyRWwgJiYgIXBsYWNlaG9sZGVyRWwucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgdGhpcy5zbGlkZS5jb250YWluZXIucHJlcGVuZChwbGFjZWhvbGRlckVsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50ICYmICFyZWxvYWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50TG9hZCcsIHsgY29udGVudDogdGhpcywgaXNMYXp5IH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzSW1hZ2VDb250ZW50KCkpIHtcclxuICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudCgncHN3cF9faW1nJywgJ2ltZycpO1xyXG4gICAgICAvLyBTdGFydCBsb2FkaW5nIG9ubHkgYWZ0ZXIgd2lkdGggaXMgZGVmaW5lZCwgYXMgc2l6ZXMgbWlnaHQgZGVwZW5kIG9uIGl0LlxyXG4gICAgICAvLyBEdWUgdG8gU2FmYXJpIGZlYXR1cmUsIHdlIG11c3QgZGVmaW5lIHNpemVzIGJlZm9yZSBzcmNzZXQuXHJcbiAgICAgIGlmICh0aGlzLmRpc3BsYXllZEltYWdlV2lkdGgpIHtcclxuICAgICAgICB0aGlzLmxvYWRJbWFnZShpc0xhenkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19jb250ZW50JywgJ2RpdicpO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5kYXRhLmh0bWwgfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbG9hZCAmJiB0aGlzLnNsaWRlKSB7XHJcbiAgICAgIHRoaXMuc2xpZGUudXBkYXRlQ29udGVudFNpemUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVsb2FkIGltYWdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGF6eVxyXG4gICAqL1xyXG4gIGxvYWRJbWFnZShpc0xhenkpIHtcclxuICAgIGlmICghdGhpcy5pc0ltYWdlQ29udGVudCgpXHJcbiAgICAgIHx8ICF0aGlzLmVsZW1lbnRcclxuICAgICAgfHwgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudExvYWRJbWFnZScsIHsgY29udGVudDogdGhpcywgaXNMYXp5IH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IC8qKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50ICovICh0aGlzLmVsZW1lbnQpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlU3Jjc2V0U2l6ZXMoKTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhLnNyY3NldCkge1xyXG4gICAgICBpbWFnZUVsZW1lbnQuc3Jjc2V0ID0gdGhpcy5kYXRhLnNyY3NldDtcclxuICAgIH1cclxuXHJcbiAgICBpbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5kYXRhLnNyYyA/PyAnJztcclxuICAgIGltYWdlRWxlbWVudC5hbHQgPSB0aGlzLmRhdGEuYWx0ID8/ICcnO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBMT0FEX1NUQVRFLkxPQURJTkc7XHJcblxyXG4gICAgaWYgKGltYWdlRWxlbWVudC5jb21wbGV0ZSkge1xyXG4gICAgICB0aGlzLm9uTG9hZGVkKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMub25Mb2FkZWQoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMub25FcnJvcigpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXNzaWduIHNsaWRlIHRvIGNvbnRlbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2xpZGV9IHNsaWRlXHJcbiAgICovXHJcbiAgc2V0U2xpZGUoc2xpZGUpIHtcclxuICAgIHRoaXMuc2xpZGUgPSBzbGlkZTtcclxuICAgIHRoaXMuaGFzU2xpZGUgPSB0cnVlO1xyXG4gICAgdGhpcy5pbnN0YW5jZSA9IHNsaWRlLnBzd3A7XHJcblxyXG4gICAgLy8gdG9kbzogZG8gd2UgbmVlZCB0byB1bnNldCBzbGlkZT9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnRlbnQgbG9hZCBzdWNjZXNzIGhhbmRsZXJcclxuICAgKi9cclxuICBvbkxvYWRlZCgpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBMT0FEX1NUQVRFLkxPQURFRDtcclxuXHJcbiAgICBpZiAodGhpcy5zbGlkZSAmJiB0aGlzLmVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZENvbXBsZXRlJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgY29udGVudDogdGhpcyB9KTtcclxuXHJcbiAgICAgIC8vIGlmIGNvbnRlbnQgaXMgcmVsb2FkZWRcclxuICAgICAgaWYgKHRoaXMuc2xpZGUuaXNBY3RpdmVcclxuICAgICAgICAgICYmIHRoaXMuc2xpZGUuaGVhdnlBcHBlbmRlZFxyXG4gICAgICAgICAgJiYgIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmQoKTtcclxuICAgICAgICB0aGlzLnNsaWRlLnVwZGF0ZUNvbnRlbnRTaXplKHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5MT0FERUQgfHwgdGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUikge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGVudCBsb2FkIGVycm9yIGhhbmRsZXJcclxuICAgKi9cclxuICBvbkVycm9yKCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IExPQURfU1RBVEUuRVJST1I7XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZENvbXBsZXRlJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgaXNFcnJvcjogdHJ1ZSwgY29udGVudDogdGhpcyB9KTtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZEVycm9yJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgY29udGVudDogdGhpcyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgY29udGVudCBpcyBjdXJyZW50bHkgbG9hZGluZ1xyXG4gICAqL1xyXG4gIGlzTG9hZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ2lzQ29udGVudExvYWRpbmcnLFxyXG4gICAgICB0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkxPQURJTkcsXHJcbiAgICAgIHRoaXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgaXMgaW4gZXJyb3Igc3RhdGVcclxuICAgKi9cclxuICBpc0Vycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IExPQURfU1RBVEUuRVJST1I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgaXMgaW1hZ2VcclxuICAgKi9cclxuICBpc0ltYWdlQ29udGVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdpbWFnZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgY29udGVudCBzaXplXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAgICovXHJcbiAgc2V0RGlzcGxheWVkU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgdGhpcy5wbGFjZWhvbGRlci5zZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKFxyXG4gICAgICAnY29udGVudFJlc2l6ZScsXHJcbiAgICAgIHsgY29udGVudDogdGhpcywgd2lkdGgsIGhlaWdodCB9KS5kZWZhdWx0UHJldmVudGVkXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFdpZHRoSGVpZ2h0KHRoaXMuZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSAmJiAhdGhpcy5pc0Vycm9yKCkpIHtcclxuICAgICAgY29uc3QgaXNJbml0aWFsU2l6ZVVwZGF0ZSA9ICghdGhpcy5kaXNwbGF5ZWRJbWFnZVdpZHRoICYmIHdpZHRoKTtcclxuXHJcbiAgICAgIHRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCA9IHdpZHRoO1xyXG4gICAgICB0aGlzLmRpc3BsYXllZEltYWdlSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgaWYgKGlzSW5pdGlhbFNpemVVcGRhdGUpIHtcclxuICAgICAgICB0aGlzLmxvYWRJbWFnZShmYWxzZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTcmNzZXRTaXplcygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5zbGlkZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goXHJcbiAgICAgICAgICAnaW1hZ2VTaXplQ2hhbmdlJyxcclxuICAgICAgICAgIHsgc2xpZGU6IHRoaXMuc2xpZGUsIHdpZHRoLCBoZWlnaHQsIGNvbnRlbnQ6IHRoaXMgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgY29udGVudCBjYW4gYmUgem9vbWVkXHJcbiAgICovXHJcbiAgaXNab29tYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ2lzQ29udGVudFpvb21hYmxlJyxcclxuICAgICAgdGhpcy5pc0ltYWdlQ29udGVudCgpICYmICh0aGlzLnN0YXRlICE9PSBMT0FEX1NUQVRFLkVSUk9SKSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBpbWFnZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlIGJhc2VkIG9uIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgKi9cclxuICB1cGRhdGVTcmNzZXRTaXplcygpIHtcclxuICAgIC8vIEhhbmRsZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlLlxyXG4gICAgLy9cclxuICAgIC8vIE5ldmVyIGxvd2VyIHF1YWxpdHksIGlmIGl0IHdhcyBpbmNyZWFzZWQgcHJldmlvdXNseS5cclxuICAgIC8vIENocm9tZSBkb2VzIHRoaXMgYXV0b21hdGljYWxseSwgRmlyZWZveCBhbmQgU2FmYXJpIGRvIG5vdCxcclxuICAgIC8vIHNvIHdlIHN0b3JlIGxhcmdlc3QgdXNlZCBzaXplIGluIGRhdGFzZXQuXHJcbiAgICBpZiAoIXRoaXMuaXNJbWFnZUNvbnRlbnQoKSB8fCAhdGhpcy5lbGVtZW50IHx8ICF0aGlzLmRhdGEuc3Jjc2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbWFnZSA9IC8qKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50ICovICh0aGlzLmVsZW1lbnQpO1xyXG4gICAgY29uc3Qgc2l6ZXNXaWR0aCA9IHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKFxyXG4gICAgICAnc3Jjc2V0U2l6ZXNXaWR0aCcsXHJcbiAgICAgIHRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICFpbWFnZS5kYXRhc2V0Lmxhcmdlc3RVc2VkU2l6ZVxyXG4gICAgICB8fCBzaXplc1dpZHRoID4gcGFyc2VJbnQoaW1hZ2UuZGF0YXNldC5sYXJnZXN0VXNlZFNpemUsIDEwKVxyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlLnNpemVzID0gc2l6ZXNXaWR0aCArICdweCc7XHJcbiAgICAgIGltYWdlLmRhdGFzZXQubGFyZ2VzdFVzZWRTaXplID0gU3RyaW5nKHNpemVzV2lkdGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IElmIGNvbnRlbnQgc2hvdWxkIHVzZSBhIHBsYWNlaG9sZGVyIChmcm9tIG1zcmMgYnkgZGVmYXVsdClcclxuICAgKi9cclxuICB1c2VQbGFjZWhvbGRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ3VzZUNvbnRlbnRQbGFjZWhvbGRlcicsXHJcbiAgICAgIHRoaXMuaXNJbWFnZUNvbnRlbnQoKSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZWxvYWQgY29udGVudCB3aXRoIGxhenktbG9hZGluZyBwYXJhbVxyXG4gICAqL1xyXG4gIGxhenlMb2FkKCkge1xyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRMYXp5TG9hZCcsIHsgY29udGVudDogdGhpcyB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvYWQodHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIGtlcHQgYWZ0ZXIgY29udGVudCBpcyBsb2FkZWRcclxuICAgKi9cclxuICBrZWVwUGxhY2Vob2xkZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoXHJcbiAgICAgICdpc0tlZXBpbmdQbGFjZWhvbGRlcicsXHJcbiAgICAgIHRoaXMuaXNMb2FkaW5nKCksXHJcbiAgICAgIHRoaXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSBjb250ZW50XHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuaGFzU2xpZGUgPSBmYWxzZTtcclxuICAgIHRoaXMuc2xpZGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnREZXN0cm95JywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgdGhpcy5wbGFjZWhvbGRlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSAmJiB0aGlzLmVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5lbGVtZW50Lm9ubG9hZCA9IG51bGw7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5vbmVycm9yID0gbnVsbDtcclxuICAgICAgdGhpcy5lbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGxheSBlcnJvciBtZXNzYWdlXHJcbiAgICovXHJcbiAgZGlzcGxheUVycm9yKCkge1xyXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgbGV0IGVycm9yTXNnRWwgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19lcnJvci1tc2cnLCAnZGl2Jyk7XHJcbiAgICAgIGVycm9yTXNnRWwuaW5uZXJUZXh0ID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zPy5lcnJvck1zZyA/PyAnJztcclxuICAgICAgZXJyb3JNc2dFbCA9IC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovICh0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgICAnY29udGVudEVycm9yRWxlbWVudCcsXHJcbiAgICAgICAgZXJyb3JNc2dFbCxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICkpO1xyXG4gICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19jb250ZW50IHBzd3BfX2Vycm9yLW1zZy1jb250YWluZXInLCAnZGl2Jyk7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChlcnJvck1zZ0VsKTtcclxuICAgICAgdGhpcy5zbGlkZS5jb250YWluZXIuaW5uZXJUZXh0ID0gJyc7XHJcbiAgICAgIHRoaXMuc2xpZGUuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuc2xpZGUudXBkYXRlQ29udGVudFNpemUodHJ1ZSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCB0aGUgY29udGVudFxyXG4gICAqL1xyXG4gIGFwcGVuZCgpIHtcclxuICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgfHwgIXRoaXMuZWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUikge1xyXG4gICAgICB0aGlzLmRpc3BsYXlFcnJvcigpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRBcHBlbmQnLCB7IGNvbnRlbnQ6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3VwcG9ydHNEZWNvZGUgPSAoJ2RlY29kZScgaW4gdGhpcy5lbGVtZW50KTtcclxuXHJcbiAgICBpZiAodGhpcy5pc0ltYWdlQ29udGVudCgpKSB7XHJcbiAgICAgIC8vIFVzZSBkZWNvZGUoKSBvbiBuZWFyYnkgc2xpZGVzXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIE5lYXJieSBzbGlkZSBpbWFnZXMgYXJlIGluIERPTSBhbmQgbm90IGhpZGRlbiB2aWEgZGlzcGxheTpub25lLlxyXG4gICAgICAvLyBIb3dldmVyLCB0aGV5IGFyZSBwbGFjZWQgb2Zmc2NyZWVuICh0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSkuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IGNvbXBvc2l0ZSB0aGUgaW1hZ2UgdW50aWwgaXQncyBhY3R1YWxseSB2aXNpYmxlLFxyXG4gICAgICAvLyB1c2luZyBkZWNvZGUoKSBoZWxwcy5cclxuICAgICAgLy9cclxuICAgICAgLy8gWW91IG1pZ2h0IGFzayBcIndoeSBkb250IHlvdSBqdXN0IGRlY29kZSgpIGFuZCB0aGVuIGFwcGVuZCBhbGwgaW1hZ2VzXCIsXHJcbiAgICAgIC8vIHRoYXQncyBiZWNhdXNlIEkgd2FudCB0byBzaG93IGltYWdlIGJlZm9yZSBpdCdzIGZ1bGx5IGxvYWRlZCxcclxuICAgICAgLy8gYXMgYnJvd3NlciBjYW4gcmVuZGVyIHBhcnRzIG9mIGltYWdlIHdoaWxlIGl0IGlzIGxvYWRpbmcuXHJcbiAgICAgIC8vIFdlIGRvIG5vdCBkbyB0aGlzIGluIFNhZmFyaSBkdWUgdG8gcGFydGlhbCBsb2FkaW5nIGJ1Zy5cclxuICAgICAgaWYgKHN1cHBvcnRzRGVjb2RlICYmIHRoaXMuc2xpZGUgJiYgKCF0aGlzLnNsaWRlLmlzQWN0aXZlIHx8IGlzU2FmYXJpKCkpKSB7XHJcbiAgICAgICAgdGhpcy5pc0RlY29kaW5nID0gdHJ1ZTtcclxuICAgICAgICAvLyBwdXJwb3NlZnVsbHkgdXNpbmcgZmluYWxseSBpbnN0ZWFkIG9mIHRoZW4sXHJcbiAgICAgICAgLy8gYXMgaWYgc3Jjc2V0IHNpemVzIGNoYW5nZXMgZHluYW1pY2FsbHkgLSBpdCBtYXkgY2F1c2UgZGVjb2RlIGVycm9yXHJcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqL1xyXG4gICAgICAgICh0aGlzLmVsZW1lbnQpLmRlY29kZSgpLmNhdGNoKCgpID0+IHt9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuaXNEZWNvZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5hcHBlbmRJbWFnZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kSW1hZ2UoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLnNsaWRlICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWN0aXZhdGUgdGhlIHNsaWRlLFxyXG4gICAqIGFjdGl2ZSBzbGlkZSBpcyBnZW5lcmFsbHkgdGhlIGN1cnJlbnQgb25lLFxyXG4gICAqIG1lYW5pbmcgdGhlIHVzZXIgY2FuIHNlZSBpdC5cclxuICAgKi9cclxuICBhY3RpdmF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50QWN0aXZhdGUnLCB7IGNvbnRlbnQ6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZFxyXG4gICAgICB8fCAhdGhpcy5zbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSAmJiB0aGlzLmlzRGVjb2RpbmcgJiYgIWlzU2FmYXJpKCkpIHtcclxuICAgICAgLy8gYWRkIGltYWdlIHRvIHNsaWRlIHdoZW4gaXQgYmVjb21lcyBhY3RpdmUsXHJcbiAgICAgIC8vIGV2ZW4gaWYgaXQncyBub3QgZmluaXNoZWQgZGVjb2RpbmdcclxuICAgICAgdGhpcy5hcHBlbmRJbWFnZSgpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRXJyb3IoKSkge1xyXG4gICAgICB0aGlzLmxvYWQoZmFsc2UsIHRydWUpOyAvLyB0cnkgdG8gcmVsb2FkXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGUuaG9sZGVyRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnNsaWRlLmhvbGRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVhY3RpdmF0ZSB0aGUgY29udGVudFxyXG4gICAqL1xyXG4gIGRlYWN0aXZhdGUoKSB7XHJcbiAgICB0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50RGVhY3RpdmF0ZScsIHsgY29udGVudDogdGhpcyB9KTtcclxuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMuc2xpZGUuaG9sZGVyRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnNsaWRlLmhvbGRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBjb250ZW50IGZyb20gRE9NXHJcbiAgICovXHJcbiAgcmVtb3ZlKCkge1xyXG4gICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRSZW1vdmUnLCB7IGNvbnRlbnQ6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIgJiYgdGhpcy5wbGFjZWhvbGRlci5lbGVtZW50KSB7XHJcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIuZWxlbWVudC5yZW1vdmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCB0aGUgaW1hZ2UgY29udGVudCB0byBzbGlkZSBjb250YWluZXJcclxuICAgKi9cclxuICBhcHBlbmRJbWFnZSgpIHtcclxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudEFwcGVuZEltYWdlJywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVuc3VyZSB0aGF0IGVsZW1lbnQgZXhpc3RzIGFuZCBpcyBub3QgYWxyZWFkeSBhcHBlbmRlZFxyXG4gICAgaWYgKHRoaXMuc2xpZGUgJiYgdGhpcy5lbGVtZW50ICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkxPQURFRCB8fCB0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkVSUk9SKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgIH1cclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29udGVudC5qcycpLmRlZmF1bHR9IENvbnRlbnQgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL2Jhc2UuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlQmFzZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuXHJcbmNvbnN0IE1JTl9TTElERVNfVE9fQ0FDSEUgPSA1O1xyXG5cclxuLyoqXHJcbiAqIExhenktbG9hZCBhbiBpbWFnZVxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBieSBMaWdodGJveCBhbmQgUGhvdG9Td2lwZSBjb3JlLFxyXG4gKiB0aHVzIGl0IGNhbiBiZSBjYWxsZWQgYmVmb3JlIGRpYWxvZyBpcyBvcGVuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBEYXRhIGFib3V0IHRoZSBzbGlkZVxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVCYXNlfSBpbnN0YW5jZSBQaG90b1N3aXBlIG9yIFBob3RvU3dpcGVMaWdodGJveCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICogQHJldHVybnMge0NvbnRlbnR9IEltYWdlIHRoYXQgaXMgYmVpbmcgZGVjb2RlZCBvciBmYWxzZS5cclxuICovXHJcbmZ1bmN0aW9uIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgaW5zdGFuY2UsIGluZGV4KSB7XHJcbiAgY29uc3QgY29udGVudCA9IGluc3RhbmNlLmNyZWF0ZUNvbnRlbnRGcm9tRGF0YShpdGVtRGF0YSwgaW5kZXgpO1xyXG4gIC8qKiBAdHlwZSB7Wm9vbUxldmVsIHwgdW5kZWZpbmVkfSAqL1xyXG4gIGxldCB6b29tTGV2ZWw7XHJcblxyXG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5zdGFuY2U7XHJcblxyXG4gIC8vIFdlIG5lZWQgdG8ga25vdyBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZSB0byBwcmVsb2FkIGl0LFxyXG4gIC8vIGFzIGl0IG1pZ2h0IHVzZSBzcmNzZXQsIGFuZCB3ZSBuZWVkIHRvIGRlZmluZSBzaXplc1xyXG4gIGlmIChvcHRpb25zKSB7XHJcbiAgICB6b29tTGV2ZWwgPSBuZXcgWm9vbUxldmVsKG9wdGlvbnMsIGl0ZW1EYXRhLCAtMSk7XHJcblxyXG4gICAgbGV0IHZpZXdwb3J0U2l6ZTtcclxuICAgIGlmIChpbnN0YW5jZS5wc3dwKSB7XHJcbiAgICAgIHZpZXdwb3J0U2l6ZSA9IGluc3RhbmNlLnBzd3Audmlld3BvcnRTaXplO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKG9wdGlvbnMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYW5BcmVhU2l6ZSA9IGdldFBhbkFyZWFTaXplKG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KTtcclxuICAgIHpvb21MZXZlbC51cGRhdGUoY29udGVudC53aWR0aCwgY29udGVudC5oZWlnaHQsIHBhbkFyZWFTaXplKTtcclxuICB9XHJcblxyXG4gIGNvbnRlbnQubGF6eUxvYWQoKTtcclxuXHJcbiAgaWYgKHpvb21MZXZlbCkge1xyXG4gICAgY29udGVudC5zZXREaXNwbGF5ZWRTaXplKFxyXG4gICAgICBNYXRoLmNlaWwoY29udGVudC53aWR0aCAqIHpvb21MZXZlbC5pbml0aWFsKSxcclxuICAgICAgTWF0aC5jZWlsKGNvbnRlbnQuaGVpZ2h0ICogem9vbUxldmVsLmluaXRpYWwpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnRlbnQ7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTGF6eS1sb2FkcyBzcGVjaWZpYyBzbGlkZS5cclxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggYnkgTGlnaHRib3ggYW5kIFBob3RvU3dpcGUgY29yZSxcclxuICogdGh1cyBpdCBjYW4gYmUgY2FsbGVkIGJlZm9yZSBkaWFsb2cgaXMgb3BlbmVkLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBpdCBsb2FkcyBpbWFnZSBiYXNlZCBvbiB2aWV3cG9ydCBzaXplIGFuZCBpbml0aWFsIHpvb20gbGV2ZWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBTbGlkZSBpbmRleFxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVCYXNlfSBpbnN0YW5jZSBQaG90b1N3aXBlIG9yIFBob3RvU3dpcGVMaWdodGJveCBldmVudGFibGUgaW5zdGFuY2VcclxuICogQHJldHVybnMge0NvbnRlbnQgfCB1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBsYXp5TG9hZFNsaWRlKGluZGV4LCBpbnN0YW5jZSkge1xyXG4gIGNvbnN0IGl0ZW1EYXRhID0gaW5zdGFuY2UuZ2V0SXRlbURhdGEoaW5kZXgpO1xyXG5cclxuICBpZiAoaW5zdGFuY2UuZGlzcGF0Y2goJ2xhenlMb2FkU2xpZGUnLCB7IGluZGV4LCBpdGVtRGF0YSB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGF6eUxvYWREYXRhKGl0ZW1EYXRhLCBpbnN0YW5jZSwgaW5kZXgpO1xyXG59XHJcblxyXG5jbGFzcyBDb250ZW50TG9hZGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XHJcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xyXG4gICAgLy8gVG90YWwgYW1vdW50IG9mIGNhY2hlZCBpbWFnZXNcclxuICAgIHRoaXMubGltaXQgPSBNYXRoLm1heChcclxuICAgICAgcHN3cC5vcHRpb25zLnByZWxvYWRbMF0gKyBwc3dwLm9wdGlvbnMucHJlbG9hZFsxXSArIDEsXHJcbiAgICAgIE1JTl9TTElERVNfVE9fQ0FDSEVcclxuICAgICk7XHJcbiAgICAvKiogQHR5cGUge0NvbnRlbnRbXX0gKi9cclxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMYXp5IGxvYWQgbmVhcmJ5IHNsaWRlcyBiYXNlZCBvbiBgcHJlbG9hZGAgb3B0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkaWZmXSBEaWZmZXJlbmNlIGJldHdlZW4gc2xpZGUgaW5kZXhlcyB0aGF0IHdhcyBjaGFuZ2VkIHJlY2VudGx5LCBvciAwLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUxhenkoZGlmZikge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmIChwc3dwLmRpc3BhdGNoKCdsYXp5TG9hZCcpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgcHJlbG9hZCB9ID0gcHN3cC5vcHRpb25zO1xyXG4gICAgY29uc3QgaXNGb3J3YXJkID0gZGlmZiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IChkaWZmID49IDApO1xyXG4gICAgbGV0IGk7XHJcblxyXG4gICAgLy8gcHJlbG9hZFsxXSAtIG51bSBpdGVtcyB0byBwcmVsb2FkIGluIGZvcndhcmQgZGlyZWN0aW9uXHJcbiAgICBmb3IgKGkgPSAwOyBpIDw9IHByZWxvYWRbMV07IGkrKykge1xyXG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gaSA6ICgtaSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcmVsb2FkWzBdIC0gbnVtIGl0ZW1zIHRvIHByZWxvYWQgaW4gYmFja3dhcmQgZGlyZWN0aW9uXHJcbiAgICBmb3IgKGkgPSAxOyBpIDw9IHByZWxvYWRbMF07IGkrKykge1xyXG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gKC1pKSA6IGkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsSW5kZXhcclxuICAgKi9cclxuICBsb2FkU2xpZGVCeUluZGV4KGluaXRpYWxJbmRleCkge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBzd3AuZ2V0TG9vcGVkSW5kZXgoaW5pdGlhbEluZGV4KTtcclxuICAgIC8vIHRyeSB0byBnZXQgY2FjaGVkIGNvbnRlbnRcclxuICAgIGxldCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50QnlJbmRleChpbmRleCk7XHJcbiAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgLy8gbm8gY2FjaGVkIGNvbnRlbnQsIHNvIHRyeSB0byBsb2FkIGZyb20gc2NyYXRjaDpcclxuICAgICAgY29udGVudCA9IGxhenlMb2FkU2xpZGUoaW5kZXgsIHRoaXMucHN3cCk7XHJcbiAgICAgIC8vIGlmIGNvbnRlbnQgY2FuIGJlIGxvYWRlZCwgYWRkIGl0IHRvIGNhY2hlOlxyXG4gICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgIHRoaXMuYWRkVG9DYWNoZShjb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTbGlkZX0gc2xpZGVcclxuICAgKiBAcmV0dXJucyB7Q29udGVudH1cclxuICAgKi9cclxuICBnZXRDb250ZW50QnlTbGlkZShzbGlkZSkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnRCeUluZGV4KHNsaWRlLmluZGV4KTtcclxuICAgIGlmICghY29udGVudCkge1xyXG4gICAgICAvLyBjcmVhdGUgY29udGVudCBpZiBub3QgZm91bmQgaW4gY2FjaGVcclxuICAgICAgY29udGVudCA9IHRoaXMucHN3cC5jcmVhdGVDb250ZW50RnJvbURhdGEoc2xpZGUuZGF0YSwgc2xpZGUuaW5kZXgpO1xyXG4gICAgICB0aGlzLmFkZFRvQ2FjaGUoY29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXNzaWduIHNsaWRlIHRvIGNvbnRlbnRcclxuICAgIGNvbnRlbnQuc2V0U2xpZGUoc2xpZGUpO1xyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtDb250ZW50fSBjb250ZW50XHJcbiAgICovXHJcbiAgYWRkVG9DYWNoZShjb250ZW50KSB7XHJcbiAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYXJyYXlcclxuICAgIHRoaXMucmVtb3ZlQnlJbmRleChjb250ZW50LmluZGV4KTtcclxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zLnB1c2goY29udGVudCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2NhY2hlZEl0ZW1zLmxlbmd0aCA+IHRoaXMubGltaXQpIHtcclxuICAgICAgLy8gRGVzdHJveSB0aGUgZmlyc3QgY29udGVudCB0aGF0J3Mgbm90IGF0dGFjaGVkXHJcbiAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSB0aGlzLl9jYWNoZWRJdGVtcy5maW5kSW5kZXgoKGl0ZW0pID0+IHtcclxuICAgICAgICByZXR1cm4gIWl0ZW0uaXNBdHRhY2hlZCAmJiAhaXRlbS5oYXNTbGlkZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChpbmRleFRvUmVtb3ZlICE9PSAtMSkge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRJdGVtID0gdGhpcy5fY2FjaGVkSXRlbXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpWzBdO1xyXG4gICAgICAgIHJlbW92ZWRJdGVtLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbiBpbWFnZSBmcm9tIGNhY2hlLCBkb2VzIG5vdCBkZXN0cm95KCkgaXQsIGp1c3QgcmVtb3Zlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIHJlbW92ZUJ5SW5kZXgoaW5kZXgpIHtcclxuICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSB0aGlzLl9jYWNoZWRJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmluZGV4ID09PSBpbmRleCk7XHJcbiAgICBpZiAoaW5kZXhUb1JlbW92ZSAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5fY2FjaGVkSXRlbXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICogQHJldHVybnMge0NvbnRlbnQgfCB1bmRlZmluZWR9XHJcbiAgICovXHJcbiAgZ2V0Q29udGVudEJ5SW5kZXgoaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJdGVtcy5maW5kKGNvbnRlbnQgPT4gY29udGVudC5pbmRleCA9PT0gaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zLmZvckVhY2goY29udGVudCA9PiBjb250ZW50LmRlc3Ryb3koKSk7XHJcbiAgICB0aGlzLl9jYWNoZWRJdGVtcyA9IFtdO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL3Bob3Rvc3dpcGUuanNcIikuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL3NsaWRlL3NsaWRlLmpzXCIpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcblxyXG4vKipcclxuICogUGhvdG9Td2lwZSBiYXNlIGNsYXNzIHRoYXQgY2FuIHJldHJpZXZlIGRhdGEgYWJvdXQgZXZlcnkgc2xpZGUuXHJcbiAqIFNoYXJlZCBieSBQaG90b1N3aXBlIENvcmUgYW5kIFBob3RvU3dpcGUgTGlnaHRib3hcclxuICovXHJcbmNsYXNzIFBob3RvU3dpcGVCYXNlIGV4dGVuZHMgRXZlbnRhYmxlIHtcclxuICAvKipcclxuICAgKiBHZXQgdG90YWwgbnVtYmVyIG9mIHNsaWRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXROdW1JdGVtcygpIHtcclxuICAgIGxldCBudW1JdGVtcyA9IDA7XHJcbiAgICBjb25zdCBkYXRhU291cmNlID0gdGhpcy5vcHRpb25zPy5kYXRhU291cmNlO1xyXG5cclxuICAgIGlmIChkYXRhU291cmNlICYmICdsZW5ndGgnIGluIGRhdGFTb3VyY2UpIHtcclxuICAgICAgLy8gbWF5IGJlIGFuIGFycmF5IG9yIGp1c3Qgb2JqZWN0IHdpdGggbGVuZ3RoIHByb3BlcnR5XHJcbiAgICAgIG51bUl0ZW1zID0gZGF0YVNvdXJjZS5sZW5ndGg7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFTb3VyY2UgJiYgJ2dhbGxlcnknIGluIGRhdGFTb3VyY2UpIHtcclxuICAgICAgLy8gcXVlcnkgRE9NIGVsZW1lbnRzXHJcbiAgICAgIGlmICghZGF0YVNvdXJjZS5pdGVtcykge1xyXG4gICAgICAgIGRhdGFTb3VyY2UuaXRlbXMgPSB0aGlzLl9nZXRHYWxsZXJ5RE9NRWxlbWVudHMoZGF0YVNvdXJjZS5nYWxsZXJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRhdGFTb3VyY2UuaXRlbXMpIHtcclxuICAgICAgICBudW1JdGVtcyA9IGRhdGFTb3VyY2UuaXRlbXMubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbGVnYWN5IGV2ZW50LCBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5kaXNwYXRjaCgnbnVtSXRlbXMnLCB7XHJcbiAgICAgIGRhdGFTb3VyY2UsXHJcbiAgICAgIG51bUl0ZW1zXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnbnVtSXRlbXMnLCBldmVudC5udW1JdGVtcywgZGF0YVNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gc2xpZGVEYXRhXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICogQHJldHVybnMge0NvbnRlbnR9XHJcbiAgICovXHJcbiAgY3JlYXRlQ29udGVudEZyb21EYXRhKHNsaWRlRGF0YSwgaW5kZXgpIHtcclxuICAgIHJldHVybiBuZXcgQ29udGVudChzbGlkZURhdGEsIHRoaXMsIGluZGV4KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBpdGVtIGRhdGEgYnkgaW5kZXguXHJcbiAgICpcclxuICAgKiBcIml0ZW0gZGF0YVwiIHNob3VsZCBjb250YWluIG5vcm1hbGl6ZWQgaW5mb3JtYXRpb24gdGhhdCBQaG90b1N3aXBlIG5lZWRzIHRvIGdlbmVyYXRlIGEgc2xpZGUuXHJcbiAgICogRm9yIGV4YW1wbGUsIGl0IG1heSBjb250YWluIHByb3BlcnRpZXMgbGlrZVxyXG4gICAqIGBzcmNgLCBgc3Jjc2V0YCwgYHdgLCBgaGAsIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBhIHNsaWRlIHdpdGggaW1hZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJucyB7U2xpZGVEYXRhfVxyXG4gICAqL1xyXG4gIGdldEl0ZW1EYXRhKGluZGV4KSB7XHJcbiAgICBjb25zdCBkYXRhU291cmNlID0gdGhpcy5vcHRpb25zPy5kYXRhU291cmNlO1xyXG4gICAgLyoqIEB0eXBlIHtTbGlkZURhdGEgfCBIVE1MRWxlbWVudH0gKi9cclxuICAgIGxldCBkYXRhU291cmNlSXRlbSA9IHt9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVNvdXJjZSkpIHtcclxuICAgICAgLy8gRGF0YXNvdXJjZSBpcyBhbiBhcnJheSBvZiBlbGVtZW50c1xyXG4gICAgICBkYXRhU291cmNlSXRlbSA9IGRhdGFTb3VyY2VbaW5kZXhdO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhU291cmNlICYmICdnYWxsZXJ5JyBpbiBkYXRhU291cmNlKSB7XHJcbiAgICAgIC8vIGRhdGFTb3VyY2UgaGFzIGdhbGxlcnkgcHJvcGVydHksXHJcbiAgICAgIC8vIHRodXMgaXQgd2FzIGNyZWF0ZWQgYnkgTGlnaHRib3gsIGJhc2VkIG9uXHJcbiAgICAgIC8vIGdhbGxlcnkgYW5kIGNoaWxkcmVuIG9wdGlvbnNcclxuXHJcbiAgICAgIC8vIHF1ZXJ5IERPTSBlbGVtZW50c1xyXG4gICAgICBpZiAoIWRhdGFTb3VyY2UuaXRlbXMpIHtcclxuICAgICAgICBkYXRhU291cmNlLml0ZW1zID0gdGhpcy5fZ2V0R2FsbGVyeURPTUVsZW1lbnRzKGRhdGFTb3VyY2UuZ2FsbGVyeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRhdGFTb3VyY2VJdGVtID0gZGF0YVNvdXJjZS5pdGVtc1tpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGl0ZW1EYXRhID0gZGF0YVNvdXJjZUl0ZW07XHJcblxyXG4gICAgaWYgKGl0ZW1EYXRhIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICBpdGVtRGF0YSA9IHRoaXMuX2RvbUVsZW1lbnRUb0l0ZW1EYXRhKGl0ZW1EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaGluZyB0aGUgaXRlbURhdGEgZXZlbnQsXHJcbiAgICAvLyBpdCdzIGEgbGVnYWN5IHZlcmlvbiBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5kaXNwYXRjaCgnaXRlbURhdGEnLCB7XHJcbiAgICAgIGl0ZW1EYXRhOiBpdGVtRGF0YSB8fCB7fSxcclxuICAgICAgaW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnaXRlbURhdGEnLCBldmVudC5pdGVtRGF0YSwgaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFycmF5IG9mIGdhbGxlcnkgRE9NIGVsZW1lbnRzLFxyXG4gICAqIGJhc2VkIG9uIGNoaWxkU2VsZWN0b3IgYW5kIGdhbGxlcnkgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGdhbGxlcnlFbGVtZW50XHJcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgX2dldEdhbGxlcnlET01FbGVtZW50cyhnYWxsZXJ5RWxlbWVudCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucz8uY2hpbGRyZW4gfHwgdGhpcy5vcHRpb25zPy5jaGlsZFNlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0Zyb21PcHRpb24oXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmNoaWxkcmVuLFxyXG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGlsZFNlbGVjdG9yLFxyXG4gICAgICAgIGdhbGxlcnlFbGVtZW50XHJcbiAgICAgICkgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtnYWxsZXJ5RWxlbWVudF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBET00gZWxlbWVudCB0byBpdGVtIGRhdGEgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBET00gZWxlbWVudFxyXG4gICAqIEByZXR1cm5zIHtTbGlkZURhdGF9XHJcbiAgICovXHJcbiAgX2RvbUVsZW1lbnRUb0l0ZW1EYXRhKGVsZW1lbnQpIHtcclxuICAgIC8qKiBAdHlwZSB7U2xpZGVEYXRhfSAqL1xyXG4gICAgY29uc3QgaXRlbURhdGEgPSB7XHJcbiAgICAgIGVsZW1lbnRcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbGlua0VsID0gLyoqIEB0eXBlIHtIVE1MQW5jaG9yRWxlbWVudH0gKi8gKFxyXG4gICAgICBlbGVtZW50LnRhZ05hbWUgPT09ICdBJ1xyXG4gICAgICAgID8gZWxlbWVudFxyXG4gICAgICAgIDogZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhJylcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGxpbmtFbCkge1xyXG4gICAgICAvLyBzcmMgY29tZXMgZnJvbSBkYXRhLXBzd3Atc3JjIGF0dHJpYnV0ZSxcclxuICAgICAgLy8gaWYgaXQncyBlbXB0eSBsaW5rIGhyZWYgaXMgdXNlZFxyXG4gICAgICBpdGVtRGF0YS5zcmMgPSBsaW5rRWwuZGF0YXNldC5wc3dwU3JjIHx8IGxpbmtFbC5ocmVmO1xyXG5cclxuICAgICAgaWYgKGxpbmtFbC5kYXRhc2V0LnBzd3BTcmNzZXQpIHtcclxuICAgICAgICBpdGVtRGF0YS5zcmNzZXQgPSBsaW5rRWwuZGF0YXNldC5wc3dwU3Jjc2V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVtRGF0YS53aWR0aCA9IGxpbmtFbC5kYXRhc2V0LnBzd3BXaWR0aCA/IHBhcnNlSW50KGxpbmtFbC5kYXRhc2V0LnBzd3BXaWR0aCwgMTApIDogMDtcclxuICAgICAgaXRlbURhdGEuaGVpZ2h0ID0gbGlua0VsLmRhdGFzZXQucHN3cEhlaWdodCA/IHBhcnNlSW50KGxpbmtFbC5kYXRhc2V0LnBzd3BIZWlnaHQsIDEwKSA6IDA7XHJcblxyXG4gICAgICAvLyBzdXBwb3J0IGxlZ2FjeSB3ICYgaCBwcm9wZXJ0aWVzXHJcbiAgICAgIGl0ZW1EYXRhLncgPSBpdGVtRGF0YS53aWR0aDtcclxuICAgICAgaXRlbURhdGEuaCA9IGl0ZW1EYXRhLmhlaWdodDtcclxuXHJcbiAgICAgIGlmIChsaW5rRWwuZGF0YXNldC5wc3dwVHlwZSkge1xyXG4gICAgICAgIGl0ZW1EYXRhLnR5cGUgPSBsaW5rRWwuZGF0YXNldC5wc3dwVHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdGh1bWJuYWlsRWwgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG5cclxuICAgICAgaWYgKHRodW1ibmFpbEVsKSB7XHJcbiAgICAgICAgLy8gbXNyYyBpcyBVUkwgdG8gcGxhY2Vob2xkZXIgaW1hZ2UgdGhhdCdzIGRpc3BsYXllZCBiZWZvcmUgbGFyZ2UgaW1hZ2UgaXMgbG9hZGVkXHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBpdCdzIGRpc3BsYXllZCBvbmx5IGZvciB0aGUgZmlyc3Qgc2xpZGVcclxuICAgICAgICBpdGVtRGF0YS5tc3JjID0gdGh1bWJuYWlsRWwuY3VycmVudFNyYyB8fCB0aHVtYm5haWxFbC5zcmM7XHJcbiAgICAgICAgaXRlbURhdGEuYWx0ID0gdGh1bWJuYWlsRWwuZ2V0QXR0cmlidXRlKCdhbHQnKSA/PyAnJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxpbmtFbC5kYXRhc2V0LnBzd3BDcm9wcGVkIHx8IGxpbmtFbC5kYXRhc2V0LmNyb3BwZWQpIHtcclxuICAgICAgICBpdGVtRGF0YS50aHVtYkNyb3BwZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlGaWx0ZXJzKCdkb21JdGVtRGF0YScsIGl0ZW1EYXRhLCBlbGVtZW50LCBsaW5rRWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGF6eS1sb2FkIGJ5IHNsaWRlIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBEYXRhIGFib3V0IHRoZSBzbGlkZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtDb250ZW50fSBJbWFnZSB0aGF0IGlzIGJlaW5nIGRlY29kZWQgb3IgZmFsc2UuXHJcbiAgICovXHJcbiAgbGF6eUxvYWREYXRhKGl0ZW1EYXRhLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgdGhpcywgaW5kZXgpO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9nZXQtdGh1bWItYm91bmRzLmpzJykuQm91bmRzfSBCb3VuZHMgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbC9hbmltYXRpb25zLmpzJykuQW5pbWF0aW9uUHJvcHN9IEFuaW1hdGlvblByb3BzICovXHJcblxyXG4vLyBzb21lIGJyb3dzZXJzIGRvIG5vdCBwYWludFxyXG4vLyBlbGVtZW50cyB3aGljaCBvcGFjaXR5IGlzIHNldCB0byAwLFxyXG4vLyBzaW5jZSB3ZSBuZWVkIHRvIHByZS1yZW5kZXIgZWxlbWVudHMgZm9yIHRoZSBhbmltYXRpb24gLVxyXG4vLyB3ZSBzZXQgaXQgdG8gdGhlIG1pbmltdW0gYW1vdW50XHJcbmNvbnN0IE1JTl9PUEFDSVRZID0gMC4wMDM7XHJcblxyXG4vKipcclxuICogTWFuYWdlcyBvcGVuaW5nIGFuZCBjbG9zaW5nIHRyYW5zaXRpb25zIG9mIHRoZSBQaG90b1N3aXBlLlxyXG4gKlxyXG4gKiBJdCBjYW4gcGVyZm9ybSB6b29tLCBmYWRlIG9yIG5vIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jbGFzcyBPcGVuZXIge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXIgfCBmYWxzZSB8IHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZHVyYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3VzZUFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9jcm9wcGVkWm9vbSA9IGZhbHNlO1xyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSBmYWxzZTtcclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fYW5pbWF0ZUJnT3BhY2l0eSA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUgeyBIVE1MRGl2RWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkIH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fcGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fb3BhY2l0eUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY3JvcENvbnRhaW5lcjEgPSB1bmRlZmluZWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7IEhUTUxFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZCB9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2Nyb3BDb250YWluZXIyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtCb3VuZHMgfCB1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3RodW1iQm91bmRzID0gdW5kZWZpbmVkO1xyXG5cclxuXHJcbiAgICB0aGlzLl9wcmVwYXJlT3BlbiA9IHRoaXMuX3ByZXBhcmVPcGVuLmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy8gT3ZlcnJpZGUgaW5pdGlhbCB6b29tIGFuZCBwYW4gcG9zaXRpb25cclxuICAgIHBzd3Aub24oJ2ZpcnN0Wm9vbVBhbicsIHRoaXMuX3ByZXBhcmVPcGVuKTtcclxuICB9XHJcblxyXG4gIG9wZW4oKSB7XHJcbiAgICB0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG4gICAgdGhpcy5fc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNsb3NlKCkge1xyXG4gICAgaWYgKHRoaXMuaXNDbG9zZWQgfHwgdGhpcy5pc0Nsb3NpbmcgfHwgdGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgLy8gaWYgd2UgY2xvc2UgZHVyaW5nIG9wZW5pbmcgYW5pbWF0aW9uXHJcbiAgICAgIC8vIGZvciBub3cgZG8gbm90aGluZyxcclxuICAgICAgLy8gYnJvd3NlcnMgYXJlbid0IGdvb2QgYXQgY2hhbmdpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgQ1NTIHRyYW5zaXRpb25cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuXHJcbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5wc3dwLm9wdGlvbnMuaGlkZUFuaW1hdGlvbkR1cmF0aW9uO1xyXG5cclxuICAgIGlmIChzbGlkZSAmJiBzbGlkZS5jdXJyWm9vbUxldmVsICogc2xpZGUud2lkdGggPj0gdGhpcy5wc3dwLm9wdGlvbnMubWF4V2lkdGhUb0FuaW1hdGUpIHtcclxuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2FwcGx5U3RhcnRQcm9wcygpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICB9LCB0aGlzLl9jcm9wcGVkWm9vbSA/IDMwIDogMCk7XHJcbiAgfVxyXG5cclxuICAvKiogQHByaXZhdGUgKi9cclxuICBfcHJlcGFyZU9wZW4oKSB7XHJcbiAgICB0aGlzLnBzd3Aub2ZmKCdmaXJzdFpvb21QYW4nLCB0aGlzLl9wcmVwYXJlT3Blbik7XHJcbiAgICBpZiAoIXRoaXMuaXNPcGVuaW5nKSB7XHJcbiAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuICAgICAgdGhpcy5pc09wZW5pbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMucHN3cC5vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbjtcclxuICAgICAgaWYgKHNsaWRlICYmIHNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCAqIHNsaWRlLndpZHRoID49IHRoaXMucHN3cC5vcHRpb25zLm1heFdpZHRoVG9BbmltYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2FwcGx5U3RhcnRQcm9wcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBwcml2YXRlICovXHJcbiAgX2FwcGx5U3RhcnRQcm9wcygpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcHN3cDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5zaG93SGlkZUFuaW1hdGlvblR5cGUgPT09ICdmYWRlJykge1xyXG4gICAgICBvcHRpb25zLnNob3dIaWRlT3BhY2l0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3RodW1iQm91bmRzID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNob3dIaWRlQW5pbWF0aW9uVHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgIG9wdGlvbnMuc2hvd0hpZGVPcGFjaXR5ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcclxuICAgICAgdGhpcy5fdGh1bWJCb3VuZHMgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuaW5nICYmIHBzd3AuX2luaXRpYWxUaHVtYkJvdW5kcykge1xyXG4gICAgICAvLyBVc2UgaW5pdGlhbCBib3VuZHMgaWYgZGVmaW5lZFxyXG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IHBzd3AuX2luaXRpYWxUaHVtYkJvdW5kcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3RodW1iQm91bmRzID0gdGhpcy5wc3dwLmdldFRodW1iQm91bmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBzbGlkZT8uZ2V0UGxhY2Vob2xkZXJFbGVtZW50KCk7XHJcblxyXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGwoKTtcclxuXHJcbiAgICAvLyBEaXNjYXJkIGFuaW1hdGlvbnMgd2hlbiBkdXJhdGlvbiBpcyBsZXNzIHRoYW4gNTBtc1xyXG4gICAgdGhpcy5fdXNlQW5pbWF0aW9uID0gQm9vbGVhbih0aGlzLl9kdXJhdGlvbiAmJiB0aGlzLl9kdXJhdGlvbiA+IDUwKTtcclxuICAgIHRoaXMuX2FuaW1hdGVab29tID0gQm9vbGVhbih0aGlzLl90aHVtYkJvdW5kcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2xpZGU/LmNvbnRlbnQudXNlUGxhY2Vob2xkZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoIXRoaXMuaXNDbG9zaW5nIHx8ICFwc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKCkpO1xyXG4gICAgaWYgKCF0aGlzLl9hbmltYXRlWm9vbSkge1xyXG4gICAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaXNPcGVuaW5nICYmIHNsaWRlKSB7XHJcbiAgICAgICAgc2xpZGUuem9vbUFuZFBhblRvSW5pdGlhbCgpO1xyXG4gICAgICAgIHNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5ID0gb3B0aW9ucy5zaG93SGlkZU9wYWNpdHkgPz8gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9hbmltYXRlQmdPcGFjaXR5ID0gIXRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSAmJiB0aGlzLnBzd3Aub3B0aW9ucy5iZ09wYWNpdHkgPiBNSU5fT1BBQ0lUWTtcclxuICAgIHRoaXMuX29wYWNpdHlFbGVtZW50ID0gdGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5ID8gcHN3cC5lbGVtZW50IDogcHN3cC5iZztcclxuXHJcbiAgICBpZiAoIXRoaXMuX3VzZUFuaW1hdGlvbikge1xyXG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVab29tID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5ID0gdHJ1ZTtcclxuICAgICAgaWYgKHRoaXMuaXNPcGVuaW5nKSB7XHJcbiAgICAgICAgaWYgKHBzd3AuZWxlbWVudCkge1xyXG4gICAgICAgICAgcHN3cC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcoTUlOX09QQUNJVFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVpvb20gJiYgdGhpcy5fdGh1bWJCb3VuZHMgJiYgdGhpcy5fdGh1bWJCb3VuZHMuaW5uZXJSZWN0KSB7XHJcbiAgICAgIC8vIFByb3BlcnRpZXMgYXJlIHVzZWQgd2hlbiBhbmltYXRpb24gZnJvbSBjcm9wcGVkIHRodW1ibmFpbFxyXG4gICAgICB0aGlzLl9jcm9wcGVkWm9vbSA9IHRydWU7XHJcbiAgICAgIHRoaXMuX2Nyb3BDb250YWluZXIxID0gdGhpcy5wc3dwLmNvbnRhaW5lcjtcclxuICAgICAgdGhpcy5fY3JvcENvbnRhaW5lcjIgPSB0aGlzLnBzd3AuY3VyclNsaWRlPy5ob2xkZXJFbGVtZW50O1xyXG5cclxuICAgICAgaWYgKHBzd3AuY29udGFpbmVyKSB7XHJcbiAgICAgICAgcHN3cC5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICBwc3dwLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHBzd3Audmlld3BvcnRTaXplLnggKyAncHgnO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9jcm9wcGVkWm9vbSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzT3BlbmluZykge1xyXG4gICAgICAvLyBBcHBseSBzdHlsZXMgYmVmb3JlIG9wZW5pbmcgdHJhbnNpdGlvblxyXG4gICAgICBpZiAodGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKHBzd3AuZWxlbWVudCkge1xyXG4gICAgICAgICAgcHN3cC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcoTUlOX09QQUNJVFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRlQmdPcGFjaXR5ICYmIHBzd3AuYmcpIHtcclxuICAgICAgICAgIHBzd3AuYmcuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwc3dwLmVsZW1lbnQpIHtcclxuICAgICAgICAgIHBzd3AuZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2FuaW1hdGVab29tKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0Q2xvc2VkU3RhdGVab29tUGFuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAvLyB0ZWxsIGJyb3dzZXIgdGhhdCB3ZSBwbGFuIHRvIGFuaW1hdGUgdGhlIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XHJcblxyXG4gICAgICAgICAgLy8gaGlkZSBwbGFjZWhvbGRlciB0byBhbGxvdyBoaWRpbmcgb2ZcclxuICAgICAgICAgIC8vIGVsZW1lbnRzIHRoYXQgb3ZlcmxhcCBpdCAoc3VjaCBhcyBpY29ucyBvdmVyIHRoZSB0aHVtYm5haWwpXHJcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKE1JTl9PUEFDSVRZKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0Nsb3NpbmcpIHtcclxuICAgICAgLy8gaGlkZSBuZWFyYnkgc2xpZGVzIHRvIG1ha2Ugc3VyZSB0aGF0XHJcbiAgICAgIC8vIHRoZXkgYXJlIG5vdCBwYWludGVkIGR1cmluZyB0aGUgdHJhbnNpdGlvblxyXG4gICAgICBpZiAocHN3cC5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzBdKSB7XHJcbiAgICAgICAgcHN3cC5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBzd3AubWFpblNjcm9sbC5pdGVtSG9sZGVyc1syXSkge1xyXG4gICAgICAgIHBzd3AubWFpblNjcm9sbC5pdGVtSG9sZGVyc1syXS5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fY3JvcHBlZFpvb20pIHtcclxuICAgICAgICBpZiAocHN3cC5tYWluU2Nyb2xsLnggIT09IDApIHtcclxuICAgICAgICAgIC8vIHNoaWZ0IHRoZSBtYWluIHNjcm9sbGVyIHRvIHplcm8gcG9zaXRpb25cclxuICAgICAgICAgIHBzd3AubWFpblNjcm9sbC5yZXNldFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICBwc3dwLm1haW5TY3JvbGwucmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQHByaXZhdGUgKi9cclxuICBfc3RhcnQoKSB7XHJcbiAgICBpZiAodGhpcy5pc09wZW5pbmdcclxuICAgICAgICAmJiB0aGlzLl91c2VBbmltYXRpb25cclxuICAgICAgICAmJiB0aGlzLl9wbGFjZWhvbGRlclxyXG4gICAgICAgICYmIHRoaXMuX3BsYWNlaG9sZGVyLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgICAgIC8vIFRvIGVuc3VyZSBzbW9vdGggYW5pbWF0aW9uXHJcbiAgICAgIC8vIHdlIHdhaXQgdGlsbCB0aGUgY3VycmVudCBzbGlkZSBpbWFnZSBwbGFjZWhvbGRlciBpcyBkZWNvZGVkLFxyXG4gICAgICAvLyBidXQgbm8gbG9uZ2VyIHRoYW4gMjUwbXMsXHJcbiAgICAgIC8vIGFuZCBubyBzaG9ydGVyIHRoYW4gNTBtc1xyXG4gICAgICAvLyAoanVzdCB1c2luZyByZXF1ZXN0YW5pbWF0aW9uZnJhbWUgaXMgbm90IGVub3VnaCBpbiBGaXJlZm94LFxyXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24pXHJcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgbGV0IGRlY29kZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaXNEZWxheWluZyA9IHRydWU7XHJcbiAgICAgICAgZGVjb2RlSW1hZ2UoLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5fcGxhY2Vob2xkZXIpKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgIGRlY29kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKCFpc0RlbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpc0RlbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoZGVjb2RlZCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDUwKTtcclxuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDI1MCk7XHJcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy5faW5pdGlhdGUoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9pbml0aWF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBwcml2YXRlICovXHJcbiAgX2luaXRpYXRlKCkge1xyXG4gICAgdGhpcy5wc3dwLmVsZW1lbnQ/LnN0eWxlLnNldFByb3BlcnR5KCctLXBzd3AtdHJhbnNpdGlvbi1kdXJhdGlvbicsIHRoaXMuX2R1cmF0aW9uICsgJ21zJyk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKFxyXG4gICAgICB0aGlzLmlzT3BlbmluZyA/ICdvcGVuaW5nQW5pbWF0aW9uU3RhcnQnIDogJ2Nsb3NpbmdBbmltYXRpb25TdGFydCdcclxuICAgICk7XHJcblxyXG4gICAgLy8gbGVnYWN5IGV2ZW50XHJcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goXHJcbiAgICAgIC8qKiBAdHlwZSB7J2luaXRpYWxab29tSW4nIHwgJ2luaXRpYWxab29tT3V0J30gKi9cclxuICAgICAgKCdpbml0aWFsWm9vbScgKyAodGhpcy5pc09wZW5pbmcgPyAnSW4nIDogJ091dCcpKVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnBzd3AuZWxlbWVudD8uY2xhc3NMaXN0LnRvZ2dsZSgncHN3cC0tdWktdmlzaWJsZScsIHRoaXMuaXNPcGVuaW5nKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgLy8gdW5oaWRlIHRoZSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvT3BlblN0YXRlKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbG9zaW5nKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVUb0Nsb3NlZFN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl91c2VBbmltYXRpb24pIHtcclxuICAgICAgdGhpcy5fb25BbmltYXRpb25Db21wbGV0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBwcml2YXRlICovXHJcbiAgX29uQW5pbWF0aW9uQ29tcGxldGUoKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICB0aGlzLmlzT3BlbiA9IHRoaXMuaXNPcGVuaW5nO1xyXG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRoaXMuaXNDbG9zaW5nO1xyXG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaChcclxuICAgICAgdGhpcy5pc09wZW4gPyAnb3BlbmluZ0FuaW1hdGlvbkVuZCcgOiAnY2xvc2luZ0FuaW1hdGlvbkVuZCdcclxuICAgICk7XHJcblxyXG4gICAgLy8gbGVnYWN5IGV2ZW50XHJcbiAgICBwc3dwLmRpc3BhdGNoKFxyXG4gICAgICAvKiogQHR5cGUgeydpbml0aWFsWm9vbUluRW5kJyB8ICdpbml0aWFsWm9vbU91dEVuZCd9ICovXHJcbiAgICAgICgnaW5pdGlhbFpvb20nICsgKHRoaXMuaXNPcGVuID8gJ0luRW5kJyA6ICdPdXRFbmQnKSlcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcclxuICAgICAgcHN3cC5kZXN0cm95KCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuKSB7XHJcbiAgICAgIGlmICh0aGlzLl9hbmltYXRlWm9vbSAmJiBwc3dwLmNvbnRhaW5lcikge1xyXG4gICAgICAgIHBzd3AuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xyXG4gICAgICAgIHBzd3AuY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICB9XHJcbiAgICAgIHBzd3AuY3VyclNsaWRlPy5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQHByaXZhdGUgKi9cclxuICBfYW5pbWF0ZVRvT3BlblN0YXRlKCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVab29tKSB7XHJcbiAgICAgIGlmICh0aGlzLl9jcm9wcGVkWm9vbSAmJiB0aGlzLl9jcm9wQ29udGFpbmVyMSAmJiB0aGlzLl9jcm9wQ29udGFpbmVyMikge1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyh0aGlzLl9jcm9wQ29udGFpbmVyMSwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRlVG8odGhpcy5fY3JvcENvbnRhaW5lcjIsICd0cmFuc2Zvcm0nLCAnbm9uZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHN3cC5jdXJyU2xpZGUpIHtcclxuICAgICAgICBwc3dwLmN1cnJTbGlkZS56b29tQW5kUGFuVG9Jbml0aWFsKCk7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKFxyXG4gICAgICAgICAgcHN3cC5jdXJyU2xpZGUuY29udGFpbmVyLFxyXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICBwc3dwLmN1cnJTbGlkZS5nZXRDdXJyZW50VHJhbnNmb3JtKClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgJiYgcHN3cC5iZykge1xyXG4gICAgICB0aGlzLl9hbmltYXRlVG8ocHN3cC5iZywgJ29wYWNpdHknLCBTdHJpbmcocHN3cC5vcHRpb25zLmJnT3BhY2l0eSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgJiYgcHN3cC5lbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVUbyhwc3dwLmVsZW1lbnQsICdvcGFjaXR5JywgJzEnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAcHJpdmF0ZSAqL1xyXG4gIF9hbmltYXRlVG9DbG9zZWRTdGF0ZSgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuXHJcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVpvb20pIHtcclxuICAgICAgdGhpcy5fc2V0Q2xvc2VkU3RhdGVab29tUGFuKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIG5vdCBhbmltYXRlIG9wYWNpdHkgaWYgaXQncyBhbHJlYWR5IGF0IDBcclxuICAgIGlmICh0aGlzLl9hbmltYXRlQmdPcGFjaXR5ICYmIHBzd3AuYmdPcGFjaXR5ID4gMC4wMSAmJiBwc3dwLmJnKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVUbyhwc3dwLmJnLCAnb3BhY2l0eScsICcwJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSAmJiBwc3dwLmVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuZWxlbWVudCwgJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbmltYXRlXVxyXG4gICAqL1xyXG4gIF9zZXRDbG9zZWRTdGF0ZVpvb21QYW4oYW5pbWF0ZSkge1xyXG4gICAgaWYgKCF0aGlzLl90aHVtYkJvdW5kcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgaW5uZXJSZWN0IH0gPSB0aGlzLl90aHVtYkJvdW5kcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlLCB2aWV3cG9ydFNpemUgfSA9IHBzd3A7XHJcblxyXG4gICAgaWYgKHRoaXMuX2Nyb3BwZWRab29tICYmIGlubmVyUmVjdCAmJiB0aGlzLl9jcm9wQ29udGFpbmVyMSAmJiB0aGlzLl9jcm9wQ29udGFpbmVyMikge1xyXG4gICAgICBjb25zdCBjb250YWluZXJPbmVQYW5YID0gLXZpZXdwb3J0U2l6ZS54ICsgKHRoaXMuX3RodW1iQm91bmRzLnggLSBpbm5lclJlY3QueCkgKyBpbm5lclJlY3QudztcclxuICAgICAgY29uc3QgY29udGFpbmVyT25lUGFuWSA9IC12aWV3cG9ydFNpemUueSArICh0aGlzLl90aHVtYkJvdW5kcy55IC0gaW5uZXJSZWN0LnkpICsgaW5uZXJSZWN0Lmg7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclR3b1BhblggPSB2aWV3cG9ydFNpemUueCAtIGlubmVyUmVjdC53O1xyXG4gICAgICBjb25zdCBjb250YWluZXJUd29QYW5ZID0gdmlld3BvcnRTaXplLnkgLSBpbm5lclJlY3QuaDtcclxuXHJcblxyXG4gICAgICBpZiAoYW5pbWF0ZSkge1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyhcclxuICAgICAgICAgIHRoaXMuX2Nyb3BDb250YWluZXIxLFxyXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICB0b1RyYW5zZm9ybVN0cmluZyhjb250YWluZXJPbmVQYW5YLCBjb250YWluZXJPbmVQYW5ZKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyhcclxuICAgICAgICAgIHRoaXMuX2Nyb3BDb250YWluZXIyLFxyXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICB0b1RyYW5zZm9ybVN0cmluZyhjb250YWluZXJUd29QYW5YLCBjb250YWluZXJUd29QYW5ZKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0VHJhbnNmb3JtKHRoaXMuX2Nyb3BDb250YWluZXIxLCBjb250YWluZXJPbmVQYW5YLCBjb250YWluZXJPbmVQYW5ZKTtcclxuICAgICAgICBzZXRUcmFuc2Zvcm0odGhpcy5fY3JvcENvbnRhaW5lcjIsIGNvbnRhaW5lclR3b1BhblgsIGNvbnRhaW5lclR3b1BhblkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJTbGlkZSkge1xyXG4gICAgICBlcXVhbGl6ZVBvaW50cyhjdXJyU2xpZGUucGFuLCBpbm5lclJlY3QgfHwgdGhpcy5fdGh1bWJCb3VuZHMpO1xyXG4gICAgICBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA9IHRoaXMuX3RodW1iQm91bmRzLncgLyBjdXJyU2xpZGUud2lkdGg7XHJcbiAgICAgIGlmIChhbmltYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKGN1cnJTbGlkZS5jb250YWluZXIsICd0cmFuc2Zvcm0nLCBjdXJyU2xpZGUuZ2V0Q3VycmVudFRyYW5zZm9ybSgpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7J3RyYW5zZm9ybScgfCAnb3BhY2l0eSd9IHByb3BcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFZhbHVlXHJcbiAgICovXHJcbiAgX2FuaW1hdGVUbyh0YXJnZXQsIHByb3AsIHByb3BWYWx1ZSkge1xyXG4gICAgaWYgKCF0aGlzLl9kdXJhdGlvbikge1xyXG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBwcm9wVmFsdWU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGFuaW1hdGlvbnMgfSA9IHRoaXMucHN3cDtcclxuICAgIC8qKiBAdHlwZSB7QW5pbWF0aW9uUHJvcHN9ICovXHJcbiAgICBjb25zdCBhbmltUHJvcHMgPSB7XHJcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcclxuICAgICAgZWFzaW5nOiB0aGlzLnBzd3Aub3B0aW9ucy5lYXNpbmcsXHJcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICBpZiAoIWFuaW1hdGlvbnMuYWN0aXZlQW5pbWF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHRhcmdldCxcclxuICAgIH07XHJcbiAgICBhbmltUHJvcHNbcHJvcF0gPSBwcm9wVmFsdWU7XHJcbiAgICBhbmltYXRpb25zLnN0YXJ0VHJhbnNpdGlvbihhbmltUHJvcHMpO1xyXG4gIH1cclxufVxuXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLlR5cGU8VD59IFR5cGU8VD5cclxuICovXHJcblxyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL3pvb20tbGV2ZWwuanMnKS5ab29tTGV2ZWxPcHRpb259IFpvb21MZXZlbE9wdGlvbiAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi91aS91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9tYWluLXNjcm9sbC5qcycpLkl0ZW1Ib2xkZXJ9IEl0ZW1Ib2xkZXIgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5QaG90b1N3aXBlRXZlbnRzTWFwfSBQaG90b1N3aXBlRXZlbnRzTWFwICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvZXZlbnRhYmxlLmpzJykuUGhvdG9Td2lwZUZpbHRlcnNNYXB9IFBob3RvU3dpcGVGaWx0ZXJzTWFwICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL2dldC10aHVtYi1ib3VuZHMnKS5Cb3VuZHN9IEJvdW5kcyAqL1xyXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL2V2ZW50YWJsZS5qcycpLkV2ZW50Q2FsbGJhY2s8VD59IEV2ZW50Q2FsbGJhY2s8VD5cclxuICovXHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvZXZlbnRhYmxlLmpzJykuQXVnbWVudGVkRXZlbnQ8VD59IEF1Z21lbnRlZEV2ZW50PFQ+XHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBpZD86IHN0cmluZyB8IG51bWJlciB9fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYge3sgdG9wOiBudW1iZXI7IGJvdHRvbTogbnVtYmVyOyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXIgfX0gUGFkZGluZyAqL1xyXG4vKiogQHR5cGVkZWYge1NsaWRlRGF0YVtdfSBEYXRhU291cmNlQXJyYXkgKi9cclxuLyoqIEB0eXBlZGVmIHt7IGdhbGxlcnk6IEhUTUxFbGVtZW50OyBpdGVtcz86IEhUTUxFbGVtZW50W10gfX0gRGF0YVNvdXJjZU9iamVjdCAqL1xyXG4vKiogQHR5cGVkZWYge0RhdGFTb3VyY2VBcnJheSB8IERhdGFTb3VyY2VPYmplY3R9IERhdGFTb3VyY2UgKi9cclxuLyoqIEB0eXBlZGVmIHsocG9pbnQ6IFBvaW50LCBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHZvaWR9IEFjdGlvbkZuICovXHJcbi8qKiBAdHlwZWRlZiB7J2Nsb3NlJyB8ICduZXh0JyB8ICd6b29tJyB8ICd6b29tLW9yLWNsb3NlJyB8ICd0b2dnbGUtY29udHJvbHMnfSBBY3Rpb25UeXBlICovXHJcbi8qKiBAdHlwZWRlZiB7VHlwZTxQaG90b1N3aXBlPiB8IHsgZGVmYXVsdDogVHlwZTxQaG90b1N3aXBlPiB9fSBQaG90b1N3aXBlTW9kdWxlICovXHJcbi8qKiBAdHlwZWRlZiB7UGhvdG9Td2lwZU1vZHVsZSB8IFByb21pc2U8UGhvdG9Td2lwZU1vZHVsZT4gfCAoKCkgPT4gUHJvbWlzZTxQaG90b1N3aXBlTW9kdWxlPil9IFBob3RvU3dpcGVNb2R1bGVPcHRpb24gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7c3RyaW5nIHwgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudFtdIHwgSFRNTEVsZW1lbnR9IEVsZW1lbnRQcm92aWRlclxyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7UGFydGlhbDxQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zPn0gUGhvdG9Td2lwZU9wdGlvbnMgaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9vcHRpb25zLyAqL1xyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gUHJlcGFyZWRQaG90b1N3aXBlT3B0aW9uc1xyXG4gKlxyXG4gKiBAcHJvcCB7RGF0YVNvdXJjZX0gW2RhdGFTb3VyY2VdXHJcbiAqIFBhc3MgYW4gYXJyYXkgb2YgYW55IGl0ZW1zIHZpYSBkYXRhU291cmNlIG9wdGlvbi4gSXRzIGxlbmd0aCB3aWxsIGRldGVybWluZSBhbW91bnQgb2Ygc2xpZGVzXHJcbiAqICh3aGljaCBtYXkgYmUgbW9kaWZpZWQgZnVydGhlciBmcm9tIG51bUl0ZW1zIGV2ZW50KS5cclxuICpcclxuICogRWFjaCBpdGVtIHNob3VsZCBjb250YWluIGRhdGEgdGhhdCB5b3UgbmVlZCB0byBnZW5lcmF0ZSBzbGlkZVxyXG4gKiAoZm9yIGltYWdlIHNsaWRlIGl0IHdvdWxkIGJlIHNyYyAoaW1hZ2UgVVJMKSwgd2lkdGggKGltYWdlIHdpZHRoKSwgaGVpZ2h0LCBzcmNzZXQsIGFsdCkuXHJcbiAqXHJcbiAqIElmIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBwcmVzZW50IGluIHlvdXIgaW5pdGlhbCBhcnJheSwgeW91IG1heSBcInByZS1wYXJzZVwiIGVhY2ggaXRlbSBmcm9tIGl0ZW1EYXRhIGZpbHRlci5cclxuICpcclxuICogQHByb3Age251bWJlcn0gYmdPcGFjaXR5XHJcbiAqIEJhY2tncm91bmQgYmFja2Ryb3Agb3BhY2l0eSwgYWx3YXlzIGRlZmluZSBpdCB2aWEgdGhpcyBvcHRpb24gYW5kIG5vdCB2aWEgQ1NTIHJnYmEgY29sb3IuXHJcbiAqXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHNwYWNpbmdcclxuICogU3BhY2luZyBiZXR3ZWVuIHNsaWRlcy4gRGVmaW5lZCBhcyByYXRpbyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgd2lkdGggKDAuMSA9IDEwJSBvZiB2aWV3cG9ydCkuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBhbGxvd1BhblRvTmV4dFxyXG4gKiBBbGxvdyBzd2lwZSBuYXZpZ2F0aW9uIHRvIHRoZSBuZXh0IHNsaWRlIHdoZW4gdGhlIGN1cnJlbnQgc2xpZGUgaXMgem9vbWVkLiBEb2VzIG5vdCBhcHBseSB0byBtb3VzZSBldmVudHMuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBsb29wXHJcbiAqIElmIHNldCB0byB0cnVlIHlvdSdsbCBiZSBhYmxlIHRvIHN3aXBlIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0IGltYWdlLlxyXG4gKiBPcHRpb24gaXMgYWx3YXlzIGZhbHNlIHdoZW4gdGhlcmUgYXJlIGxlc3MgdGhhbiAzIHNsaWRlcy5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IFt3aGVlbFRvWm9vbV1cclxuICogQnkgZGVmYXVsdCBQaG90b1N3aXBlIHpvb21zIGltYWdlIHdpdGggY3RybC13aGVlbCwgaWYgeW91IGVuYWJsZSB0aGlzIG9wdGlvbiAtIGltYWdlIHdpbGwgem9vbSBqdXN0IHZpYSB3aGVlbC5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IHBpbmNoVG9DbG9zZVxyXG4gKiBQaW5jaCB0b3VjaCBnZXN0dXJlIHRvIGNsb3NlIHRoZSBnYWxsZXJ5LlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gY2xvc2VPblZlcnRpY2FsRHJhZ1xyXG4gKiBWZXJ0aWNhbCBkcmFnIGdlc3R1cmUgdG8gY2xvc2UgdGhlIFBob3RvU3dpcGUuXHJcbiAqXHJcbiAqIEBwcm9wIHtQYWRkaW5nfSBbcGFkZGluZ11cclxuICogU2xpZGUgYXJlYSBwYWRkaW5nIChpbiBwaXhlbHMpLlxyXG4gKlxyXG4gKiBAcHJvcCB7KHZpZXdwb3J0U2l6ZTogUG9pbnQsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IFBhZGRpbmd9IFtwYWRkaW5nRm5dXHJcbiAqIFRoZSBvcHRpb24gaXMgY2hlY2tlZCBmcmVxdWVudGx5LCBzbyBtYWtlIHN1cmUgaXQncyBwZXJmb3JtYW50LiBPdmVycmlkZXMgcGFkZGluZyBvcHRpb24gaWYgZGVmaW5lZC4gRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIEBwcm9wIHtudW1iZXIgfCBmYWxzZX0gaGlkZUFuaW1hdGlvbkR1cmF0aW9uXHJcbiAqIFRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLCBjYW4gYmUgMC5cclxuICpcclxuICogQHByb3Age251bWJlciB8IGZhbHNlfSBzaG93QW5pbWF0aW9uRHVyYXRpb25cclxuICogVHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMsIGNhbiBiZSAwLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyIHwgZmFsc2V9IHpvb21BbmltYXRpb25EdXJhdGlvblxyXG4gKiBUcmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcywgY2FuIGJlIDAuXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IGVhc2luZ1xyXG4gKiBTdHJpbmcsICdjdWJpYy1iZXppZXIoLjQsMCwuMjIsMSknLiBDU1MgZWFzaW5nIGZ1bmN0aW9uIGZvciBvcGVuL2Nsb3NlL3pvb20gdHJhbnNpdGlvbnMuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBlc2NLZXlcclxuICogRXNjIGtleSB0byBjbG9zZS5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IGFycm93S2V5c1xyXG4gKiBMZWZ0L3JpZ2h0IGFycm93IGtleXMgZm9yIG5hdmlnYXRpb24uXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSByZXR1cm5Gb2N1c1xyXG4gKiBSZXN0b3JlIGZvY3VzIHRoZSBsYXN0IGFjdGl2ZSBlbGVtZW50IGFmdGVyIFBob3RvU3dpcGUgaXMgY2xvc2VkLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gY2xpY2tUb0Nsb3NlTm9uWm9vbWFibGVcclxuICogSWYgaW1hZ2UgaXMgbm90IHpvb21hYmxlIChmb3IgZXhhbXBsZSwgc21hbGxlciB0aGFuIHZpZXdwb3J0KSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIG9uIGl0LlxyXG4gKlxyXG4gKiBAcHJvcCB7QWN0aW9uVHlwZSB8IEFjdGlvbkZuIHwgZmFsc2V9IGltYWdlQ2xpY2tBY3Rpb25cclxuICogUmVmZXIgdG8gY2xpY2sgYW5kIHRhcCBhY3Rpb25zIHBhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wIHtBY3Rpb25UeXBlIHwgQWN0aW9uRm4gfCBmYWxzZX0gYmdDbGlja0FjdGlvblxyXG4gKiBSZWZlciB0byBjbGljayBhbmQgdGFwIGFjdGlvbnMgcGFnZS5cclxuICpcclxuICogQHByb3Age0FjdGlvblR5cGUgfCBBY3Rpb25GbiB8IGZhbHNlfSB0YXBBY3Rpb25cclxuICogUmVmZXIgdG8gY2xpY2sgYW5kIHRhcCBhY3Rpb25zIHBhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wIHtBY3Rpb25UeXBlIHwgQWN0aW9uRm4gfCBmYWxzZX0gZG91YmxlVGFwQWN0aW9uXHJcbiAqIFJlZmVyIHRvIGNsaWNrIGFuZCB0YXAgYWN0aW9ucyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyfSBwcmVsb2FkZXJEZWxheVxyXG4gKiBEZWxheSBiZWZvcmUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHdpbGwgYmUgZGlzcGxheWVkLFxyXG4gKiBpZiBpbWFnZSBpcyBsb2FkZWQgZHVyaW5nIGl0IC0gdGhlIGluZGljYXRvciB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQgYXQgYWxsLiBDYW4gYmUgemVyby5cclxuICpcclxuICogQHByb3Age3N0cmluZ30gaW5kZXhJbmRpY2F0b3JTZXBcclxuICogVXNlZCBmb3Igc2xpZGUgY291bnQgaW5kaWNhdG9yIChcIjEgb2YgMTAgXCIpLlxyXG4gKlxyXG4gKiBAcHJvcCB7KG9wdGlvbnM6IFBob3RvU3dpcGVPcHRpb25zLCBwc3dwOiBQaG90b1N3aXBlQmFzZSkgPT4gUG9pbnR9IFtnZXRWaWV3cG9ydFNpemVGbl1cclxuICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gc2xpZGUgdmlld3BvcnQgd2lkdGggYW5kIGhlaWdodCwgaW4gZm9ybWF0IHt4OiAxMDAsIHk6IDEwMH0uXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IGVycm9yTXNnXHJcbiAqIE1lc3NhZ2UgdG8gZGlzcGxheSB3aGVuIHRoZSBpbWFnZSB3YXNuJ3QgYWJsZSB0byBsb2FkLiBJZiB5b3UgbmVlZCB0byBkaXNwbGF5IEhUTUwgLSB1c2UgY29udGVudEVycm9yRWxlbWVudCBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBwcm9wIHtbbnVtYmVyLCBudW1iZXJdfSBwcmVsb2FkXHJcbiAqIExhenkgbG9hZGluZyBvZiBuZWFyYnkgc2xpZGVzIGJhc2VkIG9uIGRpcmVjdGlvbiBvZiBtb3ZlbWVudC4gU2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdHdvIGludGVnZXJzLFxyXG4gKiBmaXJzdCBvbmUgLSBudW1iZXIgb2YgaXRlbXMgdG8gcHJlbG9hZCBiZWZvcmUgdGhlIGN1cnJlbnQgaW1hZ2UsIHNlY29uZCBvbmUgLSBhZnRlciB0aGUgY3VycmVudCBpbWFnZS5cclxuICogVHdvIG5lYXJieSBpbWFnZXMgYXJlIGFsd2F5cyBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFttYWluQ2xhc3NdXHJcbiAqIENsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcm9vdCBlbGVtZW50IG9mIFBob3RvU3dpcGUsIG1heSBjb250YWluIG11bHRpcGxlIHNlcGFyYXRlZCBieSBzcGFjZS5cclxuICogRXhhbXBsZSBvbiBTdHlsaW5nIHBhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wIHtIVE1MRWxlbWVudH0gW2FwcGVuZFRvRWxdXHJcbiAqIEVsZW1lbnQgdG8gd2hpY2ggUGhvdG9Td2lwZSBkaWFsb2cgd2lsbCBiZSBhcHBlbmRlZCB3aGVuIGl0IG9wZW5zLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyfSBtYXhXaWR0aFRvQW5pbWF0ZVxyXG4gKiBNYXhpbXVtIHdpZHRoIG9mIGltYWdlIHRvIGFuaW1hdGUsIGlmIGluaXRpYWwgcmVuZGVyZWQgaW1hZ2Ugd2lkdGhcclxuICogaXMgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZSAtIHRoZSBvcGVuaW5nL2Nsb3NpbmcgdHJhbnNpdGlvbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQuXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtjbG9zZVRpdGxlXVxyXG4gKiBUcmFuc2xhdGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbem9vbVRpdGxlXVxyXG4gKiBUcmFuc2xhdGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbYXJyb3dQcmV2VGl0bGVdXHJcbiAqIFRyYW5zbGF0aW5nXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFthcnJvd05leHRUaXRsZV1cclxuICogVHJhbnNsYXRpbmdcclxuICpcclxuICogQHByb3Ageyd6b29tJyB8ICdmYWRlJyB8ICdub25lJ30gW3Nob3dIaWRlQW5pbWF0aW9uVHlwZV1cclxuICogVG8gYWRqdXN0IG9wZW5pbmcgb3IgY2xvc2luZyB0cmFuc2l0aW9uIHR5cGUgdXNlIGxpZ2h0Ym94IG9wdGlvbiBgc2hvd0hpZGVBbmltYXRpb25UeXBlYCAoYFN0cmluZ2ApLlxyXG4gKiBJdCBzdXBwb3J0cyB0aHJlZSB2YWx1ZXMgLSBgem9vbWAgKGRlZmF1bHQpLCBgZmFkZWAgKGRlZmF1bHQgaWYgdGhlcmUgaXMgbm8gdGh1bWJuYWlsKSBhbmQgYG5vbmVgLlxyXG4gKlxyXG4gKiBBbmltYXRpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGRpc2FibGVkIGlmIHVzZXIgYChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpYC5cclxuICpcclxuICogQHByb3Age251bWJlcn0gaW5kZXhcclxuICogRGVmaW5lcyBzdGFydCBzbGlkZSBpbmRleC5cclxuICpcclxuICogQHByb3AgeyhlOiBNb3VzZUV2ZW50KSA9PiBudW1iZXJ9IFtnZXRDbGlja2VkSW5kZXhGbl1cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IFthcnJvd1ByZXZdXHJcbiAqIEBwcm9wIHtib29sZWFufSBbYXJyb3dOZXh0XVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW3pvb21dXHJcbiAqIEBwcm9wIHtib29sZWFufSBbY2xvc2VdXHJcbiAqIEBwcm9wIHtib29sZWFufSBbY291bnRlcl1cclxuICpcclxuICogQHByb3Age3N0cmluZ30gW2Fycm93UHJldlNWR11cclxuICogQHByb3Age3N0cmluZ30gW2Fycm93TmV4dFNWR11cclxuICogQHByb3Age3N0cmluZ30gW3pvb21TVkddXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtjbG9zZVNWR11cclxuICogQHByb3Age3N0cmluZ30gW2NvdW50ZXJTVkddXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFthcnJvd1ByZXZUaXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW2Fycm93TmV4dFRpdGxlXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbem9vbVRpdGxlXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbY2xvc2VUaXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW2NvdW50ZXJUaXRsZV1cclxuICpcclxuICogQHByb3Age1pvb21MZXZlbE9wdGlvbn0gW2luaXRpYWxab29tTGV2ZWxdXHJcbiAqIEBwcm9wIHtab29tTGV2ZWxPcHRpb259IFtzZWNvbmRhcnlab29tTGV2ZWxdXHJcbiAqIEBwcm9wIHtab29tTGV2ZWxPcHRpb259IFttYXhab29tTGV2ZWxdXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBbbW91c2VNb3ZlUGFuXVxyXG4gKiBAcHJvcCB7UG9pbnQgfCBudWxsfSBbaW5pdGlhbFBvaW50ZXJQb3NdXHJcbiAqIEBwcm9wIHtib29sZWFufSBbc2hvd0hpZGVPcGFjaXR5XVxyXG4gKlxyXG4gKiBAcHJvcCB7UGhvdG9Td2lwZU1vZHVsZU9wdGlvbn0gW3Bzd3BNb2R1bGVdXHJcbiAqIEBwcm9wIHsoKSA9PiBQcm9taXNlPGFueT59IFtvcGVuUHJvbWlzZV1cclxuICogQHByb3Age2Jvb2xlYW59IFtwcmVsb2FkRmlyc3RTbGlkZV1cclxuICogQHByb3Age0VsZW1lbnRQcm92aWRlcn0gW2dhbGxlcnldXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtnYWxsZXJ5U2VsZWN0b3JdXHJcbiAqIEBwcm9wIHtFbGVtZW50UHJvdmlkZXJ9IFtjaGlsZHJlbl1cclxuICogQHByb3Age3N0cmluZ30gW2NoaWxkU2VsZWN0b3JdXHJcbiAqIEBwcm9wIHtzdHJpbmcgfCBmYWxzZX0gW3RodW1iU2VsZWN0b3JdXHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlIHtQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zfSAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBhbGxvd1BhblRvTmV4dDogdHJ1ZSxcclxuICBzcGFjaW5nOiAwLjEsXHJcbiAgbG9vcDogdHJ1ZSxcclxuICBwaW5jaFRvQ2xvc2U6IHRydWUsXHJcbiAgY2xvc2VPblZlcnRpY2FsRHJhZzogdHJ1ZSxcclxuICBoaWRlQW5pbWF0aW9uRHVyYXRpb246IDMzMyxcclxuICBzaG93QW5pbWF0aW9uRHVyYXRpb246IDMzMyxcclxuICB6b29tQW5pbWF0aW9uRHVyYXRpb246IDMzMyxcclxuICBlc2NLZXk6IHRydWUsXHJcbiAgYXJyb3dLZXlzOiB0cnVlLFxyXG4gIHJldHVybkZvY3VzOiB0cnVlLFxyXG4gIG1heFdpZHRoVG9BbmltYXRlOiA0MDAwLFxyXG4gIGNsaWNrVG9DbG9zZU5vblpvb21hYmxlOiB0cnVlLFxyXG4gIGltYWdlQ2xpY2tBY3Rpb246ICd6b29tLW9yLWNsb3NlJyxcclxuICBiZ0NsaWNrQWN0aW9uOiAnY2xvc2UnLFxyXG4gIHRhcEFjdGlvbjogJ3RvZ2dsZS1jb250cm9scycsXHJcbiAgZG91YmxlVGFwQWN0aW9uOiAnem9vbScsXHJcbiAgaW5kZXhJbmRpY2F0b3JTZXA6ICcgLyAnLFxyXG4gIHByZWxvYWRlckRlbGF5OiAyMDAwLFxyXG4gIGJnT3BhY2l0eTogMC44LFxyXG5cclxuICBpbmRleDogMCxcclxuICBlcnJvck1zZzogJ1RoZSBpbWFnZSBjYW5ub3QgYmUgbG9hZGVkJyxcclxuICBwcmVsb2FkOiBbMSwgMl0sXHJcbiAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKC40LDAsLjIyLDEpJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBob3RvU3dpcGUgQ29yZVxyXG4gKi9cclxuY2xhc3MgUGhvdG9Td2lwZSBleHRlbmRzIFBob3RvU3dpcGVCYXNlIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogb2Zmc2V0IG9mIHZpZXdwb3J0IHJlbGF0aXZlIHRvIGRvY3VtZW50XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fcHJldlZpZXdwb3J0U2l6ZSA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2l6ZSBvZiBzY3JvbGxhYmxlIFBob3RvU3dpcGUgdmlld3BvcnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmlld3BvcnRTaXplID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBiYWNrZ3JvdW5kIChiYWNrZHJvcCkgb3BhY2l0eVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJnT3BhY2l0eSA9IDE7XHJcbiAgICB0aGlzLmN1cnJJbmRleCA9IDA7XHJcbiAgICB0aGlzLnBvdGVudGlhbEluZGV4ID0gMDtcclxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzRGVzdHJveWluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNNb3VzZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtTbGlkZURhdGF9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2luaXRpYWxJdGVtRGF0YSA9IHt9O1xyXG4gICAgLyoqIEB0eXBlIHtCb3VuZHMgfCB1bmRlZmluZWR9ICovXHJcbiAgICB0aGlzLl9pbml0aWFsVGh1bWJCb3VuZHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cclxuICAgIHRoaXMudG9wQmFyID0gdW5kZWZpbmVkO1xyXG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cclxuICAgIHRoaXMuZWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWR9ICovXHJcbiAgICB0aGlzLnRlbXBsYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cclxuICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cclxuICAgIHRoaXMuc2Nyb2xsV3JhcCA9IHVuZGVmaW5lZDtcclxuICAgIC8qKiBAdHlwZSB7U2xpZGUgfCB1bmRlZmluZWR9ICovXHJcbiAgICB0aGlzLmN1cnJTbGlkZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBET01FdmVudHMoKTtcclxuICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKCk7XHJcbiAgICB0aGlzLm1haW5TY3JvbGwgPSBuZXcgTWFpblNjcm9sbCh0aGlzKTtcclxuICAgIHRoaXMuZ2VzdHVyZXMgPSBuZXcgR2VzdHVyZXModGhpcyk7XHJcbiAgICB0aGlzLm9wZW5lciA9IG5ldyBPcGVuZXIodGhpcyk7XHJcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKHRoaXMpO1xyXG4gICAgdGhpcy5jb250ZW50TG9hZGVyID0gbmV3IENvbnRlbnRMb2FkZXIodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKiogQHJldHVybnMge2Jvb2xlYW59ICovXHJcbiAgaW5pdCgpIHtcclxuICAgIGlmICh0aGlzLmlzT3BlbiB8fCB0aGlzLmlzRGVzdHJveWluZykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pc09wZW4gPSB0cnVlO1xyXG4gICAgdGhpcy5kaXNwYXRjaCgnaW5pdCcpOyAvLyBsZWdhY3lcclxuICAgIHRoaXMuZGlzcGF0Y2goJ2JlZm9yZU9wZW4nKTtcclxuXHJcbiAgICB0aGlzLl9jcmVhdGVNYWluU3RydWN0dXJlKCk7XHJcblxyXG4gICAgLy8gYWRkIGNsYXNzZXMgdG8gdGhlIHJvb3QgZWxlbWVudCBvZiBQaG90b1N3aXBlXHJcbiAgICBsZXQgcm9vdENsYXNzZXMgPSAncHN3cC0tb3Blbic7XHJcbiAgICBpZiAodGhpcy5nZXN0dXJlcy5zdXBwb3J0c1RvdWNoKSB7XHJcbiAgICAgIHJvb3RDbGFzc2VzICs9ICcgcHN3cC0tdG91Y2gnO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5tYWluQ2xhc3MpIHtcclxuICAgICAgcm9vdENsYXNzZXMgKz0gJyAnICsgdGhpcy5vcHRpb25zLm1haW5DbGFzcztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyByb290Q2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJJbmRleCA9IHRoaXMub3B0aW9ucy5pbmRleCB8fCAwO1xyXG4gICAgdGhpcy5wb3RlbnRpYWxJbmRleCA9IHRoaXMuY3VyckluZGV4O1xyXG4gICAgdGhpcy5kaXNwYXRjaCgnZmlyc3RVcGRhdGUnKTsgLy8gc3RhcnRpbmcgaW5kZXggY2FuIGJlIG1vZGlmaWVkIGhlcmVcclxuXHJcbiAgICAvLyBpbml0aWFsaXplIHNjcm9sbCB3aGVlbCBoYW5kbGVyIHRvIGJsb2NrIHRoZSBzY3JvbGxcclxuICAgIHRoaXMuc2Nyb2xsV2hlZWwgPSBuZXcgU2Nyb2xsV2hlZWwodGhpcyk7XHJcblxyXG4gICAgLy8gc2FuaXRpemUgaW5kZXhcclxuICAgIGlmIChOdW1iZXIuaXNOYU4odGhpcy5jdXJySW5kZXgpXHJcbiAgICAgICAgfHwgdGhpcy5jdXJySW5kZXggPCAwXHJcbiAgICAgICAgfHwgdGhpcy5jdXJySW5kZXggPj0gdGhpcy5nZXROdW1JdGVtcygpKSB7XHJcbiAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuZ2VzdHVyZXMuc3VwcG9ydHNUb3VjaCkge1xyXG4gICAgICAvLyBlbmFibGUgbW91c2UgZmVhdHVyZXMgaWYgbm8gdG91Y2ggc3VwcG9ydCBkZXRlY3RlZFxyXG4gICAgICB0aGlzLm1vdXNlRGV0ZWN0ZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYXVzZXMgZm9yY2VkIHN5bmNocm9ub3VzIGxheW91dFxyXG4gICAgdGhpcy51cGRhdGVTaXplKCk7XHJcblxyXG4gICAgdGhpcy5vZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuXHJcbiAgICB0aGlzLl9pbml0aWFsSXRlbURhdGEgPSB0aGlzLmdldEl0ZW1EYXRhKHRoaXMuY3VyckluZGV4KTtcclxuICAgIHRoaXMuZGlzcGF0Y2goJ2dldHRpbmdEYXRhJywge1xyXG4gICAgICBpbmRleDogdGhpcy5jdXJySW5kZXgsXHJcbiAgICAgIGRhdGE6IHRoaXMuX2luaXRpYWxJdGVtRGF0YSxcclxuICAgICAgc2xpZGU6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gKkxheW91dCogLSBjYWxjdWxhdGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgZWxlbWVudHMgaGVyZVxyXG4gICAgdGhpcy5faW5pdGlhbFRodW1iQm91bmRzID0gdGhpcy5nZXRUaHVtYkJvdW5kcygpO1xyXG4gICAgdGhpcy5kaXNwYXRjaCgnaW5pdGlhbExheW91dCcpO1xyXG5cclxuICAgIHRoaXMub24oJ29wZW5pbmdBbmltYXRpb25FbmQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgaXRlbUhvbGRlcnMgfSA9IHRoaXMubWFpblNjcm9sbDtcclxuXHJcbiAgICAgIC8vIEFkZCBjb250ZW50IHRvIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBzbGlkZVxyXG4gICAgICBpZiAoaXRlbUhvbGRlcnNbMF0pIHtcclxuICAgICAgICBpdGVtSG9sZGVyc1swXS5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB0aGlzLnNldENvbnRlbnQoaXRlbUhvbGRlcnNbMF0sIHRoaXMuY3VyckluZGV4IC0gMSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGl0ZW1Ib2xkZXJzWzJdKSB7XHJcbiAgICAgICAgaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KGl0ZW1Ib2xkZXJzWzJdLCB0aGlzLmN1cnJJbmRleCArIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFwcGVuZEhlYXZ5KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbnRlbnRMb2FkZXIudXBkYXRlTGF6eSgpO1xyXG5cclxuICAgICAgdGhpcy5ldmVudHMuYWRkKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVBhZ2VSZXNpemUuYmluZCh0aGlzKSk7XHJcbiAgICAgIHRoaXMuZXZlbnRzLmFkZCh3aW5kb3csICdzY3JvbGwnLCB0aGlzLl91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0LmJpbmQodGhpcykpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoKCdiaW5kRXZlbnRzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzZXQgY29udGVudCBmb3IgY2VudGVyIHNsaWRlIChmaXJzdCB0aW1lKVxyXG4gICAgaWYgKHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVyc1sxXSkge1xyXG4gICAgICB0aGlzLnNldENvbnRlbnQodGhpcy5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzFdLCB0aGlzLmN1cnJJbmRleCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmRpc3BhdGNoKCdjaGFuZ2UnKTtcclxuXHJcbiAgICB0aGlzLm9wZW5lci5vcGVuKCk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnYWZ0ZXJJbml0Jyk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgbG9vcGVkIHNsaWRlIGluZGV4XHJcbiAgICogKGZvciBleGFtcGxlLCAtMSB3aWxsIHJldHVybiB0aGUgbGFzdCBzbGlkZSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0TG9vcGVkSW5kZXgoaW5kZXgpIHtcclxuICAgIGNvbnN0IG51bVNsaWRlcyA9IHRoaXMuZ2V0TnVtSXRlbXMoKTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvb3ApIHtcclxuICAgICAgaWYgKGluZGV4ID4gbnVtU2xpZGVzIC0gMSkge1xyXG4gICAgICAgIGluZGV4IC09IG51bVNsaWRlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIGluZGV4ICs9IG51bVNsaWRlcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGFtcChpbmRleCwgMCwgbnVtU2xpZGVzIC0gMSk7XHJcbiAgfVxyXG5cclxuICBhcHBlbmRIZWF2eSgpIHtcclxuICAgIHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVycy5mb3JFYWNoKChpdGVtSG9sZGVyKSA9PiB7XHJcbiAgICAgIGl0ZW1Ib2xkZXIuc2xpZGU/LmFwcGVuZEhlYXZ5KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgc2xpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggTmV3IGluZGV4XHJcbiAgICovXHJcbiAgZ29UbyhpbmRleCkge1xyXG4gICAgdGhpcy5tYWluU2Nyb2xsLm1vdmVJbmRleEJ5KFxyXG4gICAgICB0aGlzLmdldExvb3BlZEluZGV4KGluZGV4KSAtIHRoaXMucG90ZW50aWFsSW5kZXhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHbyB0byB0aGUgbmV4dCBzbGlkZS5cclxuICAgKi9cclxuICBuZXh0KCkge1xyXG4gICAgdGhpcy5nb1RvKHRoaXMucG90ZW50aWFsSW5kZXggKyAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cclxuICAgKi9cclxuICBwcmV2KCkge1xyXG4gICAgdGhpcy5nb1RvKHRoaXMucG90ZW50aWFsSW5kZXggLSAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBzZWUgc2xpZGUvc2xpZGUuanMgem9vbVRvXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8U2xpZGVbJ3pvb21UbyddPn0gYXJnc1xyXG4gICAqL1xyXG4gIHpvb21UbyguLi5hcmdzKSB7XHJcbiAgICB0aGlzLmN1cnJTbGlkZT8uem9vbVRvKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHNlZSBzbGlkZS9zbGlkZS5qcyB0b2dnbGVab29tXHJcbiAgICovXHJcbiAgdG9nZ2xlWm9vbSgpIHtcclxuICAgIHRoaXMuY3VyclNsaWRlPy50b2dnbGVab29tKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9zZSB0aGUgZ2FsbGVyeS5cclxuICAgKiBBZnRlciBjbG9zaW5nIHRyYW5zaXRpb24gZW5kcyAtIGRlc3Ryb3kgaXRcclxuICAgKi9cclxuICBjbG9zZSgpIHtcclxuICAgIGlmICghdGhpcy5vcGVuZXIuaXNPcGVuIHx8IHRoaXMuaXNEZXN0cm95aW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmlzRGVzdHJveWluZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnY2xvc2UnKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGwoKTtcclxuICAgIHRoaXMub3BlbmVyLmNsb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyB0aGUgZ2FsbGVyeTpcclxuICAgKiAtIGluc3RhbnRseSBjbG9zZXMgdGhlIGdhbGxlcnlcclxuICAgKiAtIHVuYmluZHMgZXZlbnRzLFxyXG4gICAqIC0gY2xlYW5zIGludGVydmFscyBhbmQgdGltZW91dHNcclxuICAgKiAtIHJlbW92ZXMgZWxlbWVudHMgZnJvbSBET01cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgaWYgKCF0aGlzLmlzRGVzdHJveWluZykge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuc2hvd0hpZGVBbmltYXRpb25UeXBlID0gJ25vbmUnO1xyXG4gICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoKCdkZXN0cm95Jyk7XHJcblxyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcblxyXG4gICAgaWYgKHRoaXMuc2Nyb2xsV3JhcCkge1xyXG4gICAgICB0aGlzLnNjcm9sbFdyYXAub250b3VjaG1vdmUgPSBudWxsO1xyXG4gICAgICB0aGlzLnNjcm9sbFdyYXAub250b3VjaGVuZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbGVtZW50Py5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnMuZm9yRWFjaCgoaXRlbUhvbGRlcikgPT4ge1xyXG4gICAgICBpdGVtSG9sZGVyLnNsaWRlPy5kZXN0cm95KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRMb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoL3JlbG9hZCBjb250ZW50IG9mIGEgc2xpZGUgYnkgaXRzIGluZGV4XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2xpZGVJbmRleFxyXG4gICAqL1xyXG4gIHJlZnJlc2hTbGlkZUNvbnRlbnQoc2xpZGVJbmRleCkge1xyXG4gICAgdGhpcy5jb250ZW50TG9hZGVyLnJlbW92ZUJ5SW5kZXgoc2xpZGVJbmRleCk7XHJcbiAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnMuZm9yRWFjaCgoaXRlbUhvbGRlciwgaSkgPT4ge1xyXG4gICAgICBsZXQgcG90ZW50aWFsSG9sZGVySW5kZXggPSAodGhpcy5jdXJyU2xpZGU/LmluZGV4ID8/IDApIC0gMSArIGk7XHJcbiAgICAgIGlmICh0aGlzLmNhbkxvb3AoKSkge1xyXG4gICAgICAgIHBvdGVudGlhbEhvbGRlckluZGV4ID0gdGhpcy5nZXRMb29wZWRJbmRleChwb3RlbnRpYWxIb2xkZXJJbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBvdGVudGlhbEhvbGRlckluZGV4ID09PSBzbGlkZUluZGV4KSB7XHJcbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgc2xpZGUgY29udGVudFxyXG4gICAgICAgIHRoaXMuc2V0Q29udGVudChpdGVtSG9sZGVyLCBzbGlkZUluZGV4LCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gYWN0aXZhdGUgdGhlIG5ldyBzbGlkZSBpZiBpdCdzIGN1cnJlbnRcclxuICAgICAgICBpZiAoaSA9PT0gMSkge1xyXG4gICAgICAgICAgdGhpcy5jdXJyU2xpZGUgPSBpdGVtSG9sZGVyLnNsaWRlO1xyXG4gICAgICAgICAgaXRlbUhvbGRlci5zbGlkZT8uc2V0SXNBY3RpdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoKCdjaGFuZ2UnKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTZXQgc2xpZGUgY29udGVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtJdGVtSG9sZGVyfSBob2xkZXIgbWFpblNjcm9sbC5pdGVtSG9sZGVycyBhcnJheSBpdGVtXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFNsaWRlIGluZGV4XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIElmIGNvbnRlbnQgc2hvdWxkIGJlIHNldCBldmVuIGlmIGluZGV4IHdhc24ndCBjaGFuZ2VkXHJcbiAgICovXHJcbiAgc2V0Q29udGVudChob2xkZXIsIGluZGV4LCBmb3JjZSkge1xyXG4gICAgaWYgKHRoaXMuY2FuTG9vcCgpKSB7XHJcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRMb29wZWRJbmRleChpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhvbGRlci5zbGlkZSkge1xyXG4gICAgICBpZiAoaG9sZGVyLnNsaWRlLmluZGV4ID09PSBpbmRleCAmJiAhZm9yY2UpIHtcclxuICAgICAgICAvLyBleGl0IGlmIGhvbGRlciBhbHJlYWR5IGNvbnRhaW5zIHRoaXMgc2xpZGVcclxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGNvbW1vbiB3aGVuIGp1c3QgdGhyZWUgc2xpZGVzIGFyZSB1c2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkZXN0cm95IHByZXZpb3VzIHNsaWRlXHJcbiAgICAgIGhvbGRlci5zbGlkZS5kZXN0cm95KCk7XHJcbiAgICAgIGhvbGRlci5zbGlkZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBleGl0IGlmIG5vIGxvb3AgYW5kIGluZGV4IGlzIG91dCBvZiBib3VuZHNcclxuICAgIGlmICghdGhpcy5jYW5Mb29wKCkgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmdldE51bUl0ZW1zKCkpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpdGVtRGF0YSA9IHRoaXMuZ2V0SXRlbURhdGEoaW5kZXgpO1xyXG4gICAgaG9sZGVyLnNsaWRlID0gbmV3IFNsaWRlKGl0ZW1EYXRhLCBpbmRleCwgdGhpcyk7XHJcblxyXG4gICAgLy8gc2V0IGN1cnJlbnQgc2xpZGVcclxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJySW5kZXgpIHtcclxuICAgICAgdGhpcy5jdXJyU2xpZGUgPSBob2xkZXIuc2xpZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaG9sZGVyLnNsaWRlLmFwcGVuZChob2xkZXIuZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEByZXR1cm5zIHtQb2ludH0gKi9cclxuICBnZXRWaWV3cG9ydENlbnRlclBvaW50KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogdGhpcy52aWV3cG9ydFNpemUueCAvIDIsXHJcbiAgICAgIHk6IHRoaXMudmlld3BvcnRTaXplLnkgLyAyXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNpemUgb2YgYWxsIGVsZW1lbnRzLlxyXG4gICAqIEV4ZWN1dGVkIG9uIGluaXQgYW5kIG9uIHBhZ2UgcmVzaXplLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIFVwZGF0ZSBzaXplIGV2ZW4gaWYgc2l6ZSBvZiB2aWV3cG9ydCB3YXMgbm90IGNoYW5nZWQuXHJcbiAgICovXHJcbiAgdXBkYXRlU2l6ZShmb3JjZSkge1xyXG4gICAgLy8gbGV0IGl0ZW07XHJcbiAgICAvLyBsZXQgaXRlbUluZGV4O1xyXG5cclxuICAgIGlmICh0aGlzLmlzRGVzdHJveWluZykge1xyXG4gICAgICAvLyBleGl0IGlmIFBob3RvU3dpcGUgaXMgY2xvc2VkIG9yIGNsb3NpbmdcclxuICAgICAgLy8gKHRvIGF2b2lkIGVycm9ycywgYXMgcmVzaXplIGV2ZW50IG1pZ2h0IGJlIGRlbGF5ZWQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnN0IG5ld1dpZHRoID0gdGhpcy5zY3JvbGxXcmFwLmNsaWVudFdpZHRoO1xyXG4gICAgLy9jb25zdCBuZXdIZWlnaHQgPSB0aGlzLnNjcm9sbFdyYXAuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSh0aGlzLm9wdGlvbnMsIHRoaXMpO1xyXG5cclxuICAgIGlmICghZm9yY2UgJiYgcG9pbnRzRXF1YWwobmV3Vmlld3BvcnRTaXplLCB0aGlzLl9wcmV2Vmlld3BvcnRTaXplKSkge1xyXG4gICAgICAvLyBFeGl0IGlmIGRpbWVuc2lvbnMgd2VyZSBub3QgY2hhbmdlZFxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy90aGlzLl9wcmV2Vmlld3BvcnRTaXplLnggPSBuZXdXaWR0aDtcclxuICAgIC8vdGhpcy5fcHJldlZpZXdwb3J0U2l6ZS55ID0gbmV3SGVpZ2h0O1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5fcHJldlZpZXdwb3J0U2l6ZSwgbmV3Vmlld3BvcnRTaXplKTtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoKCdiZWZvcmVSZXNpemUnKTtcclxuXHJcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnZpZXdwb3J0U2l6ZSwgdGhpcy5fcHJldlZpZXdwb3J0U2l6ZSk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUGFnZVNjcm9sbE9mZnNldCgpO1xyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2goJ3ZpZXdwb3J0U2l6ZScpO1xyXG5cclxuICAgIC8vIFJlc2l6ZSBzbGlkZXMgb25seSBhZnRlciBvcGVuZXIgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXHJcbiAgICAvLyBhbmQgZG9uJ3QgcmUtY2FsY3VsYXRlIHNpemUgb24gaW5pdGFsIHNpemUgdXBkYXRlXHJcbiAgICB0aGlzLm1haW5TY3JvbGwucmVzaXplKHRoaXMub3BlbmVyLmlzT3Blbik7XHJcblxyXG4gICAgaWYgKCF0aGlzLmhhc01vdXNlICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcoYW55LWhvdmVyOiBob3ZlciknKS5tYXRjaGVzKSB7XHJcbiAgICAgIHRoaXMubW91c2VEZXRlY3RlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2goJ3Jlc2l6ZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcclxuICAgKi9cclxuICBhcHBseUJnT3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICB0aGlzLmJnT3BhY2l0eSA9IE1hdGgubWF4KG9wYWNpdHksIDApO1xyXG4gICAgaWYgKHRoaXMuYmcpIHtcclxuICAgICAgdGhpcy5iZy5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHRoaXMuYmdPcGFjaXR5ICogdGhpcy5vcHRpb25zLmJnT3BhY2l0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIG1vdXNlIGlzIGRldGVjdGVkXHJcbiAgICovXHJcbiAgbW91c2VEZXRlY3RlZCgpIHtcclxuICAgIGlmICghdGhpcy5oYXNNb3VzZSkge1xyXG4gICAgICB0aGlzLmhhc01vdXNlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5lbGVtZW50Py5jbGFzc0xpc3QuYWRkKCdwc3dwLS1oYXNfbW91c2UnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhZ2UgcmVzaXplIGV2ZW50IGhhbmRsZXJcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2hhbmRsZVBhZ2VSZXNpemUoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuXHJcbiAgICAvLyBJbiBpT1Mgd2VidmlldywgaWYgZWxlbWVudCBzaXplIGRlcGVuZHMgb24gZG9jdW1lbnQgc2l6ZSxcclxuICAgIC8vIGl0J2xsIGJlIG1lYXN1cmVkIGluY29ycmVjdGx5IGluIHJlc2l6ZSBldmVudFxyXG4gICAgLy9cclxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA1OTVcclxuICAgIC8vIGh0dHBzOi8vaGFja2Vybm9vbi5jb20vb25yZXNpemUtZXZlbnQtYnJva2VuLWluLW1vYmlsZS1zYWZhcmktZDg0NjkwMjdiZjRkXHJcbiAgICBpZiAoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhZ2Ugc2Nyb2xsIG9mZnNldCBpcyB1c2VkXHJcbiAgICogdG8gZ2V0IGNvcnJlY3QgY29vcmRpbmF0ZXNcclxuICAgKiByZWxhdGl2ZSB0byBQaG90b1N3aXBlIHZpZXdwb3J0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCgpIHtcclxuICAgIHRoaXMuc2V0U2Nyb2xsT2Zmc2V0KDAsIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICovXHJcbiAgc2V0U2Nyb2xsT2Zmc2V0KHgsIHkpIHtcclxuICAgIHRoaXMub2Zmc2V0LnggPSB4O1xyXG4gICAgdGhpcy5vZmZzZXQueSA9IHk7XHJcbiAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVTY3JvbGxPZmZzZXQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBtYWluIEhUTUwgc3RydWN0dXJlIG9mIFBob3RvU3dpcGUsXHJcbiAgICogYW5kIGFkZCBpdCB0byBET01cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NyZWF0ZU1haW5TdHJ1Y3R1cmUoKSB7XHJcbiAgICAvLyByb290IERPTSBlbGVtZW50IG9mIFBob3RvU3dpcGUgKC5wc3dwKVxyXG4gICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudCgncHN3cCcsICdkaXYnKTtcclxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XHJcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xyXG5cclxuICAgIC8vIHRlbXBsYXRlIGlzIGxlZ2FjeSBwcm9wXHJcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5lbGVtZW50O1xyXG5cclxuICAgIC8vIEJhY2tncm91bmQgaXMgYWRkZWQgYXMgYSBzZXBhcmF0ZSBlbGVtZW50LFxyXG4gICAgLy8gYXMgYW5pbWF0aW5nIG9wYWNpdHkgaXMgZmFzdGVyIHRoYW4gYW5pbWF0aW5nIHJnYmEoKVxyXG4gICAgdGhpcy5iZyA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX2JnJywgJ2RpdicsIHRoaXMuZWxlbWVudCk7XHJcbiAgICB0aGlzLnNjcm9sbFdyYXAgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19zY3JvbGwtd3JhcCcsICdzZWN0aW9uJywgdGhpcy5lbGVtZW50KTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgncHN3cF9fY29udGFpbmVyJywgJ2RpdicsIHRoaXMuc2Nyb2xsV3JhcCk7XHJcblxyXG4gICAgLy8gYXJpYSBwYXR0ZXJuOiBjYXJvdXNlbFxyXG4gICAgdGhpcy5zY3JvbGxXcmFwLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlZGVzY3JpcHRpb24nLCAnY2Fyb3VzZWwnKTtcclxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xyXG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdwc3dwX19pdGVtcycpO1xyXG5cclxuICAgIHRoaXMubWFpblNjcm9sbC5hcHBlbmRIb2xkZXJzKCk7XHJcblxyXG4gICAgdGhpcy51aSA9IG5ldyBVSSh0aGlzKTtcclxuICAgIHRoaXMudWkuaW5pdCgpO1xyXG5cclxuICAgIC8vIGFwcGVuZCB0byBET01cclxuICAgICh0aGlzLm9wdGlvbnMuYXBwZW5kVG9FbCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucyBvZiBzbWFsbCB0aHVtYm5haWxcclxuICAgKiAgIHt4Oix5Oix3On1cclxuICAgKlxyXG4gICAqIEhlaWdodCBpcyBvcHRpb25hbCAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbGFyZ2UgaW1hZ2UpXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Qm91bmRzIHwgdW5kZWZpbmVkfVxyXG4gICAqL1xyXG4gIGdldFRodW1iQm91bmRzKCkge1xyXG4gICAgcmV0dXJuIGdldFRodW1iQm91bmRzKFxyXG4gICAgICB0aGlzLmN1cnJJbmRleCxcclxuICAgICAgdGhpcy5jdXJyU2xpZGUgPyB0aGlzLmN1cnJTbGlkZS5kYXRhIDogdGhpcy5faW5pdGlhbEl0ZW1EYXRhLFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIFBob3RvU3dpcGUgY2FuIGhhdmUgY29udGludW91cyBsb29wXHJcbiAgICogQHJldHVybnMgQm9vbGVhblxyXG4gICAqL1xyXG4gIGNhbkxvb3AoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMub3B0aW9ucy5sb29wICYmIHRoaXMuZ2V0TnVtSXRlbXMoKSA+IDIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBvcHRpb25zXHJcbiAgICogQHJldHVybnMge1ByZXBhcmVkUGhvdG9Td2lwZU9wdGlvbnN9XHJcbiAgICovXHJcbiAgX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pLCAodXBkYXRlOiBzbG93KScpLm1hdGNoZXMpIHtcclxuICAgICAgb3B0aW9ucy5zaG93SGlkZUFuaW1hdGlvblR5cGUgPSAnbm9uZSc7XHJcbiAgICAgIG9wdGlvbnMuem9vbUFuaW1hdGlvbkR1cmF0aW9uID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHR5cGUge1ByZXBhcmVkUGhvdG9Td2lwZU9wdGlvbnN9ICovXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuICB9XHJcbn1cblxuZXhwb3J0IHsgUGhvdG9Td2lwZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG90b3N3aXBlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==