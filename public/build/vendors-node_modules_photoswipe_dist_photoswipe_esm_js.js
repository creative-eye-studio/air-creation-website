"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_photoswipe_dist_photoswipe_esm_js"],{

/***/ "./node_modules/photoswipe/dist/photoswipe.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/photoswipe/dist/photoswipe.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PhotoSwipe)
/* harmony export */ });
/*!
  * PhotoSwipe 5.3.4 - https://photoswipe.com
  * (c) 2022 Dmytro Semenov
  */
/** @typedef {import('../photoswipe.js').Point} Point */

/** @typedef {undefined | null | false | '' | 0} Falsy */
/** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */

/**
 * @template {HTMLElementTagName | Falsy} [T="div"]
 * @template {Node | undefined} [NodeToAppendElementTo=undefined]
 * @param {string=} className
 * @param {T=} [tagName]
 * @param {NodeToAppendElementTo=} appendToEl
 * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}
 */
function createElement(className, tagName, appendToEl) {
  const el = document.createElement(tagName || 'div');
  if (className) {
    el.className = className;
  }
  if (appendToEl) {
    appendToEl.appendChild(el);
  }
  // @ts-expect-error
  return el;
}

/**
 * @param {Point} p1
 * @param {Point} p2
 */
function equalizePoints(p1, p2) {
  p1.x = p2.x;
  p1.y = p2.y;
  if (p2.id !== undefined) {
    p1.id = p2.id;
  }
  return p1;
}

/**
 * @param {Point} p
 */
function roundPoint(p) {
  p.x = Math.round(p.x);
  p.y = Math.round(p.y);
}

/**
 * Returns distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 */
function getDistanceBetween(p1, p2) {
  const x = Math.abs(p1.x - p2.x);
  const y = Math.abs(p1.y - p2.y);
  return Math.sqrt((x * x) + (y * y));
}

/**
 * Whether X and Y positions of points are qual
 *
 * @param {Point} p1
 * @param {Point} p2
 */
function pointsEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

/**
 * The float result between the min and max values.
 *
 * @param {number} val
 * @param {number} min
 * @param {number} max
 */
function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

/**
 * Get transform string
 *
 * @param {number} x
 * @param {number=} y
 * @param {number=} scale
 */
function toTransformString(x, y, scale) {
  let propValue = 'translate3d('
    + x + 'px,' + (y || 0) + 'px'
    + ',0)';

  if (scale !== undefined) {
    propValue += ' scale3d('
      + scale + ',' + scale
      + ',1)';
  }

  return propValue;
}

/**
 * Apply transform:translate(x, y) scale(scale) to element
 *
 * @param {HTMLElement} el
 * @param {number} x
 * @param {number=} y
 * @param {number=} scale
 */
function setTransform(el, x, y, scale) {
  el.style.transform = toTransformString(x, y, scale);
}

const defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';

/**
 * Apply CSS transition to element
 *
 * @param {HTMLElement} el
 * @param {string=} prop CSS property to animate
 * @param {number=} duration in ms
 * @param {string=} ease CSS easing function
 */
function setTransitionStyle(el, prop, duration, ease) {
  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions
  // out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions
  // in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions
  el.style.transition = prop
    ? (prop + ' ' + duration + 'ms ' + (ease || defaultCSSEasing))
    : 'none';
}

/**
 * Apply width and height CSS properties to element
 *
 * @param {HTMLElement} el
 * @param {string | number} w
 * @param {string | number} h
 */
function setWidthHeight(el, w, h) {
  el.style.width = (typeof w === 'number') ? (w + 'px') : w;
  el.style.height = (typeof h === 'number') ? (h + 'px') : h;
}

/**
 * @param {HTMLElement} el
 */
function removeTransitionStyle(el) {
  setTransitionStyle(el);
}

/**
 * @param {HTMLImageElement} img
 * @returns {Promise<HTMLImageElement | void>}
 */
function decodeImage(img) {
  if ('decode' in img) {
    return img.decode().catch(() => {});
  }

  if (img.complete) {
    return Promise.resolve(img);
  }

  return new Promise((resolve, reject) => {
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}

/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */
/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */
const LOAD_STATE = {
  IDLE: 'idle',
  LOADING: 'loading',
  LOADED: 'loaded',
  ERROR: 'error',
};


/**
 * Check if click or keydown event was dispatched
 * with a special key or via mouse wheel.
 *
 * @param {MouseEvent | KeyboardEvent} e
 */
function specialKeyUsed(e) {
  if (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
    return true;
  }
}

/**
 * Parse `gallery` or `children` options.
 *
 * @param {import('../photoswipe.js').ElementProvider} option
 * @param {string=} legacySelector
 * @param {HTMLElement | Document} [parent]
 * @returns HTMLElement[]
 */
function getElementsFromOption(option, legacySelector, parent = document) {
  /** @type {HTMLElement[]} */
  let elements = [];

  if (option instanceof Element) {
    elements = [option];
  } else if (option instanceof NodeList || Array.isArray(option)) {
    elements = Array.from(option);
  } else {
    const selector = typeof option === 'string' ? option : legacySelector;
    if (selector) {
      elements = Array.from(parent.querySelectorAll(selector));
    }
  }

  return elements;
}

/**
 * Check if browser is Safari
 *
 * @returns {boolean}
 */
function isSafari() {
  return !!(navigator.vendor && navigator.vendor.match(/apple/i));
}

// Detect passive event listener support
let supportsPassive = false;
/* eslint-disable */
try {
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
    get: () => {
      supportsPassive = true;
    }
  }));
} catch (e) {}
/* eslint-enable */


/**
 * @typedef {Object} PoolItem
 * @prop {HTMLElement | Window | Document} target
 * @prop {string} type
 * @prop {(e: any) => void} listener
 * @prop {boolean} passive
 */

class DOMEvents {
  constructor() {
    /**
     * @type {PoolItem[]}
     * @private
     */
    this._pool = [];
  }

  /**
   * Adds event listeners
   *
   * @param {HTMLElement | Window | Document} target
   * @param {string} type Can be multiple, separated by space.
   * @param {(e: any) => void} listener
   * @param {boolean=} passive
   */
  add(target, type, listener, passive) {
    this._toggleListener(target, type, listener, passive);
  }

  /**
   * Removes event listeners
   *
   * @param {HTMLElement | Window | Document} target
   * @param {string} type
   * @param {(e: any) => void} listener
   * @param {boolean=} passive
   */
  remove(target, type, listener, passive) {
    this._toggleListener(target, type, listener, passive, true);
  }

  /**
   * Removes all bound events
   */
  removeAll() {
    this._pool.forEach((poolItem) => {
      this._toggleListener(
        poolItem.target,
        poolItem.type,
        poolItem.listener,
        poolItem.passive,
        true,
        true
      );
    });
    this._pool = [];
  }

  /**
   * Adds or removes event
   *
   * @param {HTMLElement | Window | Document} target
   * @param {string} type
   * @param {(e: any) => void} listener
   * @param {boolean} passive
   * @param {boolean=} unbind Whether the event should be added or removed
   * @param {boolean=} skipPool Whether events pool should be skipped
   */
  _toggleListener(target, type, listener, passive, unbind, skipPool) {
    if (!target) {
      return;
    }

    const methodName = unbind ? 'removeEventListener' : 'addEventListener';
    const types = type.split(' ');
    types.forEach((eType) => {
      if (eType) {
        // Events pool is used to easily unbind all events when PhotoSwipe is closed,
        // so developer doesn't need to do this manually
        if (!skipPool) {
          if (unbind) {
            // Remove from the events pool
            this._pool = this._pool.filter((poolItem) => {
              return poolItem.type !== eType
                || poolItem.listener !== listener
                || poolItem.target !== target;
            });
          } else {
            // Add to the events pool
            this._pool.push({
              target,
              type: eType,
              listener,
              passive
            });
          }
        }


        // most PhotoSwipe events call preventDefault,
        // and we do not need browser to scroll the page
        const eventOptions = supportsPassive ? { passive: (passive || false) } : false;

        target[methodName](
          eType,
          listener,
          eventOptions
        );
      }
    });
  }
}

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/**
 * @param {PhotoSwipeOptions} options
 * @param {PhotoSwipe} pswp
 */
function getViewportSize(options, pswp) {
  if (options.getViewportSizeFn) {
    const newViewportSize = options.getViewportSizeFn(options, pswp);
    if (newViewportSize) {
      return newViewportSize;
    }
  }

  return {
    x: document.documentElement.clientWidth,

    // TODO: height on mobile is very incosistent due to toolbar
    // find a way to improve this
    //
    // document.documentElement.clientHeight - doesn't seem to work well
    y: window.innerHeight
  };
}

/**
 * Parses padding option.
 * Supported formats:
 *
 * // Object
 * padding: {
 *  top: 0,
 *  bottom: 0,
 *  left: 0,
 *  right: 0
 * }
 *
 * // A function that returns the object
 * paddingFn: (viewportSize, itemData, index) => {
 *  return {
 *    top: 0,
 *    bottom: 0,
 *    left: 0,
 *    right: 0
 *  };
 * }
 *
 * // Legacy variant
 * paddingLeft: 0,
 * paddingRight: 0,
 * paddingTop: 0,
 * paddingBottom: 0,
 *
 * @param {'left' | 'top' | 'bottom' | 'right'} prop
 * @param {PhotoSwipeOptions} options PhotoSwipe options
 * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
 * @param {SlideData} itemData Data about the slide
 * @param {number} index Slide index
 * @returns {number}
 */
function parsePaddingOption(prop, options, viewportSize, itemData, index) {
  /** @type {number} */
  let paddingValue;

  if (options.paddingFn) {
    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
  } else if (options.padding) {
    paddingValue = options.padding[prop];
  } else {
    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);
    // @ts-expect-error
    if (options[legacyPropName]) {
      // @ts-expect-error
      paddingValue = options[legacyPropName];
    }
  }

  return paddingValue || 0;
}

/**
 * @param {PhotoSwipeOptions} options
 * @param {{ x?: number; y?: number }} viewportSize
 * @param {SlideData} itemData
 * @param {number} index
 */
function getPanAreaSize(options, viewportSize, itemData, index) {
  return {
    x: viewportSize.x
      - parsePaddingOption('left', options, viewportSize, itemData, index)
      - parsePaddingOption('right', options, viewportSize, itemData, index),
    y: viewportSize.y
      - parsePaddingOption('top', options, viewportSize, itemData, index)
      - parsePaddingOption('bottom', options, viewportSize, itemData, index)
  };
}

/** @typedef {import('./slide.js').default} Slide */
/** @typedef {{ x?: number; y?: number }} Point */
/** @typedef {'x' | 'y'} Axis */

/**
 * Calculates minimum, maximum and initial (center) bounds of a slide
 */
class PanBounds {
  /**
   * @param {Slide} slide
   */
  constructor(slide) {
    this.slide = slide;

    this.currZoomLevel = 1;

    /** @type {Point} */
    this.center = {};
    /** @type {Point} */
    this.max = {};
    /** @type {Point} */
    this.min = {};

    this.reset();
  }

  /**
   * _getItemBounds
   *
   * @param {number} currZoomLevel
   */
  update(currZoomLevel) {
    this.currZoomLevel = currZoomLevel;

    if (!this.slide.width) {
      this.reset();
    } else {
      this._updateAxis('x');
      this._updateAxis('y');
      this.slide.pswp.dispatch('calcBounds', { slide: this.slide });
    }
  }

  /**
   * _calculateItemBoundsForAxis
   *
   * @param {Axis} axis
   */
  _updateAxis(axis) {
    const { pswp } = this.slide;
    const elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;
    const paddingProp = axis === 'x' ? 'left' : 'top';
    const padding = parsePaddingOption(
      paddingProp,
      pswp.options,
      pswp.viewportSize,
      this.slide.data,
      this.slide.index
    );

    const panAreaSize = this.slide.panAreaSize[axis];

    // Default position of element.
    // By defaul it is center of viewport:
    this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding;

    // maximum pan position
    this.max[axis] = (elSize > panAreaSize)
      ? Math.round(panAreaSize - elSize) + padding
      : this.center[axis];

    // minimum pan position
    this.min[axis] = (elSize > panAreaSize)
      ? padding
      : this.center[axis];
  }

  // _getZeroBounds
  reset() {
    this.center.x = 0;
    this.center.y = 0;
    this.max.x = 0;
    this.max.y = 0;
    this.min.x = 0;
    this.min.y = 0;
  }

  /**
   * Correct pan position if it's beyond the bounds
   *
   * @param {Axis} axis x or y
   * @param {number} panOffset
   */
  correctPan(axis, panOffset) { // checkPanBounds
    return clamp(panOffset, this.max[axis], this.min[axis]);
  }
}

const MAX_IMAGE_WIDTH = 4000;

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

/**
 * Calculates zoom levels for specific slide.
 * Depends on viewport size and image size.
 */
class ZoomLevel {
  /**
   * @param {PhotoSwipeOptions} options PhotoSwipe options
   * @param {SlideData} itemData Slide data
   * @param {number} index Slide index
   * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet
   */
  constructor(options, itemData, index, pswp) {
    this.pswp = pswp;
    this.options = options;
    this.itemData = itemData;
    this.index = index;
  }

  /**
   * Calculate initial, secondary and maximum zoom level for the specified slide.
   *
   * It should be called when either image or viewport size changes.
   *
   * @param {number} maxWidth
   * @param {number} maxHeight
   * @param {{ x?: number; y?: number }} panAreaSize
   */
  update(maxWidth, maxHeight, panAreaSize) {
    this.elementSize = {
      x: maxWidth,
      y: maxHeight
    };

    this.panAreaSize = panAreaSize;

    const hRatio = this.panAreaSize.x / this.elementSize.x;
    const vRatio = this.panAreaSize.y / this.elementSize.y;

    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);

    // zoom.vFill defines zoom level of the image
    // when it has 100% of viewport vertical space (height)
    this.vFill = Math.min(1, vRatio);

    this.initial = this._getInitial();
    this.secondary = this._getSecondary();
    this.max = Math.max(
      this.initial,
      this.secondary,
      this._getMax()
    );

    this.min = Math.min(
      this.fit,
      this.initial,
      this.secondary
    );

    if (this.pswp) {
      this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });
    }
  }

  /**
   * Parses user-defined zoom option.
   *
   * @private
   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
   */
  _parseZoomLevelOption(optionPrefix) {
    // eslint-disable-next-line max-len
    const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (optionPrefix + 'ZoomLevel');
    const optionValue = this.options[optionName];

    if (!optionValue) {
      return;
    }

    if (typeof optionValue === 'function') {
      return optionValue(this);
    }

    if (optionValue === 'fill') {
      return this.fill;
    }

    if (optionValue === 'fit') {
      return this.fit;
    }

    return Number(optionValue);
  }

  /**
   * Get zoom level to which image will be zoomed after double-tap gesture,
   * or when user clicks on zoom icon,
   * or mouse-click on image itself.
   * If you return 1 image will be zoomed to its original size.
   *
   * @private
   * @return {number}
   */
  _getSecondary() {
    let currZoomLevel = this._parseZoomLevelOption('secondary');

    if (currZoomLevel) {
      return currZoomLevel;
    }

    // 3x of "fit" state, but not larger than original
    currZoomLevel = Math.min(1, this.fit * 3);

    if (currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
    }

    return currZoomLevel;
  }

  /**
   * Get initial image zoom level.
   *
   * @private
   * @return {number}
   */
  _getInitial() {
    return this._parseZoomLevelOption('initial') || this.fit;
  }

  /**
   * Maximum zoom level when user zooms
   * via zoom/pinch gesture,
   * via cmd/ctrl-wheel or via trackpad.
   *
   * @private
   * @return {number}
   */
  _getMax() {
    const currZoomLevel = this._parseZoomLevelOption('max');

    if (currZoomLevel) {
      return currZoomLevel;
    }

    // max zoom level is x4 from "fit state",
    // used for zoom gesture and ctrl/trackpad zoom
    return Math.max(1, this.fit * 4);
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 * Renders and allows to control a single slide
 */
class Slide {
  /**
   * @param {SlideData} data
   * @param {number} index
   * @param {PhotoSwipe} pswp
   */
  constructor(data, index, pswp) {
    this.data = data;
    this.index = index;
    this.pswp = pswp;
    this.isActive = (index === pswp.currIndex);
    this.currentResolution = 0;
    /** @type {Point} */
    this.panAreaSize = {};

    this.isFirstSlide = (this.isActive && !pswp.opener.isOpen);

    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);

    this.pswp.dispatch('gettingData', {
      slide: this,
      data: this.data,
      index
    });

    this.pan = {
      x: 0,
      y: 0
    };

    this.content = this.pswp.contentLoader.getContentBySlide(this);
    this.container = createElement('pswp__zoom-wrap');

    this.currZoomLevel = 1;
    /** @type {number} */
    this.width = this.content.width;
    /** @type {number} */
    this.height = this.content.height;

    this.bounds = new PanBounds(this);

    this.prevDisplayedWidth = -1;
    this.prevDisplayedHeight = -1;

    this.pswp.dispatch('slideInit', { slide: this });
  }

  /**
   * If this slide is active/current/visible
   *
   * @param {boolean} isActive
   */
  setIsActive(isActive) {
    if (isActive && !this.isActive) {
      // slide just became active
      this.activate();
    } else if (!isActive && this.isActive) {
      // slide just became non-active
      this.deactivate();
    }
  }

  /**
   * Appends slide content to DOM
   *
   * @param {HTMLElement} holderElement
   */
  append(holderElement) {
    this.holderElement = holderElement;

    this.container.style.transformOrigin = '0 0';

    // Slide appended to DOM
    if (!this.data) {
      return;
    }

    this.calculateSize();

    this.load();
    this.updateContentSize();
    this.appendHeavy();

    this.holderElement.appendChild(this.container);

    this.zoomAndPanToInitial();

    this.pswp.dispatch('firstZoomPan', { slide: this });

    this.applyCurrentZoomPan();

    this.pswp.dispatch('afterSetContent', { slide: this });

    if (this.isActive) {
      this.activate();
    }
  }

  load() {
    this.content.load();
    this.pswp.dispatch('slideLoad', { slide: this });
  }

  /**
   * Append "heavy" DOM elements
   *
   * This may depend on a type of slide,
   * but generally these are large images.
   */
  appendHeavy() {
    const { pswp } = this;
    const appendHeavyNearby = true; // todo

    // Avoid appending heavy elements during animations
    if (this.heavyAppended
        || !pswp.opener.isOpen
        || pswp.mainScroll.isShifted()
        || (!this.isActive && !appendHeavyNearby)) {
      return;
    }

    if (this.pswp.dispatch('appendHeavy', { slide: this }).defaultPrevented) {
      return;
    }

    this.heavyAppended = true;

    this.content.append();

    this.pswp.dispatch('appendHeavyContent', { slide: this });
  }

  /**
   * Triggered when this slide is active (selected).
   *
   * If it's part of opening/closing transition -
   * activate() will trigger after the transition is ended.
   */
  activate() {
    this.isActive = true;
    this.appendHeavy();
    this.content.activate();
    this.pswp.dispatch('slideActivate', { slide: this });
  }

  /**
   * Triggered when this slide becomes inactive.
   *
   * Slide can become inactive only after it was active.
   */
  deactivate() {
    this.isActive = false;
    this.content.deactivate();

    if (this.currZoomLevel !== this.zoomLevels.initial) {
      // allow filtering
      this.calculateSize();
    }

    // reset zoom level
    this.currentResolution = 0;
    this.zoomAndPanToInitial();
    this.applyCurrentZoomPan();
    this.updateContentSize();

    this.pswp.dispatch('slideDeactivate', { slide: this });
  }

  /**
   * The slide should destroy itself, it will never be used again.
   * (unbind all events and destroy internal components)
   */
  destroy() {
    this.content.hasSlide = false;
    this.content.remove();
    this.container.remove();
    this.pswp.dispatch('slideDestroy', { slide: this });
  }

  resize() {
    if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
      // Keep initial zoom level if it was before the resize,
      // as well as when this slide is not active

      // Reset position and scale to original state
      this.calculateSize();
      this.currentResolution = 0;
      this.zoomAndPanToInitial();
      this.applyCurrentZoomPan();
      this.updateContentSize();
    } else {
      // readjust pan position if it's beyond the bounds
      this.calculateSize();
      this.bounds.update(this.currZoomLevel);
      this.panTo(this.pan.x, this.pan.y);
    }
  }


  /**
   * Apply size to current slide content,
   * based on the current resolution and scale.
   *
   * @param {boolean=} force if size should be updated even if dimensions weren't changed
   */
  updateContentSize(force) {
    // Use initial zoom level
    // if resolution is not defined (user didn't zoom yet)
    const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;

    if (!scaleMultiplier) {
      return;
    }

    const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
    const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;

    if (!this.sizeChanged(width, height) && !force) {
      return;
    }
    this.content.setDisplayedSize(width, height);
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  sizeChanged(width, height) {
    if (width !== this.prevDisplayedWidth
        || height !== this.prevDisplayedHeight) {
      this.prevDisplayedWidth = width;
      this.prevDisplayedHeight = height;
      return true;
    }

    return false;
  }

  getPlaceholderElement() {
    if (this.content.placeholder) {
      return this.content.placeholder.element;
    }
  }

  /**
   * Zoom current slide image to...
   *
   * @param {number} destZoomLevel Destination zoom level.
   * @param {{ x?: number; y?: number }} centerPoint
   * Transform origin center point, or false if viewport center should be used.
   * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
   * @param {boolean=} ignoreBounds Minimum and maximum zoom levels will be ignored.
   * @return {boolean=} Returns true if animated.
   */
  zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
    const { pswp } = this;
    if (!this.isZoomable()
        || pswp.mainScroll.isShifted()) {
      return;
    }

    pswp.dispatch('beforeZoomTo', {
      destZoomLevel, centerPoint, transitionDuration
    });

    // stop all pan and zoom transitions
    pswp.animations.stopAllPan();

    // if (!centerPoint) {
    //   centerPoint = pswp.getViewportCenterPoint();
    // }

    const prevZoomLevel = this.currZoomLevel;

    if (!ignoreBounds) {
      destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
    }

    // if (transitionDuration === undefined) {
    //   transitionDuration = this.pswp.options.zoomAnimationDuration;
    // }

    this.setZoomLevel(destZoomLevel);
    this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);
    this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);
    roundPoint(this.pan);

    const finishTransition = () => {
      this._setResolution(destZoomLevel);
      this.applyCurrentZoomPan();
    };

    if (!transitionDuration) {
      finishTransition();
    } else {
      pswp.animations.startTransition({
        isPan: true,
        name: 'zoomTo',
        target: this.container,
        transform: this.getCurrentTransform(),
        onComplete: finishTransition,
        duration: transitionDuration,
        easing: pswp.options.easing
      });
    }
  }

  /**
   * @param {{ x?: number, y?: number }} [centerPoint]
   */
  toggleZoom(centerPoint) {
    this.zoomTo(
      this.currZoomLevel === this.zoomLevels.initial
        ? this.zoomLevels.secondary : this.zoomLevels.initial,
      centerPoint,
      this.pswp.options.zoomAnimationDuration
    );
  }

  /**
   * Updates zoom level property and recalculates new pan bounds,
   * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
   *
   * @param {number} currZoomLevel
   */
  setZoomLevel(currZoomLevel) {
    this.currZoomLevel = currZoomLevel;
    this.bounds.update(this.currZoomLevel);
  }

  /**
   * Get pan position after zoom at a given `point`.
   *
   * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
   * pan bounds according to the new zoom level.
   *
   * @param {'x' | 'y'} axis
   * @param {{ x?: number; y?: number }} [point]
   * point based on which zoom is performed, usually refers to the current mouse position,
   * if false - viewport center will be used.
   * @param {number=} prevZoomLevel Zoom level before new zoom was applied.
   */
  calculateZoomToPanOffset(axis, point, prevZoomLevel) {
    const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
    if (totalPanDistance === 0) {
      return this.bounds.center[axis];
    }

    if (!point) {
      point = this.pswp.getViewportCenterPoint();
    }

    const zoomFactor = this.currZoomLevel / prevZoomLevel;
    return this.bounds.correctPan(
      axis,
      (this.pan[axis] - point[axis]) * zoomFactor + point[axis]
    );
  }

  /**
   * Apply pan and keep it within bounds.
   *
   * @param {number} panX
   * @param {number} panY
   */
  panTo(panX, panY) {
    this.pan.x = this.bounds.correctPan('x', panX);
    this.pan.y = this.bounds.correctPan('y', panY);
    this.applyCurrentZoomPan();
  }

  /**
   * If the slide in the current state can be panned by the user
   */
  isPannable() {
    return this.width && (this.currZoomLevel > this.zoomLevels.fit);
  }

  /**
   * If the slide can be zoomed
   */
  isZoomable() {
    return this.width && this.content.isZoomable();
  }

  /**
   * Apply transform and scale based on
   * the current pan position (this.pan) and zoom level (this.currZoomLevel)
   */
  applyCurrentZoomPan() {
    this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
    if (this === this.pswp.currSlide) {
      this.pswp.dispatch('zoomPanUpdate', { slide: this });
    }
  }

  zoomAndPanToInitial() {
    this.currZoomLevel = this.zoomLevels.initial;

    // pan according to the zoom level
    this.bounds.update(this.currZoomLevel);
    equalizePoints(this.pan, this.bounds.center);
    this.pswp.dispatch('initialZoomPan', { slide: this });
  }

  /**
   * Set translate and scale based on current resolution
   *
   * @param {number} x
   * @param {number} y
   * @param {number} zoom
   */
  _applyZoomTransform(x, y, zoom) {
    zoom /= this.currentResolution || this.zoomLevels.initial;
    setTransform(this.container, x, y, zoom);
  }

  calculateSize() {
    const { pswp } = this;

    equalizePoints(
      this.panAreaSize,
      getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index)
    );

    this.zoomLevels.update(this.width, this.height, this.panAreaSize);

    pswp.dispatch('calcSlideSize', {
      slide: this
    });
  }

  getCurrentTransform() {
    const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
    return toTransformString(this.pan.x, this.pan.y, scale);
  }

  /**
   * Set resolution and re-render the image.
   *
   * For example, if the real image size is 2000x1500,
   * and resolution is 0.5 - it will be rendered as 1000x750.
   *
   * Image with zoom level 2 and resolution 0.5 is
   * the same as image with zoom level 1 and resolution 1.
   *
   * Used to optimize animations and make
   * sure that browser renders image in highest quality.
   * Also used by responsive images to load the correct one.
   *
   * @param {number} newResolution
   */
  _setResolution(newResolution) {
    if (newResolution === this.currentResolution) {
      return;
    }

    this.currentResolution = newResolution;
    this.updateContentSize();

    this.pswp.dispatch('resolutionChanged');
  }
}

/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */

const PAN_END_FRICTION = 0.35;
const VERTICAL_DRAG_FRICTION = 0.6;

// 1 corresponds to the third of viewport height
const MIN_RATIO_TO_CLOSE = 0.4;

// Minimum speed required to navigate
// to next or previous slide
const MIN_NEXT_SLIDE_SPEED = 0.5;

/**
 * @param {number} initialVelocity
 * @param {number} decelerationRate
 */
function project(initialVelocity, decelerationRate) {
  return initialVelocity * decelerationRate / (1 - decelerationRate);
}

/**
 * Handles single pointer dragging
 */
class DragHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
    this.pswp = gestures.pswp;
    /** @type {Point} */
    this.startPan = {};
  }

  start() {
    equalizePoints(this.startPan, this.pswp.currSlide.pan);
    this.pswp.animations.stopAll();
  }

  change() {
    const { p1, prevP1, dragAxis, pswp } = this.gestures;
    const { currSlide } = pswp;

    if (dragAxis === 'y'
        && pswp.options.closeOnVerticalDrag
        && currSlide.currZoomLevel <= currSlide.zoomLevels.fit
        && !this.gestures.isMultitouch) {
      // Handle vertical drag to close
      const panY = currSlide.pan.y + (p1.y - prevP1.y);
      if (!pswp.dispatch('verticalDrag', { panY }).defaultPrevented) {
        this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);
        const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
        pswp.applyBgOpacity(bgOpacity);
        currSlide.applyCurrentZoomPan();
      }
    } else {
      const mainScrollChanged = this._panOrMoveMainScroll('x');
      if (!mainScrollChanged) {
        this._panOrMoveMainScroll('y');

        roundPoint(currSlide.pan);
        currSlide.applyCurrentZoomPan();
      }
    }
  }

  end() {
    const { pswp, velocity } = this.gestures;
    const { mainScroll } = pswp;
    let indexDiff = 0;

    pswp.animations.stopAll();

    // Handle main scroll if it's shifted
    if (mainScroll.isShifted()) {
      // Position of the main scroll relative to the viewport
      const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX();

      // Ratio between 0 and 1:
      // 0 - slide is not visible at all,
      // 0.5 - half of the slide is vicible
      // 1 - slide is fully visible
      const currentSlideVisibilityRatio = (mainScrollShiftDiff / pswp.viewportSize.x);

      // Go next slide.
      //
      // - if velocity and its direction is matched
      //   and we see at least tiny part of the next slide
      //
      // - or if we see less than 50% of the current slide
      //   and velocity is close to 0
      //
      if ((velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0)
          || (velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5)) {
        // Go to next slide
        indexDiff = 1;
        velocity.x = Math.min(velocity.x, 0);
      } else if ((velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0)
          || (velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5)) {
        // Go to prev slide
        indexDiff = -1;
        velocity.x = Math.max(velocity.x, 0);
      }

      mainScroll.moveIndexBy(indexDiff, true, velocity.x);
    }

    // Restore zoom level
    if (pswp.currSlide.currZoomLevel > pswp.currSlide.zoomLevels.max
        || this.gestures.isMultitouch) {
      this.gestures.zoomLevels.correctZoomPan(true);
    } else {
      // we run two animations instead of one,
      // as each axis has own pan boundaries and thus different spring function
      // (correctZoomPan does not have this functionality,
      //  it animates all properties with single timing function)
      this._finishPanGestureForAxis('x');
      this._finishPanGestureForAxis('y');
    }
  }

  /**
   * @private
   * @param {'x' | 'y'} axis
   */
  _finishPanGestureForAxis(axis) {
    const { pswp } = this;
    const { currSlide } = pswp;
    const { velocity } = this.gestures;
    const { pan, bounds } = currSlide;
    const panPos = pan[axis];
    const restoreBgOpacity = (pswp.bgOpacity < 1 && axis === 'y');

    // 0.995 means - scroll view loses 0.5% of its velocity per millisecond
    // Inceasing this number will reduce travel distance
    const decelerationRate = 0.995; // 0.99

    // Pan position if there is no bounds
    const projectedPosition = panPos + project(velocity[axis], decelerationRate);

    if (restoreBgOpacity) {
      const vDragRatio = this._getVerticalDragRatio(panPos);
      const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);

      // If we are above and moving upwards,
      // or if we are below and moving downwards
      if ((vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE)
          || (vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE)) {
        pswp.close();
        return;
      }
    }

    // Pan position with corrected bounds
    const correctedPanPosition = bounds.correctPan(axis, projectedPosition);

    // Exit if pan position should not be changed
    // or if speed it too low
    if (panPos === correctedPanPosition) {
      return;
    }

    // Overshoot if the final position is out of pan bounds
    const dampingRatio = (correctedPanPosition === projectedPosition) ? 1 : 0.82;

    const initialBgOpacity = pswp.bgOpacity;
    const totalPanDist = correctedPanPosition - panPos;

    pswp.animations.startSpring({
      name: 'panGesture' + axis,
      isPan: true,
      start: panPos,
      end: correctedPanPosition,
      velocity: velocity[axis],
      dampingRatio,
      onUpdate: (pos) => {
        // Animate opacity of background relative to Y pan position of an image
        if (restoreBgOpacity && pswp.bgOpacity < 1) {
          // 0 - start of animation, 1 - end of animation
          const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;

          // We clamp opacity to keep it between 0 and 1.
          // As progress ratio can be larger than 1 due to overshoot,
          // and we do not want to bounce opacity.
          pswp.applyBgOpacity(clamp(
            initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio,
            0,
            1
          ));
        }

        pan[axis] = Math.floor(pos);
        currSlide.applyCurrentZoomPan();
      },
    });
  }

  /**
   * Update position of the main scroll,
   * or/and update pan position of the current slide.
   *
   * Should return true if it changes (or can change) main scroll.
   *
   * @private
   * @param {'x' | 'y'} axis
   */
  _panOrMoveMainScroll(axis) {
    const { p1, pswp, dragAxis, prevP1, isMultitouch } = this.gestures;
    const { currSlide, mainScroll } = pswp;
    const delta = (p1[axis] - prevP1[axis]);
    const newMainScrollX = mainScroll.x + delta;

    if (!delta) {
      return;
    }

    // Always move main scroll if image can not be panned
    if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {
      mainScroll.moveTo(newMainScrollX, true);
      return true; // changed main scroll
    }

    const { bounds } = currSlide;
    const newPan = currSlide.pan[axis] + delta;

    if (pswp.options.allowPanToNext
        && dragAxis === 'x'
        && axis === 'x'
        && !isMultitouch) {
      const currSlideMainScrollX = mainScroll.getCurrSlideX();

      // Position of the main scroll relative to the viewport
      const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;

      const isLeftToRight = delta > 0;
      const isRightToLeft = !isLeftToRight;

      if (newPan > bounds.min[axis] && isLeftToRight) {
        // Panning from left to right, beyond the left edge

        // Wether the image was at minimum pan position (or less)
        // when this drag gesture started.
        // Minimum pan position refers to the left edge of the image.
        const wasAtMinPanPosition = (bounds.min[axis] <= this.startPan[axis]);

        if (wasAtMinPanPosition) {
          mainScroll.moveTo(newMainScrollX, true);
          return true;
        } else {
          this._setPanWithFriction(axis, newPan);
          //currSlide.pan[axis] = newPan;
        }
      } else if (newPan < bounds.max[axis] && isRightToLeft) {
        // Paning from right to left, beyond the right edge

        // Maximum pan position refers to the right edge of the image.
        const wasAtMaxPanPosition = (this.startPan[axis] <= bounds.max[axis]);

        if (wasAtMaxPanPosition) {
          mainScroll.moveTo(newMainScrollX, true);
          return true;
        } else {
          this._setPanWithFriction(axis, newPan);
          //currSlide.pan[axis] = newPan;
        }
      } else {
        // If main scroll is shifted
        if (mainScrollShiftDiff !== 0) {
          // If main scroll is shifted right
          if (mainScrollShiftDiff > 0 /*&& isRightToLeft*/) {
            mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
            return true;
          } else if (mainScrollShiftDiff < 0 /*&& isLeftToRight*/) {
            // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)
            mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
            return true;
          }
        } else {
          // We are within pan bounds, so just pan
          this._setPanWithFriction(axis, newPan);
        }
      }
    } else {
      if (axis === 'y') {
        // Do not pan vertically if main scroll is shifted o
        if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
          this._setPanWithFriction(axis, newPan);
        }
      } else {
        this._setPanWithFriction(axis, newPan);
      }
    }
  }
  //
  // If we move above - the ratio is negative
  // If we move below the ratio is positive

  /**
   * Relation between pan Y position and third of viewport height.
   *
   * When we are at initial position (center bounds) - the ratio is 0,
   * if position is shifted upwards - the ratio is negative,
   * if position is shifted downwards - the ratio is positive.
   *
   * @private
   * @param {number} panY The current pan Y position.
   */
  _getVerticalDragRatio(panY) {
    return (panY - this.pswp.currSlide.bounds.center.y)
            / (this.pswp.viewportSize.y / 3);
  }

  /**
   * Set pan position of the current slide.
   * Apply friction if the position is beyond the pan bounds,
   * or if custom friction is defined.
   *
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} potentialPan
   * @param {number=} customFriction (0.1 - 1)
   */
  _setPanWithFriction(axis, potentialPan, customFriction) {
    const { pan, bounds } = this.pswp.currSlide;
    const correctedPan = bounds.correctPan(axis, potentialPan);
    // If we are out of pan bounds
    if (correctedPan !== potentialPan || customFriction) {
      const delta = Math.round(potentialPan - pan[axis]);
      pan[axis] += delta * (customFriction || PAN_END_FRICTION);
    } else {
      pan[axis] = potentialPan;
    }
  }
}

/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */

const UPPER_ZOOM_FRICTION = 0.05;
const LOWER_ZOOM_FRICTION = 0.15;


/**
 * Get center point between two points
 *
 * @param {Point} p
 * @param {Point} p1
 * @param {Point} p2
 */
function getZoomPointsCenter(p, p1, p2) {
  p.x = (p1.x + p2.x) / 2;
  p.y = (p1.y + p2.y) / 2;
  return p;
}

class ZoomHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
    this.pswp = this.gestures.pswp;
    /** @type {Point} */
    this._startPan = {};

    /** @type {Point} */
    this._startZoomPoint = {};
    /** @type {Point} */
    this._zoomPoint = {};
  }

  start() {
    this._startZoomLevel = this.pswp.currSlide.currZoomLevel;
    equalizePoints(this._startPan, this.pswp.currSlide.pan);
    this.pswp.animations.stopAllPan();
    this._wasOverFitZoomLevel = false;
  }

  change() {
    const { p1, startP1, p2, startP2, pswp } = this.gestures;
    const { currSlide } = pswp;
    const minZoomLevel = currSlide.zoomLevels.min;
    const maxZoomLevel = currSlide.zoomLevels.max;

    if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
      return;
    }

    getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
    getZoomPointsCenter(this._zoomPoint, p1, p2);

    let currZoomLevel = (1 / getDistanceBetween(startP1, startP2))
                      * getDistanceBetween(p1, p2)
                      * this._startZoomLevel;

    // slightly over the zoom.fit
    if (currZoomLevel > currSlide.zoomLevels.initial + (currSlide.zoomLevels.initial / 15)) {
      this._wasOverFitZoomLevel = true;
    }

    if (currZoomLevel < minZoomLevel) {
      if (pswp.options.pinchToClose
          && !this._wasOverFitZoomLevel
          && this._startZoomLevel <= currSlide.zoomLevels.initial) {
        // fade out background if zooming out
        const bgOpacity = 1 - ((minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2));
        if (!pswp.dispatch('pinchClose', { bgOpacity }).defaultPrevented) {
          pswp.applyBgOpacity(bgOpacity);
        }
      } else {
        // Apply the friction if zoom level is below the min
        currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
      }
    } else if (currZoomLevel > maxZoomLevel) {
      // Apply the friction if zoom level is above the max
      currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
    }

    currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);
    currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);

    currSlide.setZoomLevel(currZoomLevel);
    currSlide.applyCurrentZoomPan();
  }

  end() {
    const { pswp } = this;
    const { currSlide } = pswp;
    if (currSlide.currZoomLevel < currSlide.zoomLevels.initial
        && !this._wasOverFitZoomLevel
        && pswp.options.pinchToClose) {
      pswp.close();
    } else {
      this.correctZoomPan();
    }
  }

  /**
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} currZoomLevel
   */
  _calculatePanForZoomLevel(axis, currZoomLevel) {
    const zoomFactor = currZoomLevel / this._startZoomLevel;
    return this._zoomPoint[axis]
            - ((this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor);
  }

  /**
   * Correct currZoomLevel and pan if they are
   * beyond minimum or maximum values.
   * With animation.
   *
   * @param {boolean=} ignoreGesture
   * Wether gesture coordinates should be ignored when calculating destination pan position.
   */
  correctZoomPan(ignoreGesture) {
    const { pswp } = this;
    const { currSlide } = pswp;

    if (!currSlide.isZoomable()) {
      return;
    }

    if (this._zoomPoint.x === undefined) {
      ignoreGesture = true;
    }

    const prevZoomLevel = currSlide.currZoomLevel;

    /** @type {number} */
    let destinationZoomLevel;
    let currZoomLevelNeedsChange = true;

    if (prevZoomLevel < currSlide.zoomLevels.initial) {
      destinationZoomLevel = currSlide.zoomLevels.initial;
      // zoom to min
    } else if (prevZoomLevel > currSlide.zoomLevels.max) {
      destinationZoomLevel = currSlide.zoomLevels.max;
      // zoom to max
    } else {
      currZoomLevelNeedsChange = false;
      destinationZoomLevel = prevZoomLevel;
    }

    const initialBgOpacity = pswp.bgOpacity;
    const restoreBgOpacity = pswp.bgOpacity < 1;

    const initialPan = equalizePoints({}, currSlide.pan);
    let destinationPan = equalizePoints({}, initialPan);

    if (ignoreGesture) {
      this._zoomPoint.x = 0;
      this._zoomPoint.y = 0;
      this._startZoomPoint.x = 0;
      this._startZoomPoint.y = 0;
      this._startZoomLevel = prevZoomLevel;
      equalizePoints(this._startPan, initialPan);
    }

    if (currZoomLevelNeedsChange) {
      destinationPan = {
        x: this._calculatePanForZoomLevel('x', destinationZoomLevel),
        y: this._calculatePanForZoomLevel('y', destinationZoomLevel)
      };
    }

    // set zoom level, so pan bounds are updated according to it
    currSlide.setZoomLevel(destinationZoomLevel);

    destinationPan = {
      x: currSlide.bounds.correctPan('x', destinationPan.x),
      y: currSlide.bounds.correctPan('y', destinationPan.y)
    };

    // return zoom level and its bounds to initial
    currSlide.setZoomLevel(prevZoomLevel);

    let panNeedsChange = true;
    if (pointsEqual(destinationPan, initialPan)) {
      panNeedsChange = false;
    }

    if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
      // update resolution after gesture
      currSlide._setResolution(destinationZoomLevel);
      currSlide.applyCurrentZoomPan();

      // nothing to animate
      return;
    }

    pswp.animations.stopAllPan();

    pswp.animations.startSpring({
      isPan: true,
      start: 0,
      end: 1000,
      velocity: 0,
      dampingRatio: 1,
      naturalFrequency: 40,
      onUpdate: (now) => {
        now /= 1000; // 0 - start, 1 - end

        if (panNeedsChange || currZoomLevelNeedsChange) {
          if (panNeedsChange) {
            currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
            currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
          }

          if (currZoomLevelNeedsChange) {
            const newZoomLevel = prevZoomLevel
                        + (destinationZoomLevel - prevZoomLevel) * now;
            currSlide.setZoomLevel(newZoomLevel);
          }

          currSlide.applyCurrentZoomPan();
        }

        // Restore background opacity
        if (restoreBgOpacity && pswp.bgOpacity < 1) {
          // We clamp opacity to keep it between 0 and 1.
          // As progress ratio can be larger than 1 due to overshoot,
          // and we do not want to bounce opacity.
          pswp.applyBgOpacity(clamp(
            initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1
          ));
        }
      },
      onComplete: () => {
        // update resolution after transition ends
        currSlide._setResolution(destinationZoomLevel);
        currSlide.applyCurrentZoomPan();
      }
    });
  }
}

/**
 * @template T
 * @template P
 * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
 */

/** @typedef {import('./gestures.js').default} Gestures */

/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */
/** @typedef {{ x?: number; y?: number }} Point */

/**
 * Whether the tap was performed on the main slide
 * (rather than controls or caption).
 *
 * @param {PointerEvent} event
 */
function didTapOnMainContent(event) {
  return !!(/** @type {HTMLElement} */ (event.target).closest('.pswp__container'));
}

/**
 * Tap, double-tap handler.
 */
class TapHandler {
  /**
   * @param {Gestures} gestures
   */
  constructor(gestures) {
    this.gestures = gestures;
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  click(point, originalEvent) {
    const targetClassList = /** @type {HTMLElement} */ (originalEvent.target).classList;
    const isImageClick = targetClassList.contains('pswp__img');
    const isBackgroundClick = targetClassList.contains('pswp__item')
                              || targetClassList.contains('pswp__zoom-wrap');

    if (isImageClick) {
      this._doClickOrTapAction('imageClick', point, originalEvent);
    } else if (isBackgroundClick) {
      this._doClickOrTapAction('bgClick', point, originalEvent);
    }
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  tap(point, originalEvent) {
    if (didTapOnMainContent(originalEvent)) {
      this._doClickOrTapAction('tap', point, originalEvent);
    }
  }

  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  doubleTap(point, originalEvent) {
    if (didTapOnMainContent(originalEvent)) {
      this._doClickOrTapAction('doubleTap', point, originalEvent);
    }
  }

  /**
   * @param {Actions} actionName
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  _doClickOrTapAction(actionName, point, originalEvent) {
    const { pswp } = this.gestures;
    const { currSlide } = pswp;
    const actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */ (actionName + 'Action');
    const optionValue = pswp.options[actionFullName];

    if (pswp.dispatch(actionFullName, { point, originalEvent }).defaultPrevented) {
      return;
    }

    if (typeof optionValue === 'function') {
      optionValue.call(pswp, point, originalEvent);
      return;
    }

    switch (optionValue) {
      case 'close':
      case 'next':
        pswp[optionValue]();
        break;
      case 'zoom':
        currSlide.toggleZoom(point);
        break;
      case 'zoom-or-close':
        // by default click zooms current image,
        // if it can not be zoomed - gallery will be closed
        if (currSlide.isZoomable()
            && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
          currSlide.toggleZoom(point);
        } else if (pswp.options.clickToCloseNonZoomable) {
          pswp.close();
        }
        break;
      case 'toggle-controls':
        this.gestures.pswp.element.classList.toggle('pswp--ui-visible');
        // if (_controlsVisible) {
        //   _ui.hideControls();
        // } else {
        //   _ui.showControls();
        // }
        break;
    }
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').Point} Point */

// How far should user should drag
// until we can determine that the gesture is swipe and its direction
const AXIS_SWIPE_HYSTERISIS = 10;
//const PAN_END_FRICTION = 0.35;

const DOUBLE_TAP_DELAY = 300; // ms
const MIN_TAP_DISTANCE = 25; // px

/**
 * Gestures class bind touch, pointer or mouse events
 * and emits drag to drag-handler and zoom events zoom-handler.
 *
 * Drag and zoom events are emited in requestAnimationFrame,
 * and only when one of pointers was actually changed.
 */
class Gestures {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;

    /** @type {'x' | 'y'} */
    this.dragAxis = undefined;

    // point objects are defined once and reused
    // PhotoSwipe keeps track only of two pointers, others are ignored
    /** @type {Point} */
    this.p1 = {}; // the first pressed pointer
    /** @type {Point} */
    this.p2 = {}; // the second pressed pointer
    /** @type {Point} */
    this.prevP1 = {};
    /** @type {Point} */
    this.prevP2 = {};
    /** @type {Point} */
    this.startP1 = {};
    /** @type {Point} */
    this.startP2 = {};
    /** @type {Point} */
    this.velocity = {};

    /** @type {Point} */
    this._lastStartP1 = {};
    /** @type {Point} */
    this._intervalP1 = {};
    this._numActivePoints = 0;
    /** @type {Point[]} */
    this._ongoingPointers = [];

    this._touchEventEnabled = 'ontouchstart' in window;
    this._pointerEventEnabled = !!(window.PointerEvent);
    this.supportsTouch = this._touchEventEnabled
                          || (this._pointerEventEnabled && navigator.maxTouchPoints > 1);

    if (!this.supportsTouch) {
      // disable pan to next slide for non-touch devices
      pswp.options.allowPanToNext = false;
    }

    this.drag = new DragHandler(this);
    this.zoomLevels = new ZoomHandler(this);
    this.tapHandler = new TapHandler(this);

    pswp.on('bindEvents', () => {
      pswp.events.add(pswp.scrollWrap, 'click', e => this._onClick(e));

      if (this._pointerEventEnabled) {
        this._bindEvents('pointer', 'down', 'up', 'cancel');
      } else if (this._touchEventEnabled) {
        this._bindEvents('touch', 'start', 'end', 'cancel');

        // In previous versions we also bound mouse event here,
        // in case device supports both touch and mouse events,
        // but newer versions of browsers now support PointerEvent.

        // on iOS10 if you bind touchmove/end after touchstart,
        // and you don't preventDefault touchstart (which PhotoSwipe does),
        // preventDefault will have no effect on touchmove and touchend.
        // Unless you bind it previously.
        pswp.scrollWrap.ontouchmove = () => {}; // eslint-disable-line
        pswp.scrollWrap.ontouchend = () => {}; // eslint-disable-line
      } else {
        this._bindEvents('mouse', 'down', 'up');
      }
    });
  }

  /**
   *
   * @param {'mouse' | 'touch' | 'pointer'} pref
   * @param {'down' | 'start'} down
   * @param {'up' | 'end'} up
   * @param {'cancel'} [cancel]
   */
  _bindEvents(pref, down, up, cancel) {
    const { pswp } = this;
    const { events } = pswp;

    const cancelEvent = cancel ? pref + cancel : '';

    events.add(pswp.scrollWrap, pref + down, this.onPointerDown.bind(this));
    events.add(window, pref + 'move', this.onPointerMove.bind(this));
    events.add(window, pref + up, this.onPointerUp.bind(this));
    if (cancelEvent) {
      events.add(pswp.scrollWrap, cancelEvent, this.onPointerUp.bind(this));
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerDown(e) {
    // We do not call preventDefault for touch events
    // to allow browser to show native dialog on longpress
    // (the one that allows to save image or open it in new tab).
    //
    // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,
    // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.
    let isMousePointer;
    if (e.type === 'mousedown' || e.pointerType === 'mouse') {
      isMousePointer = true;
    }

    // Allow dragging only via left mouse button.
    // http://www.quirksmode.org/js/events_properties.html
    // https://developer.mozilla.org/en-US/docs/Web/API/event.button
    if (isMousePointer && e.button > 0) {
      return;
    }

    const { pswp } = this;

    // if PhotoSwipe is opening or closing
    if (!pswp.opener.isOpen) {
      e.preventDefault();
      return;
    }

    if (pswp.dispatch('pointerDown', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (isMousePointer) {
      pswp.mouseDetected();

      // preventDefault mouse event to prevent
      // browser image drag feature
      this._preventPointerEventBehaviour(e);
    }

    pswp.animations.stopAll();

    this._updatePoints(e, 'down');

    this.pointerDown = true;

    if (this._numActivePoints === 1) {
      this.dragAxis = null;
      // we need to store initial point to determine the main axis,
      // drag is activated only after the axis is determined
      equalizePoints(this.startP1, this.p1);
    }

    if (this._numActivePoints > 1) {
      // Tap or double tap should not trigger if more than one pointer
      this._clearTapTimer();
      this.isMultitouch = true;
    } else {
      this.isMultitouch = false;
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerMove(e) {
    e.preventDefault(); // always preventDefault move event

    if (!this._numActivePoints) {
      return;
    }

    this._updatePoints(e, 'move');

    if (this.pswp.dispatch('pointerMove', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (this._numActivePoints === 1 && !this.isDragging) {
      if (!this.dragAxis) {
        this._calculateDragDirection();
      }

      // Drag axis was detected, emit drag.start
      if (this.dragAxis && !this.isDragging) {
        if (this.isZooming) {
          this.isZooming = false;
          this.zoomLevels.end();
        }

        this.isDragging = true;
        this._clearTapTimer(); // Tap can not trigger after drag

        // Adjust starting point
        this._updateStartPoints();
        this._intervalTime = Date.now();
        //this._startTime = this._intervalTime;
        this._velocityCalculated = false;
        equalizePoints(this._intervalP1, this.p1);
        this.velocity.x = 0;
        this.velocity.y = 0;
        this.drag.start();

        this._rafStopLoop();
        this._rafRenderLoop();
      }
    } else if (this._numActivePoints > 1 && !this.isZooming) {
      this._finishDrag();

      this.isZooming = true;

      // Adjust starting points
      this._updateStartPoints();

      this.zoomLevels.start();

      this._rafStopLoop();
      this._rafRenderLoop();
    }
  }

  /**
   * @private
   */
  _finishDrag() {
    if (this.isDragging) {
      this.isDragging = false;

      // Try to calculate velocity,
      // if it wasn't calculated yet in drag.change
      if (!this._velocityCalculated) {
        this._updateVelocity(true);
      }

      this.drag.end();
      this.dragAxis = null;
    }
  }

  /**
   * @param {PointerEvent} e
   */
  onPointerUp(e) {
    if (!this._numActivePoints) {
      return;
    }

    this._updatePoints(e, 'up');

    if (this.pswp.dispatch('pointerUp', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (this._numActivePoints === 0) {
      this.pointerDown = false;
      this._rafStopLoop();

      if (this.isDragging) {
        this._finishDrag();
      } else if (!this.isZooming && !this.isMultitouch) {
        //this.zoomLevels.correctZoomPan();
        this._finishTap(e);
      }
    }

    if (this._numActivePoints < 2 && this.isZooming) {
      this.isZooming = false;
      this.zoomLevels.end();

      if (this._numActivePoints === 1) {
        // Since we have 1 point left, we need to reinitiate drag
        this.dragAxis = null;
        this._updateStartPoints();
      }
    }
  }

  /**
   * @private
   */
  _rafRenderLoop() {
    if (this.isDragging || this.isZooming) {
      this._updateVelocity();

      if (this.isDragging) {
        // make sure that pointer moved since the last update
        if (!pointsEqual(this.p1, this.prevP1)) {
          this.drag.change();
        }
      } else /* if (this.isZooming) */ {
        if (!pointsEqual(this.p1, this.prevP1)
            || !pointsEqual(this.p2, this.prevP2)) {
          this.zoomLevels.change();
        }
      }

      this._updatePrevPoints();
      this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
    }
  }

  /**
   * Update velocity at 50ms interval
   *
   * @param {boolean=} force
   */
  _updateVelocity(force) {
    const time = Date.now();
    const duration = time - this._intervalTime;

    if (duration < 50 && !force) {
      return;
    }


    this.velocity.x = this._getVelocity('x', duration);
    this.velocity.y = this._getVelocity('y', duration);

    this._intervalTime = time;
    equalizePoints(this._intervalP1, this.p1);
    this._velocityCalculated = true;
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _finishTap(e) {
    const { mainScroll } = this.pswp;

    // Do not trigger tap events if main scroll is shifted
    if (mainScroll.isShifted()) {
      // restore main scroll position
      // (usually happens if stopped in the middle of animation)
      mainScroll.moveIndexBy(0, true);
      return;
    }

    // Do not trigger tap for touchcancel or pointercancel
    if (e.type.indexOf('cancel') > 0) {
      return;
    }

    // Trigger click instead of tap for mouse events
    if (e.type === 'mouseup' || e.pointerType === 'mouse') {
      this.tapHandler.click(this.startP1, e);
      return;
    }

    // Disable delay if there is no doubleTapAction
    const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0;

    // If tapTimer is defined - we tapped recently,
    // check if the current tap is close to the previous one,
    // if yes - trigger double tap
    if (this._tapTimer) {
      this._clearTapTimer();
      // Check if two taps were more or less on the same place
      if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
        this.tapHandler.doubleTap(this.startP1, e);
      }
    } else {
      equalizePoints(this._lastStartP1, this.startP1);
      this._tapTimer = setTimeout(() => {
        this.tapHandler.tap(this.startP1, e);
        this._clearTapTimer();
      }, tapDelay);
    }
  }

  /**
   * @private
   */
  _clearTapTimer() {
    if (this._tapTimer) {
      clearTimeout(this._tapTimer);
      this._tapTimer = null;
    }
  }

  /**
   * Get velocity for axis
   *
   * @private
   * @param {'x' | 'y'} axis
   * @param {number} duration
   */
  _getVelocity(axis, duration) {
    // displacement is like distance, but can be negative.
    const displacement = this.p1[axis] - this._intervalP1[axis];

    if (Math.abs(displacement) > 1 && duration > 5) {
      return displacement / duration;
    }

    return 0;
  }

  /**
   * @private
   */
  _rafStopLoop() {
    if (this.raf) {
      cancelAnimationFrame(this.raf);
      this.raf = null;
    }
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _preventPointerEventBehaviour(e) {
    // TODO find a way to disable e.preventDefault on some elements
    //      via event or some class or something
    e.preventDefault();
    return true;
  }

  /**
   * Parses and normalizes points from the touch, mouse or pointer event.
   * Updates p1 and p2.
   *
   * @private
   * @param {PointerEvent | TouchEvent} e
   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
   */
  _updatePoints(e, pointerType) {
    if (this._pointerEventEnabled) {
      const pointerEvent = /** @type {PointerEvent} */ (e);
      // Try to find the current pointer in ongoing pointers by its ID
      const pointerIndex = this._ongoingPointers.findIndex((ongoingPoiner) => {
        return ongoingPoiner.id === pointerEvent.pointerId;
      });

      if (pointerType === 'up' && pointerIndex > -1) {
        // release the pointer - remove it from ongoing
        this._ongoingPointers.splice(pointerIndex, 1);
      } else if (pointerType === 'down' && pointerIndex === -1) {
        // add new pointer
        this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {}));
      } else if (pointerIndex > -1) {
        // update existing pointer
        this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
      }

      this._numActivePoints = this._ongoingPointers.length;

      // update points that PhotoSwipe uses
      // to calculate position and scale
      if (this._numActivePoints > 0) {
        equalizePoints(this.p1, this._ongoingPointers[0]);
      }

      if (this._numActivePoints > 1) {
        equalizePoints(this.p2, this._ongoingPointers[1]);
      }
    } else {
      const touchEvent = /** @type {TouchEvent} */ (e);

      this._numActivePoints = 0;
      if (touchEvent.type.indexOf('touch') > -1) {
        // Touch Event
        // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
        if (touchEvent.touches && touchEvent.touches.length > 0) {
          this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
          this._numActivePoints++;
          if (touchEvent.touches.length > 1) {
            this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
            this._numActivePoints++;
          }
        }
      } else {
        // Mouse Event
        this._convertEventPosToPoint(/** @type {PointerEvent} */ (e), this.p1);
        if (pointerType === 'up') {
          // clear all points on mouseup
          this._numActivePoints = 0;
        } else {
          this._numActivePoints++;
        }
      }
    }
  }

  // update points that were used during previous rAF tick
  _updatePrevPoints() {
    equalizePoints(this.prevP1, this.p1);
    equalizePoints(this.prevP2, this.p2);
  }

  // update points at the start of gesture
  _updateStartPoints() {
    equalizePoints(this.startP1, this.p1);
    equalizePoints(this.startP2, this.p2);
    this._updatePrevPoints();
  }

  _calculateDragDirection() {
    if (this.pswp.mainScroll.isShifted()) {
      // if main scroll position is shifted  direction is always horizontal
      this.dragAxis = 'x';
    } else {
      // calculate delta of the last touchmove tick
      const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);

      if (diff !== 0) {
        // check if pointer was shifted horizontally or vertically
        const axisToCheck = diff > 0 ? 'x' : 'y';

        if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
          this.dragAxis = axisToCheck;
        }
      }
    }
  }

  /**
   * Converts touch, pointer or mouse event
   * to PhotoSwipe point.
   *
   * @private
   * @param {Touch | PointerEvent} e
   * @param {Point} p
   */
  _convertEventPosToPoint(e, p) {
    p.x = e.pageX - this.pswp.offset.x;
    p.y = e.pageY - this.pswp.offset.y;

    if ('pointerId' in e) {
      p.id = e.pointerId;
    } else if (e.identifier !== undefined) {
      p.id = e.identifier;
    }

    return p;
  }

  /**
   * @private
   * @param {PointerEvent} e
   */
  _onClick(e) {
    // Do not allow click event to pass through after drag
    if (this.pswp.mainScroll.isShifted()) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/slide.js').default} Slide */

/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */

const MAIN_SCROLL_END_FRICTION = 0.35;


// const MIN_SWIPE_TRANSITION_DURATION = 250;
// const MAX_SWIPE_TRABSITION_DURATION = 500;
// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;

/**
 * Handles movement of the main scrolling container
 * (for example, it repositions when user swipes left or right).
 *
 * Also stores its state.
 */
class MainScroll {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    this.x = 0;

    /** @type {number} */
    this.slideWidth = undefined;

    /** @type {ItemHolder[]} */
    this.itemHolders = undefined;

    this.resetPosition();
  }

  /**
   * Position the scroller and slide containers
   * according to viewport size.
   *
   * @param {boolean=} resizeSlides Whether slides content should resized
   */
  resize(resizeSlides) {
    const { pswp } = this;
    const newSlideWidth = Math.round(
      pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing
    );
    // Mobile browsers might trigger a resize event during a gesture.
    // (due to toolbar appearing or hiding).
    // Avoid re-adjusting main scroll position if width wasn't changed
    const slideWidthChanged = (newSlideWidth !== this.slideWidth);

    if (slideWidthChanged) {
      this.slideWidth = newSlideWidth;
      this.moveTo(this.getCurrSlideX());
    }

    this.itemHolders.forEach((itemHolder, index) => {
      if (slideWidthChanged) {
        setTransform(itemHolder.el, (index + this._containerShiftIndex)
                                    * this.slideWidth);
      }

      if (resizeSlides && itemHolder.slide) {
        itemHolder.slide.resize();
      }
    });
  }

  /**
   * Reset X position of the main scroller to zero
   */
  resetPosition() {
    // Position on the main scroller (offset)
    // it is independent from slide index
    this._currPositionIndex = 0;
    this._prevPositionIndex = 0;

    // This will force recalculation of size on next resize()
    this.slideWidth = 0;

    // _containerShiftIndex*viewportSize will give you amount of transform of the current slide
    this._containerShiftIndex = -1;
  }

  /**
   * Create and append array of three items
   * that hold data about slides in DOM
   */
  appendHolders() {
    this.itemHolders = [];

    // append our three slide holders -
    // previous, current, and next
    for (let i = 0; i < 3; i++) {
      const el = createElement('pswp__item', false, this.pswp.container);
      el.setAttribute('role', 'group');
      el.setAttribute('aria-roledescription', 'slide');
      el.setAttribute('aria-hidden', 'true');

      // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
      el.style.display = (i === 1) ? 'block' : 'none';

      this.itemHolders.push({
        el,
        //index: -1
      });
    }
  }

  /**
   * Whether the main scroll can be horizontally swiped to the next or previous slide.
   */
  canBeSwiped() {
    return this.pswp.getNumItems() > 1;
  }

  /**
   * Move main scroll by X amount of slides.
   * For example:
   *   `-1` will move to the previous slide,
   *    `0` will reset the scroll position of the current slide,
   *    `3` will move three slides forward
   *
   * If loop option is enabled - index will be automatically looped too,
   * (for example `-1` will move to the last slide of the gallery).
   *
   * @param {number} diff
   * @param {boolean=} animate
   * @param {number=} velocityX
   * @returns {boolean} whether index was changed or not
   */
  moveIndexBy(diff, animate, velocityX) {
    const { pswp } = this;
    let newIndex = pswp.potentialIndex + diff;
    const numSlides = pswp.getNumItems();

    if (pswp.canLoop()) {
      newIndex = pswp.getLoopedIndex(newIndex);
      const distance = (diff + numSlides) % numSlides;
      if (distance <= numSlides / 2) {
        // go forward
        diff = distance;
      } else {
        // go backwards
        diff = distance - numSlides;
      }
    } else {
      if (newIndex < 0) {
        newIndex = 0;
      } else if (newIndex >= numSlides) {
        newIndex = numSlides - 1;
      }
      diff = newIndex - pswp.potentialIndex;
    }

    pswp.potentialIndex = newIndex;
    this._currPositionIndex -= diff;

    pswp.animations.stopMainScroll();

    const destinationX = this.getCurrSlideX();
    if (!animate) {
      this.moveTo(destinationX);
      this.updateCurrItem();
    } else {
      pswp.animations.startSpring({
        isMainScroll: true,
        start: this.x,
        end: destinationX,
        velocity: velocityX || 0,
        naturalFrequency: 30,
        dampingRatio: 1, //0.7,
        onUpdate: (x) => {
          this.moveTo(x);
        },
        onComplete: () => {
          this.updateCurrItem();
          pswp.appendHeavy();
        }
      });

      let currDiff = pswp.potentialIndex - pswp.currIndex;
      if (pswp.canLoop()) {
        const currDistance = (currDiff + numSlides) % numSlides;
        if (currDistance <= numSlides / 2) {
          // go forward
          currDiff = currDistance;
        } else {
          // go backwards
          currDiff = currDistance - numSlides;
        }
      }

      // Force-append new slides during transition
      // if difference between slides is more than 1
      if (Math.abs(currDiff) > 1) {
        this.updateCurrItem();
      }
    }

    if (diff) {
      return true;
    }
  }

  /**
   * X position of the main scroll for the current slide
   * (ignores position during dragging)
   */
  getCurrSlideX() {
    return this.slideWidth * this._currPositionIndex;
  }

  /**
   * Whether scroll position is shifted.
   * For example, it will return true if the scroll is being dragged or animated.
   */
  isShifted() {
    return this.x !== this.getCurrSlideX();
  }

  /**
   * Update slides X positions and set their content
   */
  updateCurrItem() {
    const { pswp } = this;
    const positionDifference = this._prevPositionIndex - this._currPositionIndex;

    if (!positionDifference) {
      return;
    }

    this._prevPositionIndex = this._currPositionIndex;

    pswp.currIndex = pswp.potentialIndex;

    let diffAbs = Math.abs(positionDifference);
    let tempHolder;

    if (diffAbs >= 3) {
      this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
      diffAbs = 3;
    }

    for (let i = 0; i < diffAbs; i++) {
      if (positionDifference > 0) {
        tempHolder = this.itemHolders.shift();
        this.itemHolders[2] = tempHolder; // move first to last

        this._containerShiftIndex++;

        setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);

        pswp.setContent(tempHolder, (pswp.currIndex - diffAbs) + i + 2);
      } else {
        tempHolder = this.itemHolders.pop();
        this.itemHolders.unshift(tempHolder); // move last to first

        this._containerShiftIndex--;

        setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);

        pswp.setContent(tempHolder, (pswp.currIndex + diffAbs) - i - 2);
      }
    }

    // Reset transfrom every 50ish navigations in one direction.
    //
    // Otherwise transform will keep growing indefinitely,
    // which might cause issues as browsers have a maximum transform limit.
    // I wasn't able to reach it, but just to be safe.
    // This should not cause noticable lag.
    if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
      this.resetPosition();
      this.resize();
    }

    // Pan transition might be running (and consntantly updating pan position)
    pswp.animations.stopAllPan();

    this.itemHolders.forEach((itemHolder, i) => {
      if (itemHolder.slide) {
        // Slide in the 2nd holder is always active
        itemHolder.slide.setIsActive(i === 1);
      }
    });

    pswp.currSlide = this.itemHolders[1].slide;
    pswp.contentLoader.updateLazy(positionDifference);

    if (pswp.currSlide) {
      pswp.currSlide.applyCurrentZoomPan();
    }

    pswp.dispatch('change');
  }

  /**
   * Move the X position of the main scroll container
   *
   * @param {number} x
   * @param {boolean=} dragging
   */
  moveTo(x, dragging) {
    /** @type {number} */
    let newSlideIndexOffset;
    /** @type {number} */
    let delta;

    if (!this.pswp.canLoop() && dragging) {
      // Apply friction
      newSlideIndexOffset = ((this.slideWidth * this._currPositionIndex) - x) / this.slideWidth;
      newSlideIndexOffset += this.pswp.currIndex;
      delta = Math.round(x - this.x);

      if ((newSlideIndexOffset < 0 && delta > 0)
          || (newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0)) {
        x = this.x + (delta * MAIN_SCROLL_END_FRICTION);
      }
    }

    this.x = x;
    setTransform(this.pswp.container, x);

    this.pswp.dispatch('moveMainScroll', { x, dragging });
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */

/**
 * @template T
 * @typedef {import('./types.js').Methods<T>} Methods<T>
 */

/**
 * - Manages keyboard shortcuts.
 * - Heps trap focus within photoswipe.
 */
class Keyboard {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;

    pswp.on('bindEvents', () => {
      // Dialog was likely opened by keyboard if initial point is not defined
      if (!pswp.options.initialPointerPos) {
        // focus causes layout,
        // which causes lag during the animation,
        // that's why we delay it until the opener transition ends
        this._focusRoot();
      }

      pswp.events.add(document, 'focusin', this._onFocusIn.bind(this));
      pswp.events.add(document, 'keydown', this._onKeyDown.bind(this));
    });

    const lastActiveElement = /** @type {HTMLElement} */ (document.activeElement);
    pswp.on('destroy', () => {
      if (pswp.options.returnFocus
          && lastActiveElement
          && this._wasFocused) {
        lastActiveElement.focus();
      }
    });
  }

  _focusRoot() {
    if (!this._wasFocused) {
      this.pswp.element.focus();
      this._wasFocused = true;
    }
  }

  /**
   * @param {KeyboardEvent} e
   */
  _onKeyDown(e) {
    const { pswp } = this;

    if (pswp.dispatch('keydown', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (specialKeyUsed(e)) {
      // don't do anything if special key pressed
      // to prevent from overriding default browser actions
      // for example, in Chrome on Mac cmd+arrow-left returns to previous page
      return;
    }

    /** @type {Methods<PhotoSwipe>} */
    let keydownAction;
    /** @type {'x' | 'y'} */
    let axis;
    let isForward;

    switch (e.keyCode) {
      case 27: // esc
        if (pswp.options.escKey) {
          keydownAction = 'close';
        }
        break;
      case 90: // z key
        keydownAction = 'toggleZoom';
        break;
      case 37: // left
        axis = 'x';
        break;
      case 38: // top
        axis = 'y';
        break;
      case 39: // right
        axis = 'x';
        isForward = true;
        break;
      case 40: // bottom
        isForward = true;
        axis = 'y';
        break;
      case 9: // tab
        this._focusRoot();
        break;
    }

    // if left/right/top/bottom key
    if (axis) {
      // prevent page scroll
      e.preventDefault();

      const { currSlide } = pswp;

      if (pswp.options.arrowKeys
          && axis === 'x'
          && pswp.getNumItems() > 1) {
        keydownAction = isForward ? 'next' : 'prev';
      } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
        // up/down arrow keys pan the image vertically
        // left/right arrow keys pan horizontally.
        // Unless there is only one image,
        // or arrowKeys option is disabled
        currSlide.pan[axis] += isForward ? -80 : 80;
        currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
      }
    }

    if (keydownAction) {
      e.preventDefault();
      pswp[keydownAction]();
    }
  }

  /**
   * Trap focus inside photoswipe
   *
   * @param {FocusEvent} e
   */
  _onFocusIn(e) {
    const { template } = this.pswp;
    if (document !== e.target
        && template !== e.target
        && !template.contains(/** @type {Node} */ (e.target))) {
      // focus root element
      template.focus();
    }
  }
}

const DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';

/** @typedef {import('./animations.js').AnimationProps} AnimationProps */

/**
 * Runs CSS transition.
 */
class CSSAnimation {
  /**
   * onComplete can be unpredictable, be careful about current state
   *
   * @param {AnimationProps} props
   */
  constructor(props) {
    this.props = props;
    const {
      target,
      onComplete,
      transform,
      onFinish
      // opacity
    } = props;

    let {
      duration,
      easing,
    } = props;

    /** @type {() => void} */
    this.onFinish = onFinish;

    // support only transform and opacity
    const prop = transform ? 'transform' : 'opacity';
    const propValue = props[prop];

    /** @private */
    this._target = target;
    /** @private */
    this._onComplete = onComplete;

    duration = duration || 333;
    easing = easing || DEFAULT_EASING;

    /** @private */
    this._onTransitionEnd = this._onTransitionEnd.bind(this);

    // Using timeout hack to make sure that animation
    // starts even if the animated property was changed recently,
    // otherwise transitionend might not fire or transiton won't start.
    // https://drafts.csswg.org/css-transitions/#starting
    //
    // \_()_/
    /** @private */
    this._helperTimeout = setTimeout(() => {
      setTransitionStyle(target, prop, duration, easing);
      this._helperTimeout = setTimeout(() => {
        target.addEventListener('transitionend', this._onTransitionEnd, false);
        target.addEventListener('transitioncancel', this._onTransitionEnd, false);

        // Safari occasionally does not emit transitionend event
        // if element propery was modified during the transition,
        // which may be caused by resize or third party component,
        // using timeout as a safety fallback
        this._helperTimeout = setTimeout(() => {
          this._finalizeAnimation();
        }, duration + 500);
        target.style[prop] = propValue;
      }, 30); // Do not reduce this number
    }, 0);
  }

  /**
   * @private
   * @param {TransitionEvent} e
   */
  _onTransitionEnd(e) {
    if (e.target === this._target) {
      this._finalizeAnimation();
    }
  }

  /**
   * @private
   */
  _finalizeAnimation() {
    if (!this._finished) {
      this._finished = true;
      this.onFinish();
      if (this._onComplete) {
        this._onComplete();
      }
    }
  }

  // Destroy is called automatically onFinish
  destroy() {
    if (this._helperTimeout) {
      clearTimeout(this._helperTimeout);
    }
    removeTransitionStyle(this._target);
    this._target.removeEventListener('transitionend', this._onTransitionEnd, false);
    this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);
    if (!this._finished) {
      this._finalizeAnimation();
    }
  }
}

const DEFAULT_NATURAL_FREQUENCY = 12;
const DEFAULT_DAMPING_RATIO = 0.75;

/**
 * Spring easing helper
 */
class SpringEaser {
  /**
   * @param {number} initialVelocity Initial velocity, px per ms.
   *
   * @param {number} dampingRatio
   * Determines how bouncy animation will be.
   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
   * "overshoot" refers to part of animation that
   * goes beyond the final value.
   *
   * @param {number} naturalFrequency
   * Determines how fast animation will slow down.
   * The higher value - the stiffer the transition will be,
   * and the faster it will slow down.
   * Recommended value from 10 to 50
   */
  constructor(initialVelocity, dampingRatio, naturalFrequency) {
    this.velocity = initialVelocity * 1000; // convert to "pixels per second"

    // https://en.wikipedia.org/wiki/Damping_ratio
    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO;

    // https://en.wikipedia.org/wiki/Natural_frequency
    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;

    if (this._dampingRatio < 1) {
      this._dampedFrequency = this._naturalFrequency
                         * Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
    }
  }

  /**
   * @param {number} deltaPosition Difference between current and end position of the animation
   * @param {number} deltaTime Frame duration in milliseconds
   *
   * @returns {number} Displacement, relative to the end position.
   */
  easeFrame(deltaPosition, deltaTime) {
    // Inspired by Apple Webkit and Android spring function implementation
    // https://en.wikipedia.org/wiki/Oscillation
    // https://en.wikipedia.org/wiki/Damping_ratio
    // we ignore mass (assume that it's 1kg)

    let displacement = 0;
    let coeff;

    deltaTime /= 1000;

    const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);

    if (this._dampingRatio === 1) {
      coeff = this.velocity + this._naturalFrequency * deltaPosition;

      displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;

      this.velocity = displacement
                        * (-this._naturalFrequency) + coeff
                        * naturalDumpingPow;
    } else if (this._dampingRatio < 1) {
      coeff = (1 / this._dampedFrequency)
                * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);

      const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
      const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);

      displacement = naturalDumpingPow
                       * (deltaPosition * dumpedFCos + coeff * dumpedFSin);

      this.velocity = displacement
                        * (-this._naturalFrequency)
                        * this._dampingRatio
                        + naturalDumpingPow
                        * (-this._dampedFrequency * deltaPosition * dumpedFSin
                        + this._dampedFrequency * coeff * dumpedFCos);
    }

    // Overdamped (>1) damping ratio is not supported

    return displacement;
  }
}

/** @typedef {import('./animations.js').AnimationProps} AnimationProps */

class SpringAnimation {
  /**
   * @param {AnimationProps} props
   */
  constructor(props) {
    this.props = props;

    const {
      start,
      end,
      velocity,
      onUpdate,
      onComplete,
      onFinish,
      dampingRatio,
      naturalFrequency
    } = props;

    /** @type {() => void} */
    this.onFinish = onFinish;

    const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
    let prevTime = Date.now();
    let deltaPosition = start - end;

    const animationLoop = () => {
      if (this._raf) {
        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime);

        // Stop the animation if velocity is low and position is close to end
        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
          // Finalize the animation
          onUpdate(end);
          if (onComplete) {
            onComplete();
          }
          this.onFinish();
        } else {
          prevTime = Date.now();
          onUpdate(deltaPosition + end);
          this._raf = requestAnimationFrame(animationLoop);
        }
      }
    };

    this._raf = requestAnimationFrame(animationLoop);
  }

  // Destroy is called automatically onFinish
  destroy() {
    if (this._raf >= 0) {
      cancelAnimationFrame(this._raf);
    }
    this._raf = null;
  }
}

/** @typedef {SpringAnimation | CSSAnimation} Animation */

/**
 * @typedef {Object} AnimationProps
 *
 * @prop {HTMLElement=} target
 *
 * @prop {string=} name
 *
 * @prop {number=} start
 * @prop {number=} end
 * @prop {number=} duration
 * @prop {number=} velocity
 * @prop {number=} dampingRatio
 * @prop {number=} naturalFrequency
 *
 * @prop {(end: number) => void} [onUpdate]
 * @prop {() => void} [onComplete]
 * @prop {() => void} [onFinish]
 *
 * @prop {string=} transform
 * @prop {string=} opacity
 * @prop {string=} easing
 *
 * @prop {boolean=} isPan
 * @prop {boolean=} isMainScroll
 */

/**
 * Manages animations
 */
class Animations {
  constructor() {
    /** @type {Animation[]} */
    this.activeAnimations = [];
  }

  /**
   * @param {AnimationProps} props
   */
  startSpring(props) {
    this._start(props, true);
  }

  /**
   * @param {AnimationProps} props
   */
  startTransition(props) {
    this._start(props);
  }

  /**
   * @param {AnimationProps} props
   * @param {boolean=} isSpring
   */
  _start(props, isSpring) {
    /** @type {Animation} */
    let animation;
    if (isSpring) {
      animation = new SpringAnimation(props);
    } else {
      animation = new CSSAnimation(props);
    }

    this.activeAnimations.push(animation);
    animation.onFinish = () => this.stop(animation);

    return animation;
  }

  /**
   * @param {Animation} animation
   */
  stop(animation) {
    animation.destroy();
    const index = this.activeAnimations.indexOf(animation);
    if (index > -1) {
      this.activeAnimations.splice(index, 1);
    }
  }

  stopAll() { // _stopAllAnimations
    this.activeAnimations.forEach((animation) => {
      animation.destroy();
    });
    this.activeAnimations = [];
  }

  /**
   * Stop all pan or zoom transitions
   */
  stopAllPan() {
    this.activeAnimations = this.activeAnimations.filter((animation) => {
      if (animation.props.isPan) {
        animation.destroy();
        return false;
      }

      return true;
    });
  }

  stopMainScroll() {
    this.activeAnimations = this.activeAnimations.filter((animation) => {
      if (animation.props.isMainScroll) {
        animation.destroy();
        return false;
      }

      return true;
    });
  }

  /**
   * Returns true if main scroll transition is running
   */
  // isMainScrollRunning() {
  //   return this.activeAnimations.some((animation) => {
  //     return animation.props.isMainScroll;
  //   });
  // }

  /**
   * Returns true if any pan or zoom transition is running
   */
  isPanRunning() {
    return this.activeAnimations.some((animation) => {
      return animation.props.isPan;
    });
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */

/**
 * Handles scroll wheel.
 * Can pan and zoom current slide image.
 */
class ScrollWheel {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    pswp.events.add(pswp.element, 'wheel', this._onWheel.bind(this));
  }

  /**
   * @private
   * @param {WheelEvent} e
   */
  _onWheel(e) {
    e.preventDefault();
    const { currSlide } = this.pswp;
    let { deltaX, deltaY } = e;

    if (!currSlide) {
      return;
    }

    if (this.pswp.dispatch('wheel', { originalEvent: e }).defaultPrevented) {
      return;
    }

    if (e.ctrlKey || this.pswp.options.wheelToZoom) {
      // zoom
      if (currSlide.isZoomable()) {
        let zoomFactor = -deltaY;
        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
          zoomFactor *= 0.05;
        } else {
          zoomFactor *= e.deltaMode ? 1 : 0.002;
        }
        zoomFactor = 2 ** zoomFactor;

        const destZoomLevel = currSlide.currZoomLevel * zoomFactor;
        currSlide.zoomTo(destZoomLevel, {
          x: e.clientX,
          y: e.clientY
        });
      }
    } else {
      // pan
      if (currSlide.isPannable()) {
        if (e.deltaMode === 1 /* DOM_DELTA_LINE */) {
          // 18 - average line height
          deltaX *= 18;
          deltaY *= 18;
        }

        currSlide.panTo(
          currSlide.pan.x - deltaX,
          currSlide.pan.y - deltaY
        );
      }
    }
  }
}

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 * @template T
 * @typedef {import('../types.js').Methods<T>} Methods<T>
 */

/**
 * @typedef {Object} UIElementMarkupProps
 * @prop {boolean=} isCustomSVG
 * @prop {string} inner
 * @prop {string=} outlineID
 * @prop {number | string} [size]
 */

/**
 * @typedef {Object} UIElementData
 * @prop {DefaultUIElements | string} [name]
 * @prop {string=} className
 * @prop {UIElementMarkup=} html
 * @prop {boolean=} isButton
 * @prop {keyof HTMLElementTagNameMap} [tagName]
 * @prop {string=} title
 * @prop {string=} ariaLabel
 * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
 * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
 * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
 * @prop {number=} order
 */

/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */

/** @typedef {string | UIElementMarkupProps} UIElementMarkup */

/**
 * @param {UIElementMarkup} [htmlData]
 */
function addElementHTML(htmlData) {
  if (typeof htmlData === 'string') {
    // Allow developers to provide full svg,
    // For example:
    // <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">
    //   <path d="..." />
    //   <circle ... />
    // </svg>
    // Can also be any HTML string.
    return htmlData;
  }

  if (!htmlData || !htmlData.isCustomSVG) {
    return '';
  }

  const svgData = htmlData;
  let out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
  // replace all %d with size
  out = out.split('%d').join(/** @type {string} */ (svgData.size || 32));

  // Icons may contain outline/shadow,
  // to make it we "clone" base icon shape and add border to it.
  // Icon itself and border are styled via CSS.
  //
  // Property shadowID defines ID of element that should be cloned.
  if (svgData.outlineID) {
    out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
  }

  out += svgData.inner;

  out += '</svg>';

  return out;
}

class UIElement {
  /**
   * @param {PhotoSwipe} pswp
   * @param {UIElementData} data
   */
  constructor(pswp, data) {
    const name = data.name || data.className;
    let elementHTML = data.html;

    // @ts-expect-error lookup only by `data.name` maybe?
    if (pswp.options[name] === false) {
      // exit if element is disabled from options
      return;
    }

    // Allow to override SVG icons from options
    // @ts-expect-error lookup only by `data.name` maybe?
    if (typeof pswp.options[name + 'SVG'] === 'string') {
      // arrowPrevSVG
      // arrowNextSVG
      // closeSVG
      // zoomSVG
      // @ts-expect-error lookup only by `data.name` maybe?
      elementHTML = pswp.options[name + 'SVG'];
    }

    pswp.dispatch('uiElementCreate', { data });

    let className = '';
    if (data.isButton) {
      className += 'pswp__button ';
      className += (data.className || `pswp__button--${data.name}`);
    } else {
      className += (data.className || `pswp__${data.name}`);
    }

    /** @type {HTMLElement} */
    let element;
    let tagName = data.isButton ? (data.tagName || 'button') : (data.tagName || 'div');
    tagName = /** @type {keyof HTMLElementTagNameMap} */ (tagName.toLowerCase());
    element = createElement(className, tagName);

    if (data.isButton) {
      // create button element
      element = createElement(className, tagName);
      if (tagName === 'button') {
        /** @type {HTMLButtonElement} */ (element).type = 'button';
      }

      let { title } = data;
      const { ariaLabel } = data;

      // @ts-expect-error lookup only by `data.name` maybe?
      if (typeof pswp.options[name + 'Title'] === 'string') {
        // @ts-expect-error lookup only by `data.name` maybe?
        title = pswp.options[name + 'Title'];
      }

      if (title) {
        element.title = title;
      }

      if (ariaLabel || title) {
        /** @type {HTMLElement} */ (element).setAttribute('aria-label', ariaLabel || title);
      }
    }

    element.innerHTML = addElementHTML(elementHTML);

    if (data.onInit) {
      data.onInit(element, pswp);
    }

    if (data.onClick) {
      element.onclick = (e) => {
        if (typeof data.onClick === 'string') {
          pswp[data.onClick]();
        } else {
          data.onClick(e, element, pswp);
        }
      };
    }

    // Top bar is default position
    const appendTo = data.appendTo || 'bar';
    let container;
    if (appendTo === 'bar') {
      if (!pswp.topBar) {
        pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);
      }
      container = pswp.topBar;
    } else {
      // element outside of top bar gets a secondary class
      // that makes element fade out on close
      element.classList.add('pswp__hide-on-close');

      if (appendTo === 'wrapper') {
        container = pswp.scrollWrap;
      } else {
        // root element
        container = pswp.element;
      }
    }

    container.appendChild(pswp.applyFilters('uiElement', element, data));
  }
}

/*
  Backward and forward arrow buttons
 */

/** @typedef {import('./ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/**
 *
 * @param {HTMLElement} element
 * @param {PhotoSwipe} pswp
 * @param {boolean=} isNextButton
 */
function initArrowButton(element, pswp, isNextButton) {
  element.classList.add('pswp__button--arrow');
  // TODO: this should point to a unique id for this instance
  element.setAttribute('aria-controls', 'pswp__items');
  pswp.on('change', () => {
    if (!pswp.options.loop) {
      if (isNextButton) {
        /** @type {HTMLButtonElement} */
        (element).disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
      } else {
        /** @type {HTMLButtonElement} */
        (element).disabled = !(pswp.currIndex > 0);
      }
    }
  });
}

/** @type {UIElementData} */
const arrowPrev = {
  name: 'arrowPrev',
  className: 'pswp__button--arrow--prev',
  title: 'Previous',
  order: 10,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'prev',
  onInit: initArrowButton
};

/** @type {UIElementData} */
const arrowNext = {
  name: 'arrowNext',
  className: 'pswp__button--arrow--next',
  title: 'Next',
  order: 11,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<use xlink:href="#pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'next',
  onInit: (el, pswp) => {
    initArrowButton(el, pswp, true);
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const closeButton = {
  name: 'close',
  title: 'Close',
  order: 20,
  isButton: true,
  html: {
    isCustomSVG: true,
    inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
    outlineID: 'pswp__icn-close'
  },
  onClick: 'close'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const zoomButton = {
  name: 'zoom',
  title: 'Zoom',
  order: 10,
  isButton: true,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/>'
          + '<path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/>'
          + '<path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
    outlineID: 'pswp__icn-zoom'
  },
  onClick: 'toggleZoom'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const loadingIndicator = {
  name: 'preloader',
  appendTo: 'bar',
  order: 7,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
    outlineID: 'pswp__icn-loading'
  },
  onInit: (indicatorElement, pswp) => {
    /** @type {boolean} */
    let isVisible;
    /** @type {NodeJS.Timeout} */
    let delayTimeout;

    /**
     * @param {string} className
     * @param {boolean} add
     */
    const toggleIndicatorClass = (className, add) => {
      indicatorElement.classList[add ? 'add' : 'remove']('pswp__preloader--' + className);
    };

    /**
     * @param {boolean} visible
     */
    const setIndicatorVisibility = (visible) => {
      if (isVisible !== visible) {
        isVisible = visible;
        toggleIndicatorClass('active', visible);
      }
    };

    const updatePreloaderVisibility = () => {
      if (!pswp.currSlide.content.isLoading()) {
        setIndicatorVisibility(false);
        if (delayTimeout) {
          clearTimeout(delayTimeout);
          delayTimeout = null;
        }
        return;
      }

      if (!delayTimeout) {
        // display loading indicator with delay
        delayTimeout = setTimeout(() => {
          setIndicatorVisibility(pswp.currSlide.content.isLoading());
          delayTimeout = null;
        }, pswp.options.preloaderDelay);
      }
    };

    pswp.on('change', updatePreloaderVisibility);

    pswp.on('loadComplete', (e) => {
      if (pswp.currSlide === e.slide) {
        updatePreloaderVisibility();
      }
    });

    // expose the method
    pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
const counterIndicator = {
  name: 'counter',
  order: 5,
  onInit: (counterElement, pswp) => {
    pswp.on('change', () => {
      counterElement.innerText = (pswp.currIndex + 1)
                                  + pswp.options.indexIndicatorSep
                                  + pswp.getNumItems();
    });
  }
};

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./ui-element.js').UIElementData} UIElementData */

/**
 * Set special class on element when image is zoomed.
 *
 * By default it is used to adjust
 * zoom icon and zoom cursor via CSS.
 *
 * @param {HTMLElement} el
 * @param {boolean} isZoomedIn
 */
function setZoomedIn(el, isZoomedIn) {
  el.classList[isZoomedIn ? 'add' : 'remove']('pswp--zoomed-in');
}

class UI {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;

    /** @type {() => void} */
    this.updatePreloaderVisibility = undefined;

    /** @type {number} */
    this._lastUpdatedZoomLevel = undefined;
  }

  init() {
    const { pswp } = this;
    this.isRegistered = false;
    /** @type {UIElementData[]} */
    this.uiElementsData = [
      closeButton,
      arrowPrev,
      arrowNext,
      zoomButton,
      loadingIndicator,
      counterIndicator
    ];

    pswp.dispatch('uiRegister');

    // sort by order
    this.uiElementsData.sort((a, b) => {
      // default order is 0
      return (a.order || 0) - (b.order || 0);
    });

    /** @type {(UIElement | UIElementData)[]} */
    this.items = [];

    this.isRegistered = true;
    this.uiElementsData.forEach((uiElementData) => {
      this.registerElement(uiElementData);
    });

    pswp.on('change', () => {
      pswp.element.classList[pswp.getNumItems() === 1 ? 'add' : 'remove']('pswp--one-slide');
    });

    pswp.on('zoomPanUpdate', () => this._onZoomPanUpdate());
  }

  /**
   * @param {UIElementData} elementData
   */
  registerElement(elementData) {
    if (this.isRegistered) {
      this.items.push(
        new UIElement(this.pswp, elementData)
      );
    } else {
      this.uiElementsData.push(elementData);
    }
  }

  /**
   * Fired each time zoom or pan position is changed.
   * Update classes that control visibility of zoom button and cursor icon.
   */
  _onZoomPanUpdate() {
    const { template, currSlide, options } = this.pswp;
    let { currZoomLevel } = currSlide;

    if (this.pswp.opener.isClosing) {
      return;
    }

    // if not open yet - check against initial zoom level
    if (!this.pswp.opener.isOpen) {
      currZoomLevel = currSlide.zoomLevels.initial;
    }

    if (currZoomLevel === this._lastUpdatedZoomLevel) {
      return;
    }
    this._lastUpdatedZoomLevel = currZoomLevel;

    const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;

    // Initial and secondary zoom levels are almost equal
    if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
      // disable zoom
      setZoomedIn(template, false);
      template.classList.remove('pswp--zoom-allowed');
      return;
    }

    template.classList.add('pswp--zoom-allowed');

    const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial
      ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;

    setZoomedIn(template, potentialZoomLevel <= currZoomLevel);

    if (options.imageClickAction === 'zoom'
        || options.imageClickAction === 'zoom-or-close') {
      template.classList.add('pswp--click-to-zoom');
    }
  }
}

/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */

/**
 * @param {HTMLElement} el
 */
function getBoundsByElement(el) {
  const thumbAreaRect = el.getBoundingClientRect();
  return {
    x: thumbAreaRect.left,
    y: thumbAreaRect.top,
    w: thumbAreaRect.width
  };
}

/**
 * @param {HTMLElement} el
 * @param {number} imageWidth
 * @param {number} imageHeight
 */
function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
  const thumbAreaRect = el.getBoundingClientRect();

  // fill image into the area
  // (do they same as object-fit:cover does to retrieve coordinates)
  const hRatio = thumbAreaRect.width / imageWidth;
  const vRatio = thumbAreaRect.height / imageHeight;
  const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;

  const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
  const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;

  /**
   * Coordinates of the image,
   * as if it was not cropped,
   * height is calculated automatically
   *
   * @type {Bounds}
   */
  const bounds = {
    x: thumbAreaRect.left + offsetX,
    y: thumbAreaRect.top + offsetY,
    w: imageWidth * fillZoomLevel
  };

  // Coordinates of inner crop area
  // relative to the image
  bounds.innerRect = {
    w: thumbAreaRect.width,
    h: thumbAreaRect.height,
    x: offsetX,
    y: offsetY
  };

  return bounds;
}

/**
 * Get dimensions of thumbnail image
 * (click on which opens photoswipe or closes photoswipe to)
 *
 * @param {number} index
 * @param {SlideData} itemData
 * @param {PhotoSwipe} instance PhotoSwipe instance
 * @returns {Bounds | undefined}
 */
function getThumbBounds(index, itemData, instance) {
  // legacy event, before filters were introduced
  const event = instance.dispatch('thumbBounds', {
    index,
    itemData,
    instance
  });
  // @ts-expect-error
  if (event.thumbBounds) {
    // @ts-expect-error
    return event.thumbBounds;
  }

  const { element } = itemData;
  let thumbBounds;
  /** @type {HTMLElement} */
  let thumbnail;

  if (element && instance.options.thumbSelector !== false) {
    const thumbSelector = instance.options.thumbSelector || 'img';
    thumbnail = element.matches(thumbSelector)
      ? element : element.querySelector(thumbSelector);
  }

  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);

  if (thumbnail) {
    if (!itemData.thumbCropped) {
      thumbBounds = getBoundsByElement(thumbnail);
    } else {
      thumbBounds = getCroppedBoundsByElement(
        thumbnail,
        itemData.width || itemData.w,
        itemData.height || itemData.h
      );
    }
  }

  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);
}

/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../photoswipe.js').DataSource} DataSource */
/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../slide/content.js').default} ContentDefault */
/** @typedef {import('../slide/slide.js').default} Slide */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */
/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */
/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

/**
 * Allow adding an arbitrary props to the Content
 * https://photoswipe.com/custom-content/#using-webp-image-format
 * @typedef {ContentDefault & Record<string, any>} Content
 */
/** @typedef {{ x?: number; y?: number }} Point */

/**
 * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
 *
 *
 * https://photoswipe.com/adding-ui-elements/
 *
 * @prop {undefined} uiRegister
 * @prop {{ data: UIElementData }} uiElementCreate
 *
 *
 * https://photoswipe.com/events/#initialization-events
 *
 * @prop {undefined} beforeOpen
 * @prop {undefined} firstUpdate
 * @prop {undefined} initialLayout
 * @prop {undefined} change
 * @prop {undefined} afterInit
 * @prop {undefined} bindEvents
 *
 *
 * https://photoswipe.com/events/#opening-or-closing-transition-events
 *
 * @prop {undefined} openingAnimationStart
 * @prop {undefined} openingAnimationEnd
 * @prop {undefined} closingAnimationStart
 * @prop {undefined} closingAnimationEnd
 *
 *
 * https://photoswipe.com/events/#closing-events
 *
 * @prop {undefined} close
 * @prop {undefined} destroy
 *
 *
 * https://photoswipe.com/events/#pointer-and-gesture-events
 *
 * @prop {{ originalEvent: PointerEvent }} pointerDown
 * @prop {{ originalEvent: PointerEvent }} pointerMove
 * @prop {{ originalEvent: PointerEvent }} pointerUp
 * @prop {{ bgOpacity: number }} pinchClose can be default prevented
 * @prop {{ panY: number }} verticalDrag can be default prevented
 *
 *
 * https://photoswipe.com/events/#slide-content-events
 *
 * @prop {{ content: Content }} contentInit
 * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
 * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
 * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
 * @prop {{ content: Content; slide: Slide }} loadError
 * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
 * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
 * @prop {{ content: Content }} contentLazyLoad can be default prevented
 * @prop {{ content: Content }} contentAppend can be default prevented
 * @prop {{ content: Content }} contentActivate can be default prevented
 * @prop {{ content: Content }} contentDeactivate can be default prevented
 * @prop {{ content: Content }} contentRemove can be default prevented
 * @prop {{ content: Content }} contentDestroy can be default prevented
 *
 *
 * undocumented
 *
 * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
 *
 * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
 * @prop {{ x: number; dragging: boolean }} moveMainScroll
 * @prop {{ slide: Slide }} firstZoomPan
 * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData
 * @prop {undefined} beforeResize
 * @prop {undefined} resize
 * @prop {undefined} viewportSize
 * @prop {undefined} updateScrollOffset
 * @prop {{ slide: Slide }} slideInit
 * @prop {{ slide: Slide }} afterSetContent
 * @prop {{ slide: Slide }} slideLoad
 * @prop {{ slide: Slide }} appendHeavy can be default prevented
 * @prop {{ slide: Slide }} appendHeavyContent
 * @prop {{ slide: Slide }} slideActivate
 * @prop {{ slide: Slide }} slideDeactivate
 * @prop {{ slide: Slide }} slideDestroy
 * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo
 * @prop {{ slide: Slide }} zoomPanUpdate
 * @prop {{ slide: Slide }} initialZoomPan
 * @prop {{ slide: Slide }} calcSlideSize
 * @prop {undefined} resolutionChanged
 * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
 * @prop {{ content: Content }} contentAppendImage can be default prevented
 * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
 * @prop {undefined} lazyLoad
 * @prop {{ slide: Slide }} calcBounds
 * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
 *
 *
 * legacy
 *
 * @prop {undefined} init
 * @prop {undefined} initialZoomIn
 * @prop {undefined} initialZoomOut
 * @prop {undefined} initialZoomInEnd
 * @prop {undefined} initialZoomOutEnd
 * @prop {{ dataSource: DataSource, numItems: number }} numItems
 * @prop {{ itemData: SlideData; index: number }} itemData
 * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
 */

/**
 * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
 *
 * @prop {(numItems: number, dataSource: DataSource) => number} numItems
 * Modify the total amount of slides. Example on Data sources page.
 * https://photoswipe.com/filters/#numitems
 *
 * @prop {(itemData: SlideData, index: number) => SlideData} itemData
 * Modify slide item data. Example on Data sources page.
 * https://photoswipe.com/filters/#itemdata
 *
 * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
 * Modify item data when it's parsed from DOM element. Example on Data sources page.
 * https://photoswipe.com/filters/#domitemdata
 *
 * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
 * Modify clicked gallery item index.
 * https://photoswipe.com/filters/#clickedindex
 *
 * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
 * Modify placeholder image source.
 * https://photoswipe.com/filters/#placeholdersrc
 *
 * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
 * Modify if the content is currently loading.
 * https://photoswipe.com/filters/#iscontentloading
 *
 * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
 * Modify if the content can be zoomed.
 * https://photoswipe.com/filters/#iscontentzoomable
 *
 * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
 * Modify if the placeholder should be used for the content.
 * https://photoswipe.com/filters/#usecontentplaceholder
 *
 * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
 * Modify if the placeholder should be kept after the content is loaded.
 * https://photoswipe.com/filters/#iskeepingplaceholder
 *
 *
 * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
 * Modify an element when the content has error state (for example, if image cannot be loaded).
 * https://photoswipe.com/filters/#contenterrorelement
 *
 * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
 * Modify a UI element that's being created.
 * https://photoswipe.com/filters/#uielement
 *
 * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl
 * Modify the thubmnail element from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbel
 *
 * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds
 * Modify the thubmnail bounds from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbbounds
 *
 * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
 *
 */

/**
 * @template {keyof PhotoSwipeFiltersMap} T
 * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>
 */

/**
 * Base PhotoSwipe event object
 *
 * @template {keyof PhotoSwipeEventsMap} T
 */
class PhotoSwipeEvent {
  /**
   * @param {T} type
   * @param {PhotoSwipeEventsMap[T]} [details]
   */
  constructor(type, details) {
    this.type = type;
    if (details) {
      Object.assign(this, details);
    }
  }

  preventDefault() {
    this.defaultPrevented = true;
  }
}

/**
 * PhotoSwipe base class that can listen and dispatch for events.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
 */
class Eventable {
  constructor() {
    /**
     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
     */
    this._listeners = {};

    /**
     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
     */
    this._filters = {};

    /** @type {PhotoSwipe=} */
    this.pswp = undefined;

    /** @type {PhotoSwipeOptions} */
    this.options = undefined;
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   * @param {number} priority
   */
  addFilter(name, fn, priority = 100) {
    if (!this._filters[name]) {
      this._filters[name] = [];
    }

    this._filters[name].push({ fn, priority });
    this._filters[name].sort((f1, f2) => f1.priority - f2.priority);

    if (this.pswp) {
      this.pswp.addFilter(name, fn, priority);
    }
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   */
  removeFilter(name, fn) {
    if (this._filters[name]) {
      // @ts-expect-error
      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));
    }

    if (this.pswp) {
      this.pswp.removeFilter(name, fn);
    }
  }

  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
   */
  applyFilters(name, ...args) {
    if (this._filters[name]) {
      this._filters[name].forEach((filter) => {
        // @ts-expect-error
        args[0] = filter.fn.apply(this, args);
      });
    }
    return args[0];
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {EventCallback<T>} fn
   */
  on(name, fn) {
    if (!this._listeners[name]) {
      this._listeners[name] = [];
    }
    this._listeners[name].push(fn);

    // When binding events to lightbox,
    // also bind events to PhotoSwipe Core,
    // if it's open.
    if (this.pswp) {
      this.pswp.on(name, fn);
    }
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {EventCallback<T>} fn
   */
  off(name, fn) {
    if (this._listeners[name]) {
      // @ts-expect-error
      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));
    }

    if (this.pswp) {
      this.pswp.off(name, fn);
    }
  }

  /**
   * @template {keyof PhotoSwipeEventsMap} T
   * @param {T} name
   * @param {PhotoSwipeEventsMap[T]} [details]
   * @returns {AugmentedEvent<T>}
   */
  dispatch(name, details) {
    if (this.pswp) {
      return this.pswp.dispatch(name, details);
    }

    const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));

    if (!this._listeners) {
      return event;
    }

    if (this._listeners[name]) {
      this._listeners[name].forEach((listener) => {
        listener.call(this, event);
      });
    }

    return event;
  }
}

class Placeholder {
  /**
   * @param {string | false} imageSrc
   * @param {HTMLElement} container
   */
  constructor(imageSrc, container) {
    // Create placeholder
    // (stretched thumbnail or simple div behind the main image)
    this.element = createElement(
      'pswp__img pswp__img--placeholder',
      imageSrc ? 'img' : '',
      container
    );

    if (imageSrc) {
      /** @type {HTMLImageElement} */
      (this.element).decoding = 'async';
      /** @type {HTMLImageElement} */
      (this.element).alt = '';
      /** @type {HTMLImageElement} */
      (this.element).src = imageSrc;
      this.element.setAttribute('role', 'presentation');
    }

    this.element.setAttribute('aria-hidden', 'true');
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  setDisplayedSize(width, height) {
    if (!this.element) {
      return;
    }

    if (this.element.tagName === 'IMG') {
      // Use transform scale() to modify img placeholder size
      // (instead of changing width/height directly).
      // This helps with performance, specifically in iOS15 Safari.
      setWidthHeight(this.element, 250, 'auto');
      this.element.style.transformOrigin = '0 0';
      this.element.style.transform = toTransformString(0, 0, width / 250);
    } else {
      setWidthHeight(this.element, width, height);
    }
  }

  destroy() {
    if (this.element.parentNode) {
      this.element.remove();
    }
    this.element = null;
  }
}

/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../util/util.js').LoadState} LoadState */

class Content {
  /**
   * @param {SlideData} itemData Slide data
   * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance
   * @param {number} index
   */
  constructor(itemData, instance, index) {
    this.instance = instance;
    this.data = itemData;
    this.index = index;

    /** @type {HTMLImageElement | HTMLDivElement} */
    this.element = undefined;

    this.displayedImageWidth = 0;
    this.displayedImageHeight = 0;

    this.width = Number(this.data.w) || Number(this.data.width) || 0;
    this.height = Number(this.data.h) || Number(this.data.height) || 0;

    this.isAttached = false;
    this.hasSlide = false;
    /** @type {LoadState} */
    this.state = LOAD_STATE.IDLE;

    if (this.data.type) {
      this.type = this.data.type;
    } else if (this.data.src) {
      this.type = 'image';
    } else {
      this.type = 'html';
    }

    this.instance.dispatch('contentInit', { content: this });
  }

  removePlaceholder() {
    if (this.placeholder && !this.keepPlaceholder()) {
      // With delay, as image might be loaded, but not rendered
      setTimeout(() => {
        if (this.placeholder) {
          this.placeholder.destroy();
          this.placeholder = null;
        }
      }, 1000);
    }
  }

  /**
   * Preload content
   *
   * @param {boolean=} isLazy
   * @param {boolean=} reload
   */
  load(isLazy, reload) {
    if (this.slide && this.usePlaceholder()) {
      if (!this.placeholder) {
        const placeholderSrc = this.instance.applyFilters(
          'placeholderSrc',
          // use  image-based placeholder only for the first slide,
          // as rendering (even small stretched thumbnail) is an expensive operation
          (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,
          this
        );
        this.placeholder = new Placeholder(
          placeholderSrc,
          this.slide.container
        );
      } else {
        const placeholderEl = this.placeholder.element;
        // Add placeholder to DOM if it was already created
        if (placeholderEl && !placeholderEl.parentElement) {
          this.slide.container.prepend(placeholderEl);
        }
      }
    }

    if (this.element && !reload) {
      return;
    }

    if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {
      return;
    }

    if (this.isImageContent()) {
      this.element = createElement('pswp__img', 'img');
      // Start loading only after width is defined, as sizes might depend on it.
      // Due to Safari feature, we must define sizes before srcset.
      if (this.displayedImageWidth) {
        this.loadImage(isLazy);
      }
    } else {
      this.element = createElement('pswp__content');
      this.element.innerHTML = this.data.html || '';
    }

    if (reload && this.slide) {
      this.slide.updateContentSize(true);
    }
  }

  /**
   * Preload image
   *
   * @param {boolean} isLazy
   */
  loadImage(isLazy) {
    const imageElement = /** @type HTMLImageElement */ (this.element);

    if (this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {
      return;
    }

    this.updateSrcsetSizes();

    if (this.data.srcset) {
      imageElement.srcset = this.data.srcset;
    }

    imageElement.src = this.data.src;

    imageElement.alt = this.data.alt || '';

    this.state = LOAD_STATE.LOADING;

    if (imageElement.complete) {
      this.onLoaded();
    } else {
      imageElement.onload = () => {
        this.onLoaded();
      };

      imageElement.onerror = () => {
        this.onError();
      };
    }
  }

  /**
   * Assign slide to content
   *
   * @param {Slide} slide
   */
  setSlide(slide) {
    this.slide = slide;
    this.hasSlide = true;
    this.instance = slide.pswp;

    // todo: do we need to unset slide?
  }

  /**
   * Content load success handler
   */
  onLoaded() {
    this.state = LOAD_STATE.LOADED;

    if (this.slide) {
      this.instance.dispatch('loadComplete', { slide: this.slide, content: this });

      // if content is reloaded
      if (this.slide.isActive
          && this.slide.heavyAppended
          && !this.element.parentNode) {
        this.append();
        this.slide.updateContentSize(true);
      }

      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
        this.removePlaceholder();
      }
    }
  }

  /**
   * Content load error handler
   */
  onError() {
    this.state = LOAD_STATE.ERROR;

    if (this.slide) {
      this.displayError();
      this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });
      this.instance.dispatch('loadError', { slide: this.slide, content: this });
    }
  }

  /**
   * @returns {Boolean} If the content is currently loading
   */
  isLoading() {
    return this.instance.applyFilters(
      'isContentLoading',
      this.state === LOAD_STATE.LOADING,
      this
    );
  }

  isError() {
    return this.state === LOAD_STATE.ERROR;
  }

  /**
   * @returns {boolean} If the content is image
   */
  isImageContent() {
    return this.type === 'image';
  }

  /**
   * Update content size
   *
   * @param {Number} width
   * @param {Number} height
   */
  setDisplayedSize(width, height) {
    if (!this.element) {
      return;
    }

    if (this.placeholder) {
      this.placeholder.setDisplayedSize(width, height);
    }

    // eslint-disable-next-line max-len
    if (this.instance.dispatch('contentResize', { content: this, width, height }).defaultPrevented) {
      return;
    }

    setWidthHeight(this.element, width, height);

    if (this.isImageContent() && !this.isError()) {
      const isInitialSizeUpdate = (!this.displayedImageWidth && width);

      this.displayedImageWidth = width;
      this.displayedImageHeight = height;

      if (isInitialSizeUpdate) {
        this.loadImage(false);
      } else {
        this.updateSrcsetSizes();
      }

      if (this.slide) {
        // eslint-disable-next-line max-len
        this.instance.dispatch('imageSizeChange', { slide: this.slide, width, height, content: this });
      }
    }
  }

  /**
   * @returns {boolean} If the content can be zoomed
   */
  isZoomable() {
    return this.instance.applyFilters(
      'isContentZoomable',
      this.isImageContent() && (this.state !== LOAD_STATE.ERROR),
      this
    );
  }

  /**
   * Update image srcset sizes attribute based on width and height
   */
  updateSrcsetSizes() {
    // Handle srcset sizes attribute.
    //
    // Never lower quality, if it was increased previously.
    // Chrome does this automatically, Firefox and Safari do not,
    // so we store largest used size in dataset.
    // Handle srcset sizes attribute.
    //
    // Never lower quality, if it was increased previously.
    // Chrome does this automatically, Firefox and Safari do not,
    // so we store largest used size in dataset.
    if (this.data.srcset) {
      const image = /** @type HTMLImageElement */ (this.element);
      const sizesWidth = this.instance.applyFilters(
        'srcsetSizesWidth',
        this.displayedImageWidth,
        this
      );

      if (!image.dataset.largestUsedSize
          || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
        image.sizes = sizesWidth + 'px';
        image.dataset.largestUsedSize = String(sizesWidth);
      }
    }
  }

  /**
   * @returns {boolean} If content should use a placeholder (from msrc by default)
   */
  usePlaceholder() {
    return this.instance.applyFilters(
      'useContentPlaceholder',
      this.isImageContent(),
      this
    );
  }

  /**
   * Preload content with lazy-loading param
   */
  lazyLoad() {
    if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {
      return;
    }

    this.load(true);
  }

  /**
   * @returns {boolean} If placeholder should be kept after content is loaded
   */
  keepPlaceholder() {
    return this.instance.applyFilters(
      'isKeepingPlaceholder',
      this.isLoading(),
      this
    );
  }

  /**
   * Destroy the content
   */
  destroy() {
    this.hasSlide = false;
    this.slide = null;

    if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {
      return;
    }

    this.remove();

    if (this.placeholder) {
      this.placeholder.destroy();
      this.placeholder = null;
    }

    if (this.isImageContent() && this.element) {
      this.element.onload = null;
      this.element.onerror = null;
      this.element = null;
    }
  }

  /**
   * Display error message
   */
  displayError() {
    if (this.slide) {
      /** @type {HTMLElement} */
      let errorMsgEl = createElement('pswp__error-msg');
      errorMsgEl.innerText = this.instance.options.errorMsg;
      errorMsgEl = this.instance.applyFilters(
        'contentErrorElement',
        errorMsgEl,
        this
      );
      this.element = createElement('pswp__content pswp__error-msg-container');
      this.element.appendChild(errorMsgEl);
      this.slide.container.innerText = '';
      this.slide.container.appendChild(this.element);
      this.slide.updateContentSize(true);
      this.removePlaceholder();
    }
  }

  /**
   * Append the content
   */
  append() {
    if (this.isAttached) {
      return;
    }

    this.isAttached = true;

    if (this.state === LOAD_STATE.ERROR) {
      this.displayError();
      return;
    }

    if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {
      return;
    }

    const supportsDecode = ('decode' in this.element);

    if (this.isImageContent()) {
      // Use decode() on nearby slides
      //
      // Nearby slide images are in DOM and not hidden via display:none.
      // However, they are placed offscreen (to the left and right side).
      //
      // Some browsers do not composite the image until it's actually visible,
      // using decode() helps.
      //
      // You might ask "why dont you just decode() and then append all images",
      // that's because I want to show image before it's fully loaded,
      // as browser can render parts of image while it is loading.
      // We do not do this in Safari due to partial loading bug.
      if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
        this.isDecoding = true;
        // purposefully using finally instead of then,
        // as if srcset sizes changes dynamically - it may cause decode error
        /** @type {HTMLImageElement} */
        (this.element).decode().catch(() => {}).finally(() => {
          this.isDecoding = false;
          this.appendImage();
        });
      } else {
        this.appendImage();
      }
    } else if (this.element && !this.element.parentNode) {
      this.slide.container.appendChild(this.element);
    }
  }

  /**
   * Activate the slide,
   * active slide is generally the current one,
   * meaning the user can see it.
   */
  activate() {
    if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented) {
      return;
    }

    if (this.slide) {
      if (this.isImageContent() && this.isDecoding && !isSafari()) {
        // add image to slide when it becomes active,
        // even if it's not finished decoding
        this.appendImage();
      } else if (this.isError()) {
        this.load(false, true); // try to reload
      }

      if (this.slide.holderElement) {
        this.slide.holderElement.setAttribute('aria-hidden', 'false');
      }
    }
  }

  /**
   * Deactivate the content
   */
  deactivate() {
    this.instance.dispatch('contentDeactivate', { content: this });
    if (this.slide && this.slide.holderElement) {
      this.slide.holderElement.setAttribute('aria-hidden', 'true');
    }
  }


  /**
   * Remove the content from DOM
   */
  remove() {
    this.isAttached = false;

    if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {
      return;
    }

    if (this.element && this.element.parentNode) {
      this.element.remove();
    }

    if (this.placeholder && this.placeholder.element) {
      this.placeholder.element.remove();
    }
  }

  /**
   * Append the image content to slide container
   */
  appendImage() {
    if (!this.isAttached) {
      return;
    }

    if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {
      return;
    }

    // ensure that element exists and is not already appended
    if (this.slide && this.element && !this.element.parentNode) {
      this.slide.container.appendChild(this.element);
    }

    if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
      this.removePlaceholder();
    }
  }
}

/** @typedef {import('./content.js').default} Content */
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */

const MIN_SLIDES_TO_CACHE = 5;

/**
 * Lazy-load an image
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * @param {SlideData} itemData Data about the slide
 * @param {PhotoSwipe | PhotoSwipeLightbox | PhotoSwipeBase} instance PhotoSwipe instance
 * @param {number} index
 * @returns Image that is being decoded or false.
 */
function lazyLoadData(itemData, instance, index) {
  // src/slide/content/content.js
  const content = instance.createContentFromData(itemData, index);

  if (!content || !content.lazyLoad) {
    return;
  }

  const { options } = instance;

  // We need to know dimensions of the image to preload it,
  // as it might use srcset and we need to define sizes
  // @ts-expect-error should provide pswp instance?
  const viewportSize = instance.viewportSize || getViewportSize(options, instance);
  const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);

  const zoomLevel = new ZoomLevel(options, itemData, -1);
  zoomLevel.update(content.width, content.height, panAreaSize);

  content.lazyLoad();
  content.setDisplayedSize(
    Math.ceil(content.width * zoomLevel.initial),
    Math.ceil(content.height * zoomLevel.initial)
  );

  return content;
}


/**
 * Lazy-loads specific slide.
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * By default it loads image based on viewport size and initial zoom level.
 *
 * @param {number} index Slide index
 * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
 */
function lazyLoadSlide(index, instance) {
  const itemData = instance.getItemData(index);

  if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {
    return;
  }

  return lazyLoadData(itemData, instance, index);
}


class ContentLoader {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    // Total amount of cached images
    this.limit = Math.max(
      pswp.options.preload[0] + pswp.options.preload[1] + 1,
      MIN_SLIDES_TO_CACHE
    );
    /** @type {Content[]} */
    this._cachedItems = [];
  }

  /**
   * Lazy load nearby slides based on `preload` option.
   *
   * @param {number=} diff Difference between slide indexes that was changed recently, or 0.
   */
  updateLazy(diff) {
    const { pswp } = this;

    if (pswp.dispatch('lazyLoad').defaultPrevented) {
      return;
    }

    const { preload } = pswp.options;
    const isForward = diff === undefined ? true : (diff >= 0);
    let i;

    // preload[1] - num items to preload in forward direction
    for (i = 0; i <= preload[1]; i++) {
      this.loadSlideByIndex(pswp.currIndex + (isForward ? i : (-i)));
    }

    // preload[0] - num items to preload in backward direction
    for (i = 1; i <= preload[0]; i++) {
      this.loadSlideByIndex(pswp.currIndex + (isForward ? (-i) : i));
    }
  }

  /**
   * @param {number} index
   */
  loadSlideByIndex(index) {
    index = this.pswp.getLoopedIndex(index);
    // try to get cached content
    let content = this.getContentByIndex(index);
    if (!content) {
      // no cached content, so try to load from scratch:
      content = lazyLoadSlide(index, this.pswp);
      // if content can be loaded, add it to cache:
      if (content) {
        this.addToCache(content);
      }
    }
  }

  /**
   * @param {Slide} slide
   */
  getContentBySlide(slide) {
    let content = this.getContentByIndex(slide.index);
    if (!content) {
      // create content if not found in cache
      content = this.pswp.createContentFromData(slide.data, slide.index);
      if (content) {
        this.addToCache(content);
      }
    }

    if (content) {
      // assign slide to content
      content.setSlide(slide);
    }
    return content;
  }

  /**
   * @param {Content} content
   */
  addToCache(content) {
    // move to the end of array
    this.removeByIndex(content.index);
    this._cachedItems.push(content);

    if (this._cachedItems.length > this.limit) {
      // Destroy the first content that's not attached
      const indexToRemove = this._cachedItems.findIndex((item) => {
        return !item.isAttached && !item.hasSlide;
      });
      if (indexToRemove !== -1) {
        const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
        removedItem.destroy();
      }
    }
  }

  /**
   * Removes an image from cache, does not destroy() it, just removes.
   *
   * @param {number} index
   */
  removeByIndex(index) {
    const indexToRemove = this._cachedItems.findIndex(item => item.index === index);
    if (indexToRemove !== -1) {
      this._cachedItems.splice(indexToRemove, 1);
    }
  }

  /**
   * @param {number} index
   */
  getContentByIndex(index) {
    return this._cachedItems.find(content => content.index === index);
  }

  destroy() {
    this._cachedItems.forEach(content => content.destroy());
    this._cachedItems = null;
  }
}

/** @typedef {import("../photoswipe.js").default} PhotoSwipe */
/** @typedef {import("../photoswipe.js").PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import("../slide/slide.js").SlideData} SlideData */

/**
 * PhotoSwipe base class that can retrieve data about every slide.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
 */
class PhotoSwipeBase extends Eventable {
  /**
   * Get total number of slides
   *
   * @returns {number}
   */
  getNumItems() {
    let numItems;
    const { dataSource } = this.options;
    if (!dataSource) {
      numItems = 0;
    } else if ('length' in dataSource) {
      // may be an array or just object with length property
      numItems = dataSource.length;
    } else if ('gallery' in dataSource) {
      // query DOM elements
      if (!dataSource.items) {
        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
      }

      if (dataSource.items) {
        numItems = dataSource.items.length;
      }
    }

    // legacy event, before filters were introduced
    const event = this.dispatch('numItems', {
      dataSource,
      numItems
    });
    return this.applyFilters('numItems', event.numItems, dataSource);
  }

  /**
   * @param {SlideData} slideData
   * @param {number} index
   */
  createContentFromData(slideData, index) {
    // @ts-expect-error
    return new Content(slideData, this, index);
  }

  /**
   * Get item data by index.
   *
   * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
   * For example, it may contain properties like
   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
   *
   * @param {number} index
   */
  getItemData(index) {
    const { dataSource } = this.options;
    let dataSourceItem;
    if (Array.isArray(dataSource)) {
      // Datasource is an array of elements
      dataSourceItem = dataSource[index];
    } else if (dataSource && dataSource.gallery) {
      // dataSource has gallery property,
      // thus it was created by Lightbox, based on
      // gallery and children options

      // query DOM elements
      if (!dataSource.items) {
        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
      }

      dataSourceItem = dataSource.items[index];
    }

    let itemData = dataSourceItem;

    if (itemData instanceof Element) {
      itemData = this._domElementToItemData(itemData);
    }

    // Dispatching the itemData event,
    // it's a legacy verion before filters were introduced
    const event = this.dispatch('itemData', {
      itemData: itemData || {},
      index
    });

    return this.applyFilters('itemData', event.itemData, index);
  }

  /**
   * Get array of gallery DOM elements,
   * based on childSelector and gallery element.
   *
   * @param {HTMLElement} galleryElement
   */
  _getGalleryDOMElements(galleryElement) {
    if (this.options.children || this.options.childSelector) {
      return getElementsFromOption(
        this.options.children,
        this.options.childSelector,
        galleryElement
      ) || [];
    }

    return [galleryElement];
  }

  /**
   * Converts DOM element to item data object.
   *
   * @param {HTMLElement} element DOM element
   */
  // eslint-disable-next-line class-methods-use-this
  _domElementToItemData(element) {
    /** @type {SlideData} */
    const itemData = {
      element
    };

    // eslint-disable-next-line max-len
    const linkEl = /** @type {HTMLAnchorElement} */ (element.tagName === 'A' ? element : element.querySelector('a'));

    if (linkEl) {
      // src comes from data-pswp-src attribute,
      // if it's empty link href is used
      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;

      if (linkEl.dataset.pswpSrcset) {
        itemData.srcset = linkEl.dataset.pswpSrcset;
      }

      itemData.width = parseInt(linkEl.dataset.pswpWidth, 10);
      itemData.height = parseInt(linkEl.dataset.pswpHeight, 10);

      // support legacy w & h properties
      itemData.w = itemData.width;
      itemData.h = itemData.height;

      if (linkEl.dataset.pswpType) {
        itemData.type = linkEl.dataset.pswpType;
      }

      const thumbnailEl = element.querySelector('img');

      if (thumbnailEl) {
        // msrc is URL to placeholder image that's displayed before large image is loaded
        // by default it's displayed only for the first slide
        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
        itemData.alt = thumbnailEl.getAttribute('alt');
      }

      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
        itemData.thumbCropped = true;
      }
    }

    return this.applyFilters('domItemData', itemData, element, linkEl);
  }

  /**
   * Lazy-load by slide data
   *
   * @param {SlideData} itemData Data about the slide
   * @param {number} index
   * @returns Image that is being decoded or false.
   */
  lazyLoadData(itemData, index) {
    return lazyLoadData(itemData, this, index);
  }
}

/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */
/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */

// some browsers do not paint
// elements which opacity is set to 0,
// since we need to pre-render elements for the animation -
// we set it to the minimum amount
const MIN_OPACITY = 0.003;

/**
 * Manages opening and closing transitions of the PhotoSwipe.
 *
 * It can perform zoom, fade or no transition.
 */
class Opener {
  /**
   * @param {PhotoSwipe} pswp
   */
  constructor(pswp) {
    this.pswp = pswp;
    this.isClosed = true;
    this._prepareOpen = this._prepareOpen.bind(this);

    /** @type {false | Bounds} */
    this._thumbBounds = undefined;

    // Override initial zoom and pan position
    pswp.on('firstZoomPan', this._prepareOpen);
  }

  open() {
    this._prepareOpen();
    this._start();
  }

  close() {
    if (this.isClosed || this.isClosing || this.isOpening) {
      // if we close during opening animation
      // for now do nothing,
      // browsers aren't good at changing the direction of the CSS transition
      return false;
    }

    const slide = this.pswp.currSlide;

    this.isOpen = false;
    this.isOpening = false;
    this.isClosing = true;
    this._duration = this.pswp.options.hideAnimationDuration;

    if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
      this._duration = 0;
    }

    this._applyStartProps();
    setTimeout(() => {
      this._start();
    }, this._croppedZoom ? 30 : 0);

    return true;
  }

  _prepareOpen() {
    this.pswp.off('firstZoomPan', this._prepareOpen);
    if (!this.isOpening) {
      const slide = this.pswp.currSlide;
      this.isOpening = true;
      this.isClosing = false;
      this._duration = this.pswp.options.showAnimationDuration;
      if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
        this._duration = 0;
      }
      this._applyStartProps();
    }
  }

  _applyStartProps() {
    const { pswp } = this;
    const slide = this.pswp.currSlide;
    const { options } = pswp;

    if (options.showHideAnimationType === 'fade') {
      options.showHideOpacity = true;
      this._thumbBounds = false;
    } else if (options.showHideAnimationType === 'none') {
      options.showHideOpacity = false;
      this._duration = 0;
      this._thumbBounds = false;
    } else if (this.isOpening && pswp._initialThumbBounds) {
      // Use initial bounds if defined
      this._thumbBounds = pswp._initialThumbBounds;
    } else {
      this._thumbBounds = this.pswp.getThumbBounds();
    }

    this._placeholder = slide.getPlaceholderElement();

    pswp.animations.stopAll();

    // Discard animations when duration is less than 50ms
    this._useAnimation = (this._duration > 50);
    this._animateZoom = Boolean(this._thumbBounds)
                        && (slide.content && slide.content.usePlaceholder())
                        && (!this.isClosing || !pswp.mainScroll.isShifted());
    if (!this._animateZoom) {
      this._animateRootOpacity = true;

      if (this.isOpening) {
        slide.zoomAndPanToInitial();
        slide.applyCurrentZoomPan();
      }
    } else {
      this._animateRootOpacity = options.showHideOpacity;
    }
    this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
    this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;

    if (!this._useAnimation) {
      this._duration = 0;
      this._animateZoom = false;
      this._animateBgOpacity = false;
      this._animateRootOpacity = true;
      if (this.isOpening) {
        pswp.element.style.opacity = String(MIN_OPACITY);
        pswp.applyBgOpacity(1);
      }
      return;
    }

    if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
      // Properties are used when animation from cropped thumbnail
      this._croppedZoom = true;
      this._cropContainer1 = this.pswp.container;
      this._cropContainer2 = this.pswp.currSlide.holderElement;

      pswp.container.style.overflow = 'hidden';
      pswp.container.style.width = pswp.viewportSize.x + 'px';
    } else {
      this._croppedZoom = false;
    }

    if (this.isOpening) {
      // Apply styles before opening transition
      if (this._animateRootOpacity) {
        pswp.element.style.opacity = String(MIN_OPACITY);
        pswp.applyBgOpacity(1);
      } else {
        if (this._animateBgOpacity) {
          pswp.bg.style.opacity = String(MIN_OPACITY);
        }
        pswp.element.style.opacity = '1';
      }

      if (this._animateZoom) {
        this._setClosedStateZoomPan();
        if (this._placeholder) {
          // tell browser that we plan to animate the placeholder
          this._placeholder.style.willChange = 'transform';

          // hide placeholder to allow hiding of
          // elements that overlap it (such as icons over the thumbnail)
          this._placeholder.style.opacity = String(MIN_OPACITY);
        }
      }
    } else if (this.isClosing) {
      // hide nearby slides to make sure that
      // they are not painted during the transition
      pswp.mainScroll.itemHolders[0].el.style.display = 'none';
      pswp.mainScroll.itemHolders[2].el.style.display = 'none';

      if (this._croppedZoom) {
        if (pswp.mainScroll.x !== 0) {
          // shift the main scroller to zero position
          pswp.mainScroll.resetPosition();
          pswp.mainScroll.resize();
        }
      }
    }
  }

  _start() {
    if (this.isOpening
        && this._useAnimation
        && this._placeholder
        && this._placeholder.tagName === 'IMG') {
      // To ensure smooth animation
      // we wait till the current slide image placeholder is decoded,
      // but no longer than 250ms,
      // and no shorter than 50ms
      // (just using requestanimationframe is not enough in Firefox,
      // for some reason)
      new Promise((resolve) => {
        let decoded = false;
        let isDelaying = true;
        decodeImage(/** @type {HTMLImageElement} */ (this._placeholder)).finally(() => {
          decoded = true;
          if (!isDelaying) {
            resolve();
          }
        });
        setTimeout(() => {
          isDelaying = false;
          if (decoded) {
            resolve();
          }
        }, 50);
        setTimeout(resolve, 250);
      }).finally(() => this._initiate());
    } else {
      this._initiate();
    }
  }

  _initiate() {
    this.pswp.element.style.setProperty('--pswp-transition-duration', this._duration + 'ms');

    this.pswp.dispatch(
      this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'
    );

    // legacy event
    this.pswp.dispatch(
      /** @type {'initialZoomIn' | 'initialZoomOut'} */
      ('initialZoom' + (this.isOpening ? 'In' : 'Out'))
    );

    this.pswp.element.classList[this.isOpening ? 'add' : 'remove']('pswp--ui-visible');

    if (this.isOpening) {
      if (this._placeholder) {
        // unhide the placeholder
        this._placeholder.style.opacity = '1';
      }
      this._animateToOpenState();
    } else if (this.isClosing) {
      this._animateToClosedState();
    }

    if (!this._useAnimation) {
      this._onAnimationComplete();
    }
  }

  _onAnimationComplete() {
    const { pswp } = this;
    this.isOpen = this.isOpening;
    this.isClosed = this.isClosing;
    this.isOpening = false;
    this.isClosing = false;

    pswp.dispatch(
      this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'
    );

    // legacy event
    pswp.dispatch(
      /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
      ('initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'))
    );

    if (this.isClosed) {
      pswp.destroy();
    } else if (this.isOpen) {
      if (this._animateZoom) {
        pswp.container.style.overflow = 'visible';
        pswp.container.style.width = '100%';
      }
      pswp.currSlide.applyCurrentZoomPan();
    }
  }

  _animateToOpenState() {
    const { pswp } = this;
    if (this._animateZoom) {
      if (this._croppedZoom) {
        this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');
        this._animateTo(this._cropContainer2, 'transform', 'none');
      }

      pswp.currSlide.zoomAndPanToInitial();
      this._animateTo(
        pswp.currSlide.container,
        'transform',
        pswp.currSlide.getCurrentTransform()
      );
    }

    if (this._animateBgOpacity) {
      this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));
    }

    if (this._animateRootOpacity) {
      this._animateTo(pswp.element, 'opacity', '1');
    }
  }

  _animateToClosedState() {
    const { pswp } = this;

    if (this._animateZoom) {
      this._setClosedStateZoomPan(true);
    }

    if (this._animateBgOpacity
        && pswp.bgOpacity > 0.01) { // do not animate opacity if it's already at 0
      this._animateTo(pswp.bg, 'opacity', '0');
    }

    if (this._animateRootOpacity) {
      this._animateTo(pswp.element, 'opacity', '0');
    }
  }

  /**
   * @param {boolean=} animate
   */
  _setClosedStateZoomPan(animate) {
    if (!this._thumbBounds) return;

    const { pswp } = this;
    const { innerRect } = this._thumbBounds;
    const { currSlide, viewportSize } = pswp;

    if (this._croppedZoom) {
      const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
      const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
      const containerTwoPanX = viewportSize.x - innerRect.w;
      const containerTwoPanY = viewportSize.y - innerRect.h;


      if (animate) {
        this._animateTo(
          this._cropContainer1,
          'transform',
          toTransformString(containerOnePanX, containerOnePanY)
        );

        this._animateTo(
          this._cropContainer2,
          'transform',
          toTransformString(containerTwoPanX, containerTwoPanY)
        );
      } else {
        setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
        setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
      }
    }

    equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
    currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;

    if (animate) {
      this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());
    } else {
      currSlide.applyCurrentZoomPan();
    }
  }

  /**
   * @param {HTMLElement} target
   * @param {'transform' | 'opacity'} prop
   * @param {string} propValue
   */
  _animateTo(target, prop, propValue) {
    if (!this._duration) {
      target.style[prop] = propValue;
      return;
    }

    const { animations } = this.pswp;
    /** @type {AnimationProps} */
    const animProps = {
      duration: this._duration,
      easing: this.pswp.options.easing,
      onComplete: () => {
        if (!animations.activeAnimations.length) {
          this._onAnimationComplete();
        }
      },
      target,
    };
    animProps[prop] = propValue;
    animations.startTransition(animProps);
  }
}

/**
 * @template T
 * @typedef {import('./types.js').Type<T>} Type<T>
 */

/** @typedef {import('./slide/slide.js').SlideData} SlideData */
/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */
/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */
/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */
/**
 * @template T
 * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>
 */
/**
 * @template T
 * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>
 */

/** @typedef {{ x?: number; y?: number; id?: string | number }} Point */
/** @typedef {{ x?: number; y?: number }} Size */
/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */
/** @typedef {SlideData[]} DataSourceArray */
/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */
/** @typedef {DataSourceArray | DataSourceObject} DataSource */
/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */
/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */
/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */
/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */

/**
 * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider
 */

/**
 * @typedef {Object} PhotoSwipeOptions https://photoswipe.com/options/
 *
 * @prop {DataSource=} dataSource
 * Pass an array of any items via dataSource option. Its length will determine amount of slides
 * (which may be modified further from numItems event).
 *
 * Each item should contain data that you need to generate slide
 * (for image slide it would be src (image URL), width (image width), height, srcset, alt).
 *
 * If these properties are not present in your initial array, you may "pre-parse" each item from itemData filter.
 *
 * @prop {number=} bgOpacity
 * Background backdrop opacity, always define it via this option and not via CSS rgba color.
 *
 * @prop {number=} spacing
 * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).
 *
 * @prop {boolean=} allowPanToNext
 * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.
 *
 * @prop {boolean=} loop
 * If set to true you'll be able to swipe from the last to the first image.
 * Option is always false when there are less than 3 slides.
 *
 * @prop {boolean=} wheelToZoom
 * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.
 *
 * @prop {boolean=} pinchToClose
 * Pinch touch gesture to close the gallery.
 *
 * @prop {boolean=} closeOnVerticalDrag
 * Vertical drag gesture to close the PhotoSwipe.
 *
 * @prop {Padding=} padding
 * Slide area padding (in pixels).
 *
 * @prop {(viewportSize: Size, itemData: SlideData, index: number) => Padding} [paddingFn]
 * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:
 *
 * @prop {number | false} [hideAnimationDuration]
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} [showAnimationDuration]
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} [zoomAnimationDuration]
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {string=} easing
 * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.
 *
 * @prop {boolean=} escKey
 * Esc key to close.
 *
 * @prop {boolean=} arrowKeys
 * Left/right arrow keys for navigation.
 *
 * @prop {boolean=} returnFocus
 * Restore focus the last active element after PhotoSwipe is closed.
 *
 * @prop {boolean=} clickToCloseNonZoomable
 * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.
 *
 * @prop {ActionType | ActionFn | false} [imageClickAction]
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} [bgClickAction]
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} [tapAction]
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} [doubleTapAction]
 * Refer to click and tap actions page.
 *
 * @prop {number=} preloaderDelay
 * Delay before the loading indicator will be displayed,
 * if image is loaded during it - the indicator will not be displayed at all. Can be zero.
 *
 * @prop {string=} indexIndicatorSep
 * Used for slide count indicator ("1 of 10 ").
 *
 * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipe) => { x: number; y: number }} [getViewportSizeFn]
 * A function that should return slide viewport width and height, in format {x: 100, y: 100}.
 *
 * @prop {string=} errorMsg
 * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.
 *
 * @prop {[number, number]=} preload
 * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,
 * first one - number of items to preload before the current image, second one - after the current image.
 * Two nearby images are always loaded.
 *
 * @prop {string=} mainClass
 * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.
 * Example on Styling page.
 *
 * @prop {HTMLElement=} appendToEl
 * Element to which PhotoSwipe dialog will be appended when it opens.
 *
 * @prop {number=} maxWidthToAnimate
 * Maximum width of image to animate, if initial rendered image width
 * is larger than this value - the opening/closing transition will be automatically disabled.
 *
 * @prop {string=} closeTitle
 * Translating
 *
 * @prop {string=} zoomTitle
 * Translating
 *
 * @prop {string=} arrowPrevTitle
 * Translating
 *
 * @prop {string=} arrowNextTitle
 * Translating
 *
 * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]
 * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).
 * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.
 *
 * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.
 *
 * @prop {number=} index
 * Defines start slide index.
 *
 * @prop {(e: MouseEvent) => number} [getClickedIndexFn]
 *
 * @prop {boolean=} arrowPrev
 * @prop {boolean=} arrowNext
 * @prop {boolean=} zoom
 * @prop {boolean=} close
 * @prop {boolean=} counter
 *
 * @prop {string=} arrowPrevSVG
 * @prop {string=} arrowNextSVG
 * @prop {string=} zoomSVG
 * @prop {string=} closeSVG
 * @prop {string=} counterSVG
 *
 * @prop {string=} arrowPrevTitle
 * @prop {string=} arrowNextTitle
 * @prop {string=} zoomTitle
 * @prop {string=} closeTitle
 * @prop {string=} counterTitle
 *
 * @prop {ZoomLevelOption=} initialZoomLevel
 * @prop {ZoomLevelOption=} secondaryZoomLevel
 * @prop {ZoomLevelOption=} maxZoomLevel
 *
 * @prop {boolean=} mouseMovePan
 * @prop {Point | null} [initialPointerPos]
 * @prop {boolean=} showHideOpacity
 *
 * @prop {PhotoSwipeModuleOption} [pswpModule]
 * @prop {() => Promise<any>} [openPromise]
 * @prop {boolean=} preloadFirstSlide
 * @prop {ElementProvider=} gallery
 * @prop {string=} gallerySelector
 * @prop {ElementProvider=} children
 * @prop {string=} childSelector
 * @prop {string | false} [thumbSelector]
 */

/** @type {PhotoSwipeOptions} */
const defaultOptions = {
  allowPanToNext: true,
  spacing: 0.1,
  loop: true,
  pinchToClose: true,
  closeOnVerticalDrag: true,
  hideAnimationDuration: 333,
  showAnimationDuration: 333,
  zoomAnimationDuration: 333,
  escKey: true,
  arrowKeys: true,
  returnFocus: true,
  maxWidthToAnimate: 4000,
  clickToCloseNonZoomable: true,
  imageClickAction: 'zoom-or-close',
  bgClickAction: 'close',
  tapAction: 'toggle-controls',
  doubleTapAction: 'zoom',
  indexIndicatorSep: ' / ',
  preloaderDelay: 2000,
  bgOpacity: 0.8,

  index: 0,
  errorMsg: 'The image cannot be loaded',
  preload: [1, 2],
  easing: 'cubic-bezier(.4,0,.22,1)'
};

/**
 * PhotoSwipe Core
 */
class PhotoSwipe extends PhotoSwipeBase {
  /**
   * @param {PhotoSwipeOptions} options
   */
  constructor(options) {
    super();

    this._prepareOptions(options);

    /**
     * offset of viewport relative to document
     *
     * @type {{ x?: number; y?: number }}
     */
    this.offset = {};

    /**
     * @type {{ x?: number; y?: number }}
     * @private
     */
    this._prevViewportSize = {};

    /**
     * Size of scrollable PhotoSwipe viewport
     *
     * @type {{ x?: number; y?: number }}
     */
    this.viewportSize = {};

    /**
     * background (backdrop) opacity
     *
     * @type {number}
     */
    this.bgOpacity = 1;

    /** @type {HTMLDivElement} */
    this.topBar = undefined;

    this.events = new DOMEvents();

    /** @type {Animations} */
    this.animations = new Animations();

    this.mainScroll = new MainScroll(this);
    this.gestures = new Gestures(this);
    this.opener = new Opener(this);
    this.keyboard = new Keyboard(this);
    this.contentLoader = new ContentLoader(this);
  }

  init() {
    if (this.isOpen || this.isDestroying) {
      return;
    }

    this.isOpen = true;
    this.dispatch('init'); // legacy
    this.dispatch('beforeOpen');

    this._createMainStructure();

    // add classes to the root element of PhotoSwipe
    let rootClasses = 'pswp--open';
    if (this.gestures.supportsTouch) {
      rootClasses += ' pswp--touch';
    }
    if (this.options.mainClass) {
      rootClasses += ' ' + this.options.mainClass;
    }
    this.element.className += ' ' + rootClasses;

    this.currIndex = this.options.index || 0;
    this.potentialIndex = this.currIndex;
    this.dispatch('firstUpdate'); // starting index can be modified here

    // initialize scroll wheel handler to block the scroll
    this.scrollWheel = new ScrollWheel(this);

    // sanitize index
    if (Number.isNaN(this.currIndex)
        || this.currIndex < 0
        || this.currIndex >= this.getNumItems()) {
      this.currIndex = 0;
    }

    if (!this.gestures.supportsTouch) {
      // enable mouse features if no touch support detected
      this.mouseDetected();
    }

    // causes forced synchronous layout
    this.updateSize();

    this.offset.y = window.pageYOffset;

    this._initialItemData = this.getItemData(this.currIndex);
    this.dispatch('gettingData', {
      index: this.currIndex,
      data: this._initialItemData,
      slide: undefined
    });

    // *Layout* - calculate size and position of elements here
    this._initialThumbBounds = this.getThumbBounds();
    this.dispatch('initialLayout');

    this.on('openingAnimationEnd', () => {
      this.mainScroll.itemHolders[0].el.style.display = 'block';
      this.mainScroll.itemHolders[2].el.style.display = 'block';

      // Add content to the previous and next slide
      this.setContent(this.mainScroll.itemHolders[0], this.currIndex - 1);
      this.setContent(this.mainScroll.itemHolders[2], this.currIndex + 1);

      this.appendHeavy();

      this.contentLoader.updateLazy();

      this.events.add(window, 'resize', this._handlePageResize.bind(this));
      this.events.add(window, 'scroll', this._updatePageScrollOffset.bind(this));
      this.dispatch('bindEvents');
    });

    // set content for center slide (first time)
    this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
    this.dispatch('change');

    this.opener.open();

    this.dispatch('afterInit');

    return true;
  }

  /**
   * Get looped slide index
   * (for example, -1 will return the last slide)
   *
   * @param {number} index
   */
  getLoopedIndex(index) {
    const numSlides = this.getNumItems();

    if (this.options.loop) {
      if (index > numSlides - 1) {
        index -= numSlides;
      }

      if (index < 0) {
        index += numSlides;
      }
    }

    index = clamp(index, 0, numSlides - 1);

    return index;
  }

  appendHeavy() {
    this.mainScroll.itemHolders.forEach((itemHolder) => {
      if (itemHolder.slide) {
        itemHolder.slide.appendHeavy();
      }
    });
  }

  /**
   * Change the slide
   * @param {number} index New index
   */
  goTo(index) {
    this.mainScroll.moveIndexBy(
      this.getLoopedIndex(index) - this.potentialIndex
    );
  }

  /**
   * Go to the next slide.
   */
  next() {
    this.goTo(this.potentialIndex + 1);
  }

  /**
   * Go to the previous slide.
   */
  prev() {
    this.goTo(this.potentialIndex - 1);
  }

  /**
   * @see slide/slide.js zoomTo
   *
   * @param {Parameters<Slide['zoomTo']>} args
   */
  zoomTo(...args) {
    this.currSlide.zoomTo(...args);
  }

  /**
   * @see slide/slide.js toggleZoom
   */
  toggleZoom() {
    this.currSlide.toggleZoom();
  }

  /**
   * Close the gallery.
   * After closing transition ends - destroy it
   */
  close() {
    if (!this.opener.isOpen || this.isDestroying) {
      return;
    }

    this.isDestroying = true;

    this.dispatch('close');

    this.events.removeAll();
    this.opener.close();
  }

  /**
   * Destroys the gallery:
   * - instantly closes the gallery
   * - unbinds events,
   * - cleans intervals and timeouts
   * - removes elements from DOM
   */
  destroy() {
    if (!this.isDestroying) {
      this.options.showHideAnimationType = 'none';
      this.close();
      return;
    }

    this.dispatch('destroy');

    this.listeners = null;

    this.scrollWrap.ontouchmove = null;
    this.scrollWrap.ontouchend = null;

    this.element.remove();

    this.mainScroll.itemHolders.forEach((itemHolder) => {
      if (itemHolder.slide) {
        itemHolder.slide.destroy();
      }
    });

    this.contentLoader.destroy();
    this.events.removeAll();
  }

  /**
   * Refresh/reload content of a slide by its index
   *
   * @param {number} slideIndex
   */
  refreshSlideContent(slideIndex) {
    this.contentLoader.removeByIndex(slideIndex);
    this.mainScroll.itemHolders.forEach((itemHolder, i) => {
      let potentialHolderIndex = this.currSlide.index - 1 + i;
      if (this.canLoop()) {
        potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);
      }
      if (potentialHolderIndex === slideIndex) {
        // set the new slide content
        this.setContent(itemHolder, slideIndex, true);

        // activate the new slide if it's current
        if (i === 1) {
          /** @type {Slide} */
          this.currSlide = itemHolder.slide;
          itemHolder.slide.setIsActive(true);
        }
      }
    });

    this.dispatch('change');
  }


  /**
   * Set slide content
   *
   * @param {ItemHolder} holder mainScroll.itemHolders array item
   * @param {number} index Slide index
   * @param {boolean=} force If content should be set even if index wasn't changed
   */
  setContent(holder, index, force) {
    if (this.canLoop()) {
      index = this.getLoopedIndex(index);
    }

    if (holder.slide) {
      if (holder.slide.index === index && !force) {
        // exit if holder already contains this slide
        // this could be common when just three slides are used
        return;
      }

      // destroy previous slide
      holder.slide.destroy();
      holder.slide = null;
    }

    // exit if no loop and index is out of bounds
    if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
      return;
    }

    const itemData = this.getItemData(index);
    holder.slide = new Slide(itemData, index, this);

    // set current slide
    if (index === this.currIndex) {
      this.currSlide = holder.slide;
    }

    holder.slide.append(holder.el);
  }

  getViewportCenterPoint() {
    return {
      x: this.viewportSize.x / 2,
      y: this.viewportSize.y / 2
    };
  }

  /**
   * Update size of all elements.
   * Executed on init and on page resize.
   *
   * @param {boolean=} force Update size even if size of viewport was not changed.
   */
  updateSize(force) {
    // let item;
    // let itemIndex;

    if (this.isDestroying) {
      // exit if PhotoSwipe is closed or closing
      // (to avoid errors, as resize event might be delayed)
      return;
    }

    //const newWidth = this.scrollWrap.clientWidth;
    //const newHeight = this.scrollWrap.clientHeight;

    const newViewportSize = getViewportSize(this.options, this);

    if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
      // Exit if dimensions were not changed
      return;
    }

    //this._prevViewportSize.x = newWidth;
    //this._prevViewportSize.y = newHeight;
    equalizePoints(this._prevViewportSize, newViewportSize);

    this.dispatch('beforeResize');

    equalizePoints(this.viewportSize, this._prevViewportSize);

    this._updatePageScrollOffset();

    this.dispatch('viewportSize');

    // Resize slides only after opener animation is finished
    // and don't re-calculate size on inital size update
    this.mainScroll.resize(this.opener.isOpen);

    if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {
      this.mouseDetected();
    }

    this.dispatch('resize');
  }

  /**
   * @param {number} opacity
   */
  applyBgOpacity(opacity) {
    this.bgOpacity = Math.max(opacity, 0);
    this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
  }

  /**
   * Whether mouse is detected
   */
  mouseDetected() {
    if (!this.hasMouse) {
      this.hasMouse = true;
      this.element.classList.add('pswp--has_mouse');
    }
  }

  /**
   * Page resize event handler
   *
   * @private
   */
  _handlePageResize() {
    this.updateSize();

    // In iOS webview, if element size depends on document size,
    // it'll be measured incorrectly in resize event
    //
    // https://bugs.webkit.org/show_bug.cgi?id=170595
    // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d
    if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
      setTimeout(() => {
        this.updateSize();
      }, 500);
    }
  }

  /**
   * Page scroll offset is used
   * to get correct coordinates
   * relative to PhotoSwipe viewport.
   *
   * @private
   */
  _updatePageScrollOffset() {
    this.setScrollOffset(0, window.pageYOffset);
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  setScrollOffset(x, y) {
    this.offset.x = x;
    this.offset.y = y;
    this.dispatch('updateScrollOffset');
  }

  /**
   * Create main HTML structure of PhotoSwipe,
   * and add it to DOM
   *
   * @private
   */
  _createMainStructure() {
    // root DOM element of PhotoSwipe (.pswp)
    this.element = createElement('pswp');
    this.element.setAttribute('tabindex', '-1');
    this.element.setAttribute('role', 'dialog');

    // template is legacy prop
    this.template = this.element;

    // Background is added as a separate element,
    // as animating opacity is faster than animating rgba()
    this.bg = createElement('pswp__bg', false, this.element);
    this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);
    this.container = createElement('pswp__container', false, this.scrollWrap);

    // aria pattern: carousel
    this.scrollWrap.setAttribute('aria-roledescription', 'carousel');
    this.container.setAttribute('aria-live', 'off');
    this.container.setAttribute('id', 'pswp__items');

    this.mainScroll.appendHolders();

    this.ui = new UI(this);
    this.ui.init();

    // append to DOM
    (this.options.appendToEl || document.body).appendChild(this.element);
  }


  /**
   * Get position and dimensions of small thumbnail
   *   {x:,y:,w:}
   *
   * Height is optional (calculated based on the large image)
   */
  getThumbBounds() {
    return getThumbBounds(
      this.currIndex,
      this.currSlide ? this.currSlide.data : this._initialItemData,
      this
    );
  }

  /**
   * If the PhotoSwipe can have continious loop
   * @returns Boolean
   */
  canLoop() {
    return (this.options.loop && this.getNumItems() > 2);
  }

  /**
   * @param {PhotoSwipeOptions} options
   * @private
   */
  _prepareOptions(options) {
    if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {
      options.showHideAnimationType = 'none';
      options.zoomAnimationDuration = 0;
    }

    /** @type {PhotoSwipeOptions}*/
    this.options = {
      ...defaultOptions,
      ...options
    };
  }
}


//# sourceMappingURL=photoswipe.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcGhvdG9zd2lwZV9kaXN0X3Bob3Rvc3dpcGVfZXNtX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsa0JBQWtCO0FBQ2hDLFdBQVcsU0FBUztBQUNwQixXQUFXLElBQUk7QUFDZixXQUFXLHdCQUF3QjtBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsWUFBWTtBQUN0QjtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixVQUFVLFVBQVU7QUFDcEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQixVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSxTQUFTO0FBQ25CLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsVUFBVTtBQUNwQixVQUFVLDZCQUE2QjtBQUN2QyxVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsa0RBQWtEO0FBQzVELFVBQVUseUZBQXlGO0FBQ25HLFVBQVUsNEJBQTRCO0FBQ3RDLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsY0FBYywwREFBMEQ7QUFDeEU7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakUsTUFBTTtBQUNOLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGNBQWMsb0NBQW9DO0FBQ2xELGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLG9DQUFvQztBQUNsRDtBQUNBLGdCQUFnQixXQUFXLFdBQVcsV0FBVyxjQUFjLFdBQVcsV0FBVyxXQUFXLGVBQWU7QUFDL0c7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsMkNBQTJDO0FBQ3pELGNBQWMsb0NBQW9DO0FBQ2xELGNBQWMsOENBQThDO0FBQzVELGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMscUNBQXFDO0FBQ25ELGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsMENBQTBDO0FBQ3hELGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQSxnQkFBZ0IsWUFBWSxjQUFjO0FBQzFDO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksa0JBQWtCLG1CQUFtQjtBQUNqRCxZQUFZLGtCQUFrQixtQkFBbUI7QUFDakQsWUFBWSxrQkFBa0IsY0FBYyxxQkFBcUI7QUFDakUsWUFBWSxrQkFBa0IsZ0JBQWdCO0FBQzlDLFlBQVksa0JBQWtCLGVBQWUsa0JBQWtCO0FBQy9ELFlBQVksa0JBQWtCLGVBQWUsZ0JBQWdCLGdCQUFnQjtBQUM3RSxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYywrQkFBK0I7QUFDekQsWUFBWSxjQUFjLCtCQUErQjtBQUN6RCxZQUFZLGNBQWMsK0JBQStCO0FBQ3pELFlBQVksY0FBYywrQkFBK0I7QUFDekQ7QUFDQSxZQUFZLGdDQUFnQztBQUM1QyxZQUFZLFdBQVcscUJBQXFCO0FBQzVDLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksZ0RBQWdEO0FBQzVELFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsV0FBVztBQUNyQixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGlGQUFpRjtBQUM3RixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGdCQUFnQjtBQUM1QixVQUFVLFdBQVc7QUFDckIsWUFBWSw2QkFBNkI7QUFDekMsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxlQUFlLHVCQUF1QjtBQUNsRCxVQUFVLFdBQVc7QUFDckIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsV0FBVztBQUNyQixVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCLFlBQVksNENBQTRDO0FBQ3hELFlBQVkscUJBQXFCLGlCQUFpQjtBQUNsRCxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxVQUFVLHNEQUFzRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFGQUFxRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtFQUErRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNFQUFzRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBEQUEwRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJEQUEyRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUErRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUVBQXFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQTREO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkVBQTZFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUVBQXFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQXdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsZUFBZSxpREFBaUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsYUFBYSw2R0FBNkc7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLGFBQWEsR0FBRztBQUNoQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUMsYUFBYSxHQUFHO0FBQ2hCLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxhQUFhLEdBQUc7QUFDaEIsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQyxhQUFhLEdBQUc7QUFDaEIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLGFBQWEsR0FBRztBQUNoQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsd0JBQXdCO0FBQ3JDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLG9DQUFvQztBQUNsRCxjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQ0FBa0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpREFBaUQ7QUFDaEcsNENBQTRDLGtDQUFrQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOEJBQThCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaURBQWlEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyxvQ0FBb0M7QUFDbEQsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGtEQUFrRDtBQUM3RCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxvQ0FBb0M7QUFDbEQsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWMsOENBQThDO0FBQzVELGNBQWMsK0NBQStDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQsY0FBYyxpREFBaUQ7QUFDL0QsY0FBYyw0Q0FBNEM7QUFDMUQsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxtREFBbUQ7QUFDakUsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxZQUFZLHdCQUF3QjtBQUNoRSxnQkFBZ0IsWUFBWSxjQUFjO0FBQzFDLGdCQUFnQixhQUFhLGdCQUFnQixjQUFjLGlCQUFpQjtBQUM1RSxjQUFjLGFBQWE7QUFDM0IsZ0JBQWdCLHNCQUFzQix5QkFBeUI7QUFDL0QsY0FBYyxvQ0FBb0M7QUFDbEQsY0FBYyxxREFBcUQ7QUFDbkUsY0FBYyxpRUFBaUU7QUFDL0UsY0FBYyxxQkFBcUIsNkJBQTZCO0FBQ2hFLGNBQWMsa0ZBQWtGO0FBQ2hHO0FBQ0E7QUFDQSxhQUFhLGdFQUFnRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLFVBQVUscUVBQXFFO0FBQy9FO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBLFVBQVUsb0RBQW9ELFdBQVcsYUFBYTtBQUN0Riw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBLFVBQVUsVUFBVTtBQUNwQixVQUFVLFVBQVU7QUFDcEIsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsVUFBVTtBQUNwQixVQUFVLFVBQVU7QUFDcEI7QUFDQSxVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsY0FBYztBQUN4QixVQUFVLFVBQVU7QUFDcEI7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLG9CQUFvQjtBQUM5QixVQUFVLFVBQVU7QUFDcEIsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsa0JBQWtCO0FBQzVCLFVBQVUsU0FBUztBQUNuQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bob3Rvc3dpcGUvZGlzdC9waG90b3N3aXBlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBQaG90b1N3aXBlIDUuMy40IC0gaHR0cHM6Ly9waG90b3N3aXBlLmNvbVxuICAqIChjKSAyMDIyIERteXRybyBTZW1lbm92XG4gICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xyXG5cclxuLyoqIEB0eXBlZGVmIHt1bmRlZmluZWQgfCBudWxsIHwgZmFsc2UgfCAnJyB8IDB9IEZhbHN5ICovXHJcbi8qKiBAdHlwZWRlZiB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBIVE1MRWxlbWVudFRhZ05hbWUgKi9cclxuXHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUge0hUTUxFbGVtZW50VGFnTmFtZSB8IEZhbHN5fSBbVD1cImRpdlwiXVxyXG4gKiBAdGVtcGxhdGUge05vZGUgfCB1bmRlZmluZWR9IFtOb2RlVG9BcHBlbmRFbGVtZW50VG89dW5kZWZpbmVkXVxyXG4gKiBAcGFyYW0ge3N0cmluZz19IGNsYXNzTmFtZVxyXG4gKiBAcGFyYW0ge1Q9fSBbdGFnTmFtZV1cclxuICogQHBhcmFtIHtOb2RlVG9BcHBlbmRFbGVtZW50VG89fSBhcHBlbmRUb0VsXHJcbiAqIEByZXR1cm5zIHtUIGV4dGVuZHMgSFRNTEVsZW1lbnRUYWdOYW1lID8gSFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdIDogSFRNTEVsZW1lbnRUYWdOYW1lTWFwWydkaXYnXX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLCB0YWdOYW1lLCBhcHBlbmRUb0VsKSB7XHJcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUgfHwgJ2RpdicpO1xyXG4gIGlmIChjbGFzc05hbWUpIHtcclxuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICB9XHJcbiAgaWYgKGFwcGVuZFRvRWwpIHtcclxuICAgIGFwcGVuZFRvRWwuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIH1cclxuICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsaXplUG9pbnRzKHAxLCBwMikge1xyXG4gIHAxLnggPSBwMi54O1xyXG4gIHAxLnkgPSBwMi55O1xyXG4gIGlmIChwMi5pZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBwMS5pZCA9IHAyLmlkO1xyXG4gIH1cclxuICByZXR1cm4gcDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1BvaW50fSBwXHJcbiAqL1xyXG5mdW5jdGlvbiByb3VuZFBvaW50KHApIHtcclxuICBwLnggPSBNYXRoLnJvdW5kKHAueCk7XHJcbiAgcC55ID0gTWF0aC5yb3VuZChwLnkpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZUJldHdlZW4ocDEsIHAyKSB7XHJcbiAgY29uc3QgeCA9IE1hdGguYWJzKHAxLnggLSBwMi54KTtcclxuICBjb25zdCB5ID0gTWF0aC5hYnMocDEueSAtIHAyLnkpO1xyXG4gIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xyXG59XHJcblxyXG4vKipcclxuICogV2hldGhlciBYIGFuZCBZIHBvc2l0aW9ucyBvZiBwb2ludHMgYXJlIHF1YWxcclxuICpcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICovXHJcbmZ1bmN0aW9uIHBvaW50c0VxdWFsKHAxLCBwMikge1xyXG4gIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZmxvYXQgcmVzdWx0IGJldHdlZW4gdGhlIG1pbiBhbmQgbWF4IHZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcclxuICovXHJcbmZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcclxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRyYW5zZm9ybSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXI9fSB5XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2NhbGVcclxuICovXHJcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtU3RyaW5nKHgsIHksIHNjYWxlKSB7XHJcbiAgbGV0IHByb3BWYWx1ZSA9ICd0cmFuc2xhdGUzZCgnXHJcbiAgICArIHggKyAncHgsJyArICh5IHx8IDApICsgJ3B4J1xyXG4gICAgKyAnLDApJztcclxuXHJcbiAgaWYgKHNjYWxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHByb3BWYWx1ZSArPSAnIHNjYWxlM2QoJ1xyXG4gICAgICArIHNjYWxlICsgJywnICsgc2NhbGVcclxuICAgICAgKyAnLDEpJztcclxuICB9XHJcblxyXG4gIHJldHVybiBwcm9wVmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBseSB0cmFuc2Zvcm06dHJhbnNsYXRlKHgsIHkpIHNjYWxlKHNjYWxlKSB0byBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0geVxyXG4gKiBAcGFyYW0ge251bWJlcj19IHNjYWxlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIHgsIHksIHNjYWxlKSB7XHJcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2Zvcm1TdHJpbmcoeCwgeSwgc2NhbGUpO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0Q1NTRWFzaW5nID0gJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSc7XHJcblxyXG4vKipcclxuICogQXBwbHkgQ1NTIHRyYW5zaXRpb24gdG8gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHByb3AgQ1NTIHByb3BlcnR5IHRvIGFuaW1hdGVcclxuICogQHBhcmFtIHtudW1iZXI9fSBkdXJhdGlvbiBpbiBtc1xyXG4gKiBAcGFyYW0ge3N0cmluZz19IGVhc2UgQ1NTIGVhc2luZyBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvblN0eWxlKGVsLCBwcm9wLCBkdXJhdGlvbiwgZWFzZSkge1xyXG4gIC8vIGluT3V0OiAnY3ViaWMtYmV6aWVyKC40LCAwLCAuMjIsIDEpJywgLy8gZm9yIFwidG9nZ2xlIHN0YXRlXCIgdHJhbnNpdGlvbnNcclxuICAvLyBvdXQ6ICdjdWJpYy1iZXppZXIoMCwgMCwgLjIyLCAxKScsIC8vIGZvciBcInNob3dcIiB0cmFuc2l0aW9uc1xyXG4gIC8vIGluOiAnY3ViaWMtYmV6aWVyKC40LCAwLCAxLCAxKScvLyBmb3IgXCJoaWRlXCIgdHJhbnNpdGlvbnNcclxuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gcHJvcFxyXG4gICAgPyAocHJvcCArICcgJyArIGR1cmF0aW9uICsgJ21zICcgKyAoZWFzZSB8fCBkZWZhdWx0Q1NTRWFzaW5nKSlcclxuICAgIDogJ25vbmUnO1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHkgd2lkdGggYW5kIGhlaWdodCBDU1MgcHJvcGVydGllcyB0byBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB3XHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBoXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRXaWR0aEhlaWdodChlbCwgdywgaCkge1xyXG4gIGVsLnN0eWxlLndpZHRoID0gKHR5cGVvZiB3ID09PSAnbnVtYmVyJykgPyAodyArICdweCcpIDogdztcclxuICBlbC5zdHlsZS5oZWlnaHQgPSAodHlwZW9mIGggPT09ICdudW1iZXInKSA/IChoICsgJ3B4JykgOiBoO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25TdHlsZShlbCkge1xyXG4gIHNldFRyYW5zaXRpb25TdHlsZShlbCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50IHwgdm9pZD59XHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVJbWFnZShpbWcpIHtcclxuICBpZiAoJ2RlY29kZScgaW4gaW1nKSB7XHJcbiAgICByZXR1cm4gaW1nLmRlY29kZSgpLmNhdGNoKCgpID0+IHt9KTtcclxuICB9XHJcblxyXG4gIGlmIChpbWcuY29tcGxldGUpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW1nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWcpO1xyXG4gICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiBAdHlwZWRlZiB7TE9BRF9TVEFURVtrZXlvZiBMT0FEX1NUQVRFXX0gTG9hZFN0YXRlICovXHJcbi8qKiBAdHlwZSB7eyBJRExFOiAnaWRsZSc7IExPQURJTkc6ICdsb2FkaW5nJzsgTE9BREVEOiAnbG9hZGVkJzsgRVJST1I6ICdlcnJvcicgfX0gKi9cclxuY29uc3QgTE9BRF9TVEFURSA9IHtcclxuICBJRExFOiAnaWRsZScsXHJcbiAgTE9BRElORzogJ2xvYWRpbmcnLFxyXG4gIExPQURFRDogJ2xvYWRlZCcsXHJcbiAgRVJST1I6ICdlcnJvcicsXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGNsaWNrIG9yIGtleWRvd24gZXZlbnQgd2FzIGRpc3BhdGNoZWRcclxuICogd2l0aCBhIHNwZWNpYWwga2V5IG9yIHZpYSBtb3VzZSB3aGVlbC5cclxuICpcclxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudH0gZVxyXG4gKi9cclxuZnVuY3Rpb24gc3BlY2lhbEtleVVzZWQoZSkge1xyXG4gIGlmIChlLndoaWNoID09PSAyIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5zaGlmdEtleSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgYGdhbGxlcnlgIG9yIGBjaGlsZHJlbmAgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5FbGVtZW50UHJvdmlkZXJ9IG9wdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZz19IGxlZ2FjeVNlbGVjdG9yXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBEb2N1bWVudH0gW3BhcmVudF1cclxuICogQHJldHVybnMgSFRNTEVsZW1lbnRbXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RWxlbWVudHNGcm9tT3B0aW9uKG9wdGlvbiwgbGVnYWN5U2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50KSB7XHJcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xyXG4gIGxldCBlbGVtZW50cyA9IFtdO1xyXG5cclxuICBpZiAob3B0aW9uIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgZWxlbWVudHMgPSBbb3B0aW9uXTtcclxuICB9IGVsc2UgaWYgKG9wdGlvbiBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IEFycmF5LmlzQXJyYXkob3B0aW9uKSkge1xyXG4gICAgZWxlbWVudHMgPSBBcnJheS5mcm9tKG9wdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgPyBvcHRpb24gOiBsZWdhY3lTZWxlY3RvcjtcclxuICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICBlbGVtZW50cyA9IEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGJyb3dzZXIgaXMgU2FmYXJpXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgcmV0dXJuICEhKG5hdmlnYXRvci52ZW5kb3IgJiYgbmF2aWdhdG9yLnZlbmRvci5tYXRjaCgvYXBwbGUvaSkpO1xyXG59XG5cbi8vIERldGVjdCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnRcclxubGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG50cnkge1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICAgIGdldDogKCkgPT4ge1xyXG4gICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0pKTtcclxufSBjYXRjaCAoZSkge31cclxuLyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb29sSXRlbVxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnQgfCBXaW5kb3cgfCBEb2N1bWVudH0gdGFyZ2V0XHJcbiAqIEBwcm9wIHtzdHJpbmd9IHR5cGVcclxuICogQHByb3AgeyhlOiBhbnkpID0+IHZvaWR9IGxpc3RlbmVyXHJcbiAqIEBwcm9wIHtib29sZWFufSBwYXNzaXZlXHJcbiAqL1xyXG5cclxuY2xhc3MgRE9NRXZlbnRzIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1Bvb2xJdGVtW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wb29sID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFdpbmRvdyB8IERvY3VtZW50fSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDYW4gYmUgbXVsdGlwbGUsIHNlcGFyYXRlZCBieSBzcGFjZS5cclxuICAgKiBAcGFyYW0geyhlOiBhbnkpID0+IHZvaWR9IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcGFzc2l2ZVxyXG4gICAqL1xyXG4gIGFkZCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XHJcbiAgICB0aGlzLl90b2dnbGVMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgV2luZG93IHwgRG9jdW1lbnR9IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHsoZTogYW55KSA9PiB2b2lkfSBsaXN0ZW5lclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhc3NpdmVcclxuICAgKi9cclxuICByZW1vdmUodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcGFzc2l2ZSkge1xyXG4gICAgdGhpcy5fdG9nZ2xlTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcGFzc2l2ZSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFsbCBib3VuZCBldmVudHNcclxuICAgKi9cclxuICByZW1vdmVBbGwoKSB7XHJcbiAgICB0aGlzLl9wb29sLmZvckVhY2goKHBvb2xJdGVtKSA9PiB7XHJcbiAgICAgIHRoaXMuX3RvZ2dsZUxpc3RlbmVyKFxyXG4gICAgICAgIHBvb2xJdGVtLnRhcmdldCxcclxuICAgICAgICBwb29sSXRlbS50eXBlLFxyXG4gICAgICAgIHBvb2xJdGVtLmxpc3RlbmVyLFxyXG4gICAgICAgIHBvb2xJdGVtLnBhc3NpdmUsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICB0cnVlXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3Bvb2wgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgb3IgcmVtb3ZlcyBldmVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFdpbmRvdyB8IERvY3VtZW50fSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7KGU6IGFueSkgPT4gdm9pZH0gbGlzdGVuZXJcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhc3NpdmVcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bmJpbmQgV2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGFkZGVkIG9yIHJlbW92ZWRcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUG9vbCBXaGV0aGVyIGV2ZW50cyBwb29sIHNob3VsZCBiZSBza2lwcGVkXHJcbiAgICovXHJcbiAgX3RvZ2dsZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUsIHVuYmluZCwgc2tpcFBvb2wpIHtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXRob2ROYW1lID0gdW5iaW5kID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInO1xyXG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XHJcbiAgICB0eXBlcy5mb3JFYWNoKChlVHlwZSkgPT4ge1xyXG4gICAgICBpZiAoZVR5cGUpIHtcclxuICAgICAgICAvLyBFdmVudHMgcG9vbCBpcyB1c2VkIHRvIGVhc2lseSB1bmJpbmQgYWxsIGV2ZW50cyB3aGVuIFBob3RvU3dpcGUgaXMgY2xvc2VkLFxyXG4gICAgICAgIC8vIHNvIGRldmVsb3BlciBkb2Vzbid0IG5lZWQgdG8gZG8gdGhpcyBtYW51YWxseVxyXG4gICAgICAgIGlmICghc2tpcFBvb2wpIHtcclxuICAgICAgICAgIGlmICh1bmJpbmQpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIGV2ZW50cyBwb29sXHJcbiAgICAgICAgICAgIHRoaXMuX3Bvb2wgPSB0aGlzLl9wb29sLmZpbHRlcigocG9vbEl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4gcG9vbEl0ZW0udHlwZSAhPT0gZVR5cGVcclxuICAgICAgICAgICAgICAgIHx8IHBvb2xJdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgfHwgcG9vbEl0ZW0udGFyZ2V0ICE9PSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBldmVudHMgcG9vbFxyXG4gICAgICAgICAgICB0aGlzLl9wb29sLnB1c2goe1xyXG4gICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICB0eXBlOiBlVHlwZSxcclxuICAgICAgICAgICAgICBsaXN0ZW5lcixcclxuICAgICAgICAgICAgICBwYXNzaXZlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIG1vc3QgUGhvdG9Td2lwZSBldmVudHMgY2FsbCBwcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICAvLyBhbmQgd2UgZG8gbm90IG5lZWQgYnJvd3NlciB0byBzY3JvbGwgdGhlIHBhZ2VcclxuICAgICAgICBjb25zdCBldmVudE9wdGlvbnMgPSBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IChwYXNzaXZlIHx8IGZhbHNlKSB9IDogZmFsc2U7XHJcblxyXG4gICAgICAgIHRhcmdldFttZXRob2ROYW1lXShcclxuICAgICAgICAgIGVUeXBlLFxyXG4gICAgICAgICAgbGlzdGVuZXIsXHJcbiAgICAgICAgICBldmVudE9wdGlvbnNcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5QaG90b1N3aXBlT3B0aW9uc30gUGhvdG9Td2lwZU9wdGlvbnMgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICovXHJcbmZ1bmN0aW9uIGdldFZpZXdwb3J0U2l6ZShvcHRpb25zLCBwc3dwKSB7XHJcbiAgaWYgKG9wdGlvbnMuZ2V0Vmlld3BvcnRTaXplRm4pIHtcclxuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U2l6ZSA9IG9wdGlvbnMuZ2V0Vmlld3BvcnRTaXplRm4ob3B0aW9ucywgcHN3cCk7XHJcbiAgICBpZiAobmV3Vmlld3BvcnRTaXplKSB7XHJcbiAgICAgIHJldHVybiBuZXdWaWV3cG9ydFNpemU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgeDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxyXG5cclxuICAgIC8vIFRPRE86IGhlaWdodCBvbiBtb2JpbGUgaXMgdmVyeSBpbmNvc2lzdGVudCBkdWUgdG8gdG9vbGJhclxyXG4gICAgLy8gZmluZCBhIHdheSB0byBpbXByb3ZlIHRoaXNcclxuICAgIC8vXHJcbiAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IC0gZG9lc24ndCBzZWVtIHRvIHdvcmsgd2VsbFxyXG4gICAgeTogd2luZG93LmlubmVySGVpZ2h0XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBwYWRkaW5nIG9wdGlvbi5cclxuICogU3VwcG9ydGVkIGZvcm1hdHM6XHJcbiAqXHJcbiAqIC8vIE9iamVjdFxyXG4gKiBwYWRkaW5nOiB7XHJcbiAqICB0b3A6IDAsXHJcbiAqICBib3R0b206IDAsXHJcbiAqICBsZWZ0OiAwLFxyXG4gKiAgcmlnaHQ6IDBcclxuICogfVxyXG4gKlxyXG4gKiAvLyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb2JqZWN0XHJcbiAqIHBhZGRpbmdGbjogKHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSA9PiB7XHJcbiAqICByZXR1cm4ge1xyXG4gKiAgICB0b3A6IDAsXHJcbiAqICAgIGJvdHRvbTogMCxcclxuICogICAgbGVmdDogMCxcclxuICogICAgcmlnaHQ6IDBcclxuICogIH07XHJcbiAqIH1cclxuICpcclxuICogLy8gTGVnYWN5IHZhcmlhbnRcclxuICogcGFkZGluZ0xlZnQ6IDAsXHJcbiAqIHBhZGRpbmdSaWdodDogMCxcclxuICogcGFkZGluZ1RvcDogMCxcclxuICogcGFkZGluZ0JvdHRvbTogMCxcclxuICpcclxuICogQHBhcmFtIHsnbGVmdCcgfCAndG9wJyB8ICdib3R0b20nIHwgJ3JpZ2h0J30gcHJvcFxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBvcHRpb25zIFBob3RvU3dpcGUgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge3sgeD86IG51bWJlcjsgeT86IG51bWJlciB9fSB2aWV3cG9ydFNpemUgUGhvdG9Td2lwZSB2aWV3cG9ydCBzaXplLCBmb3IgZXhhbXBsZTogeyB4OjgwMCwgeTo2MDAgfVxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgRGF0YSBhYm91dCB0aGUgc2xpZGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFNsaWRlIGluZGV4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmdPcHRpb24ocHJvcCwgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpIHtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICBsZXQgcGFkZGluZ1ZhbHVlO1xyXG5cclxuICBpZiAob3B0aW9ucy5wYWRkaW5nRm4pIHtcclxuICAgIHBhZGRpbmdWYWx1ZSA9IG9wdGlvbnMucGFkZGluZ0ZuKHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KVtwcm9wXTtcclxuICB9IGVsc2UgaWYgKG9wdGlvbnMucGFkZGluZykge1xyXG4gICAgcGFkZGluZ1ZhbHVlID0gb3B0aW9ucy5wYWRkaW5nW3Byb3BdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBsZWdhY3lQcm9wTmFtZSA9ICdwYWRkaW5nJyArIHByb3BbMF0udG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAob3B0aW9uc1tsZWdhY3lQcm9wTmFtZV0pIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICBwYWRkaW5nVmFsdWUgPSBvcHRpb25zW2xlZ2FjeVByb3BOYW1lXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBwYWRkaW5nVmFsdWUgfHwgMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7UGhvdG9Td2lwZU9wdGlvbnN9IG9wdGlvbnNcclxuICogQHBhcmFtIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gdmlld3BvcnRTaXplXHJcbiAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICovXHJcbmZ1bmN0aW9uIGdldFBhbkFyZWFTaXplKG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHZpZXdwb3J0U2l6ZS54XHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdsZWZ0Jywgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpXHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdyaWdodCcsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSxcclxuICAgIHk6IHZpZXdwb3J0U2l6ZS55XHJcbiAgICAgIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCd0b3AnLCBvcHRpb25zLCB2aWV3cG9ydFNpemUsIGl0ZW1EYXRhLCBpbmRleClcclxuICAgICAgLSBwYXJzZVBhZGRpbmdPcHRpb24oJ2JvdHRvbScsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KVxyXG4gIH07XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge3sgeD86IG51bWJlcjsgeT86IG51bWJlciB9fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYgeyd4JyB8ICd5J30gQXhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgbWluaW11bSwgbWF4aW11bSBhbmQgaW5pdGlhbCAoY2VudGVyKSBib3VuZHMgb2YgYSBzbGlkZVxyXG4gKi9cclxuY2xhc3MgUGFuQm91bmRzIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlfSBzbGlkZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHNsaWRlKSB7XHJcbiAgICB0aGlzLnNsaWRlID0gc2xpZGU7XHJcblxyXG4gICAgdGhpcy5jdXJyWm9vbUxldmVsID0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5jZW50ZXIgPSB7fTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLm1heCA9IHt9O1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMubWluID0ge307XHJcblxyXG4gICAgdGhpcy5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogX2dldEl0ZW1Cb3VuZHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyWm9vbUxldmVsXHJcbiAgICovXHJcbiAgdXBkYXRlKGN1cnJab29tTGV2ZWwpIHtcclxuICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9IGN1cnJab29tTGV2ZWw7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNsaWRlLndpZHRoKSB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUF4aXMoJ3gnKTtcclxuICAgICAgdGhpcy5fdXBkYXRlQXhpcygneScpO1xyXG4gICAgICB0aGlzLnNsaWRlLnBzd3AuZGlzcGF0Y2goJ2NhbGNCb3VuZHMnLCB7IHNsaWRlOiB0aGlzLnNsaWRlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogX2NhbGN1bGF0ZUl0ZW1Cb3VuZHNGb3JBeGlzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0F4aXN9IGF4aXNcclxuICAgKi9cclxuICBfdXBkYXRlQXhpcyhheGlzKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXMuc2xpZGU7XHJcbiAgICBjb25zdCBlbFNpemUgPSB0aGlzLnNsaWRlW2F4aXMgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gKiB0aGlzLmN1cnJab29tTGV2ZWw7XHJcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IGF4aXMgPT09ICd4JyA/ICdsZWZ0JyA6ICd0b3AnO1xyXG4gICAgY29uc3QgcGFkZGluZyA9IHBhcnNlUGFkZGluZ09wdGlvbihcclxuICAgICAgcGFkZGluZ1Byb3AsXHJcbiAgICAgIHBzd3Aub3B0aW9ucyxcclxuICAgICAgcHN3cC52aWV3cG9ydFNpemUsXHJcbiAgICAgIHRoaXMuc2xpZGUuZGF0YSxcclxuICAgICAgdGhpcy5zbGlkZS5pbmRleFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwYW5BcmVhU2l6ZSA9IHRoaXMuc2xpZGUucGFuQXJlYVNpemVbYXhpc107XHJcblxyXG4gICAgLy8gRGVmYXVsdCBwb3NpdGlvbiBvZiBlbGVtZW50LlxyXG4gICAgLy8gQnkgZGVmYXVsIGl0IGlzIGNlbnRlciBvZiB2aWV3cG9ydDpcclxuICAgIHRoaXMuY2VudGVyW2F4aXNdID0gTWF0aC5yb3VuZCgocGFuQXJlYVNpemUgLSBlbFNpemUpIC8gMikgKyBwYWRkaW5nO1xyXG5cclxuICAgIC8vIG1heGltdW0gcGFuIHBvc2l0aW9uXHJcbiAgICB0aGlzLm1heFtheGlzXSA9IChlbFNpemUgPiBwYW5BcmVhU2l6ZSlcclxuICAgICAgPyBNYXRoLnJvdW5kKHBhbkFyZWFTaXplIC0gZWxTaXplKSArIHBhZGRpbmdcclxuICAgICAgOiB0aGlzLmNlbnRlcltheGlzXTtcclxuXHJcbiAgICAvLyBtaW5pbXVtIHBhbiBwb3NpdGlvblxyXG4gICAgdGhpcy5taW5bYXhpc10gPSAoZWxTaXplID4gcGFuQXJlYVNpemUpXHJcbiAgICAgID8gcGFkZGluZ1xyXG4gICAgICA6IHRoaXMuY2VudGVyW2F4aXNdO1xyXG4gIH1cclxuXHJcbiAgLy8gX2dldFplcm9Cb3VuZHNcclxuICByZXNldCgpIHtcclxuICAgIHRoaXMuY2VudGVyLnggPSAwO1xyXG4gICAgdGhpcy5jZW50ZXIueSA9IDA7XHJcbiAgICB0aGlzLm1heC54ID0gMDtcclxuICAgIHRoaXMubWF4LnkgPSAwO1xyXG4gICAgdGhpcy5taW4ueCA9IDA7XHJcbiAgICB0aGlzLm1pbi55ID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcnJlY3QgcGFuIHBvc2l0aW9uIGlmIGl0J3MgYmV5b25kIHRoZSBib3VuZHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXhpc30gYXhpcyB4IG9yIHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFuT2Zmc2V0XHJcbiAgICovXHJcbiAgY29ycmVjdFBhbihheGlzLCBwYW5PZmZzZXQpIHsgLy8gY2hlY2tQYW5Cb3VuZHNcclxuICAgIHJldHVybiBjbGFtcChwYW5PZmZzZXQsIHRoaXMubWF4W2F4aXNdLCB0aGlzLm1pbltheGlzXSk7XHJcbiAgfVxyXG59XG5cbmNvbnN0IE1BWF9JTUFHRV9XSURUSCA9IDQwMDA7XHJcblxyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5QaG90b1N3aXBlT3B0aW9uc30gUGhvdG9Td2lwZU9wdGlvbnMgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL3NsaWRlLmpzJykuU2xpZGVEYXRhfSBTbGlkZURhdGEgKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7J2ZpdCcgfCAnZmlsbCcgfCBudW1iZXIgfCAoKHpvb21MZXZlbE9iamVjdDogWm9vbUxldmVsKSA9PiBudW1iZXIpfSBab29tTGV2ZWxPcHRpb24gKi9cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyBzbGlkZS5cclxuICogRGVwZW5kcyBvbiB2aWV3cG9ydCBzaXplIGFuZCBpbWFnZSBzaXplLlxyXG4gKi9cclxuY2xhc3MgWm9vbUxldmVsIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBvcHRpb25zIFBob3RvU3dpcGUgb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBTbGlkZSBkYXRhXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFNsaWRlIGluZGV4XHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlPX0gcHN3cCBQaG90b1N3aXBlIGluc3RhbmNlLCBjYW4gYmUgdW5kZWZpbmVkIGlmIG5vdCBpbml0aWFsaXplZCB5ZXRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpdGVtRGF0YSwgaW5kZXgsIHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5pdGVtRGF0YSA9IGl0ZW1EYXRhO1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGluaXRpYWwsIHNlY29uZGFyeSBhbmQgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgc3BlY2lmaWVkIHNsaWRlLlxyXG4gICAqXHJcbiAgICogSXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGVpdGhlciBpbWFnZSBvciB2aWV3cG9ydCBzaXplIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0XHJcbiAgICogQHBhcmFtIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gcGFuQXJlYVNpemVcclxuICAgKi9cclxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgcGFuQXJlYVNpemUpIHtcclxuICAgIHRoaXMuZWxlbWVudFNpemUgPSB7XHJcbiAgICAgIHg6IG1heFdpZHRoLFxyXG4gICAgICB5OiBtYXhIZWlnaHRcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5wYW5BcmVhU2l6ZSA9IHBhbkFyZWFTaXplO1xyXG5cclxuICAgIGNvbnN0IGhSYXRpbyA9IHRoaXMucGFuQXJlYVNpemUueCAvIHRoaXMuZWxlbWVudFNpemUueDtcclxuICAgIGNvbnN0IHZSYXRpbyA9IHRoaXMucGFuQXJlYVNpemUueSAvIHRoaXMuZWxlbWVudFNpemUueTtcclxuXHJcbiAgICB0aGlzLmZpdCA9IE1hdGgubWluKDEsIGhSYXRpbyA8IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbyk7XHJcbiAgICB0aGlzLmZpbGwgPSBNYXRoLm1pbigxLCBoUmF0aW8gPiB2UmF0aW8gPyBoUmF0aW8gOiB2UmF0aW8pO1xyXG5cclxuICAgIC8vIHpvb20udkZpbGwgZGVmaW5lcyB6b29tIGxldmVsIG9mIHRoZSBpbWFnZVxyXG4gICAgLy8gd2hlbiBpdCBoYXMgMTAwJSBvZiB2aWV3cG9ydCB2ZXJ0aWNhbCBzcGFjZSAoaGVpZ2h0KVxyXG4gICAgdGhpcy52RmlsbCA9IE1hdGgubWluKDEsIHZSYXRpbyk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsID0gdGhpcy5fZ2V0SW5pdGlhbCgpO1xyXG4gICAgdGhpcy5zZWNvbmRhcnkgPSB0aGlzLl9nZXRTZWNvbmRhcnkoKTtcclxuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoXHJcbiAgICAgIHRoaXMuaW5pdGlhbCxcclxuICAgICAgdGhpcy5zZWNvbmRhcnksXHJcbiAgICAgIHRoaXMuX2dldE1heCgpXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMubWluID0gTWF0aC5taW4oXHJcbiAgICAgIHRoaXMuZml0LFxyXG4gICAgICB0aGlzLmluaXRpYWwsXHJcbiAgICAgIHRoaXMuc2Vjb25kYXJ5XHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0aGlzLnBzd3ApIHtcclxuICAgICAgdGhpcy5wc3dwLmRpc3BhdGNoKCd6b29tTGV2ZWxzVXBkYXRlJywgeyB6b29tTGV2ZWxzOiB0aGlzLCBzbGlkZURhdGE6IHRoaXMuaXRlbURhdGEgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZXMgdXNlci1kZWZpbmVkIHpvb20gb3B0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geydpbml0aWFsJyB8ICdzZWNvbmRhcnknIHwgJ21heCd9IG9wdGlvblByZWZpeCBab29tIGxldmVsIG9wdGlvbiBwcmVmaXggKGluaXRpYWwsIHNlY29uZGFyeSwgbWF4KVxyXG4gICAqL1xyXG4gIF9wYXJzZVpvb21MZXZlbE9wdGlvbihvcHRpb25QcmVmaXgpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICBjb25zdCBvcHRpb25OYW1lID0gLyoqIEB0eXBlIHsnaW5pdGlhbFpvb21MZXZlbCcgfCAnc2Vjb25kYXJ5Wm9vbUxldmVsJyB8ICdtYXhab29tTGV2ZWwnfSAqLyAob3B0aW9uUHJlZml4ICsgJ1pvb21MZXZlbCcpO1xyXG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSB0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV07XHJcblxyXG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gb3B0aW9uVmFsdWUodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSAnZmlsbCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9uVmFsdWUgPT09ICdmaXQnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTnVtYmVyKG9wdGlvblZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB6b29tIGxldmVsIHRvIHdoaWNoIGltYWdlIHdpbGwgYmUgem9vbWVkIGFmdGVyIGRvdWJsZS10YXAgZ2VzdHVyZSxcclxuICAgKiBvciB3aGVuIHVzZXIgY2xpY2tzIG9uIHpvb20gaWNvbixcclxuICAgKiBvciBtb3VzZS1jbGljayBvbiBpbWFnZSBpdHNlbGYuXHJcbiAgICogSWYgeW91IHJldHVybiAxIGltYWdlIHdpbGwgYmUgem9vbWVkIHRvIGl0cyBvcmlnaW5hbCBzaXplLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldFNlY29uZGFyeSgpIHtcclxuICAgIGxldCBjdXJyWm9vbUxldmVsID0gdGhpcy5fcGFyc2Vab29tTGV2ZWxPcHRpb24oJ3NlY29uZGFyeScpO1xyXG5cclxuICAgIGlmIChjdXJyWm9vbUxldmVsKSB7XHJcbiAgICAgIHJldHVybiBjdXJyWm9vbUxldmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDN4IG9mIFwiZml0XCIgc3RhdGUsIGJ1dCBub3QgbGFyZ2VyIHRoYW4gb3JpZ2luYWxcclxuICAgIGN1cnJab29tTGV2ZWwgPSBNYXRoLm1pbigxLCB0aGlzLmZpdCAqIDMpO1xyXG5cclxuICAgIGlmIChjdXJyWm9vbUxldmVsICogdGhpcy5lbGVtZW50U2l6ZS54ID4gTUFYX0lNQUdFX1dJRFRIKSB7XHJcbiAgICAgIGN1cnJab29tTGV2ZWwgPSBNQVhfSU1BR0VfV0lEVEggLyB0aGlzLmVsZW1lbnRTaXplLng7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnJab29tTGV2ZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgaW5pdGlhbCBpbWFnZSB6b29tIGxldmVsLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldEluaXRpYWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyc2Vab29tTGV2ZWxPcHRpb24oJ2luaXRpYWwnKSB8fCB0aGlzLmZpdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1heGltdW0gem9vbSBsZXZlbCB3aGVuIHVzZXIgem9vbXNcclxuICAgKiB2aWEgem9vbS9waW5jaCBnZXN0dXJlLFxyXG4gICAqIHZpYSBjbWQvY3RybC13aGVlbCBvciB2aWEgdHJhY2twYWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0TWF4KCkge1xyXG4gICAgY29uc3QgY3Vyclpvb21MZXZlbCA9IHRoaXMuX3BhcnNlWm9vbUxldmVsT3B0aW9uKCdtYXgnKTtcclxuXHJcbiAgICBpZiAoY3Vyclpvb21MZXZlbCkge1xyXG4gICAgICByZXR1cm4gY3Vyclpvb21MZXZlbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYXggem9vbSBsZXZlbCBpcyB4NCBmcm9tIFwiZml0IHN0YXRlXCIsXHJcbiAgICAvLyB1c2VkIGZvciB6b29tIGdlc3R1cmUgYW5kIGN0cmwvdHJhY2twYWQgem9vbVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIHRoaXMuZml0ICogNCk7XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYW5kIGFsbG93cyB0byBjb250cm9sIGEgc2luZ2xlIHNsaWRlXHJcbiAqL1xyXG5jbGFzcyBTbGlkZSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTbGlkZURhdGF9IGRhdGFcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkYXRhLCBpbmRleCwgcHN3cCkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcbiAgICB0aGlzLmlzQWN0aXZlID0gKGluZGV4ID09PSBwc3dwLmN1cnJJbmRleCk7XHJcbiAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gMDtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnBhbkFyZWFTaXplID0ge307XHJcblxyXG4gICAgdGhpcy5pc0ZpcnN0U2xpZGUgPSAodGhpcy5pc0FjdGl2ZSAmJiAhcHN3cC5vcGVuZXIuaXNPcGVuKTtcclxuXHJcbiAgICB0aGlzLnpvb21MZXZlbHMgPSBuZXcgWm9vbUxldmVsKHBzd3Aub3B0aW9ucywgZGF0YSwgaW5kZXgsIHBzd3ApO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnZ2V0dGluZ0RhdGEnLCB7XHJcbiAgICAgIHNsaWRlOiB0aGlzLFxyXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXHJcbiAgICAgIGluZGV4XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnBhbiA9IHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLnBzd3AuY29udGVudExvYWRlci5nZXRDb250ZW50QnlTbGlkZSh0aGlzKTtcclxuICAgIHRoaXMuY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgncHN3cF9fem9vbS13cmFwJyk7XHJcblxyXG4gICAgdGhpcy5jdXJyWm9vbUxldmVsID0gMTtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGVudC53aWR0aDtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRlbnQuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuYm91bmRzID0gbmV3IFBhbkJvdW5kcyh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnByZXZEaXNwbGF5ZWRXaWR0aCA9IC0xO1xyXG4gICAgdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0ID0gLTE7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZUluaXQnLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhpcyBzbGlkZSBpcyBhY3RpdmUvY3VycmVudC92aXNpYmxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWN0aXZlXHJcbiAgICovXHJcbiAgc2V0SXNBY3RpdmUoaXNBY3RpdmUpIHtcclxuICAgIGlmIChpc0FjdGl2ZSAmJiAhdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAvLyBzbGlkZSBqdXN0IGJlY2FtZSBhY3RpdmVcclxuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgfSBlbHNlIGlmICghaXNBY3RpdmUgJiYgdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAvLyBzbGlkZSBqdXN0IGJlY2FtZSBub24tYWN0aXZlXHJcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kcyBzbGlkZSBjb250ZW50IHRvIERPTVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaG9sZGVyRWxlbWVudFxyXG4gICAqL1xyXG4gIGFwcGVuZChob2xkZXJFbGVtZW50KSB7XHJcbiAgICB0aGlzLmhvbGRlckVsZW1lbnQgPSBob2xkZXJFbGVtZW50O1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG5cclxuICAgIC8vIFNsaWRlIGFwcGVuZGVkIHRvIERPTVxyXG4gICAgaWYgKCF0aGlzLmRhdGEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xyXG5cclxuICAgIHRoaXMubG9hZCgpO1xyXG4gICAgdGhpcy51cGRhdGVDb250ZW50U2l6ZSgpO1xyXG4gICAgdGhpcy5hcHBlbmRIZWF2eSgpO1xyXG5cclxuICAgIHRoaXMuaG9sZGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy56b29tQW5kUGFuVG9Jbml0aWFsKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdmaXJzdFpvb21QYW4nLCB7IHNsaWRlOiB0aGlzIH0pO1xyXG5cclxuICAgIHRoaXMuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnYWZ0ZXJTZXRDb250ZW50JywgeyBzbGlkZTogdGhpcyB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2FkKCkge1xyXG4gICAgdGhpcy5jb250ZW50LmxvYWQoKTtcclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnc2xpZGVMb2FkJywgeyBzbGlkZTogdGhpcyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCBcImhlYXZ5XCIgRE9NIGVsZW1lbnRzXHJcbiAgICpcclxuICAgKiBUaGlzIG1heSBkZXBlbmQgb24gYSB0eXBlIG9mIHNsaWRlLFxyXG4gICAqIGJ1dCBnZW5lcmFsbHkgdGhlc2UgYXJlIGxhcmdlIGltYWdlcy5cclxuICAgKi9cclxuICBhcHBlbmRIZWF2eSgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IGFwcGVuZEhlYXZ5TmVhcmJ5ID0gdHJ1ZTsgLy8gdG9kb1xyXG5cclxuICAgIC8vIEF2b2lkIGFwcGVuZGluZyBoZWF2eSBlbGVtZW50cyBkdXJpbmcgYW5pbWF0aW9uc1xyXG4gICAgaWYgKHRoaXMuaGVhdnlBcHBlbmRlZFxyXG4gICAgICAgIHx8ICFwc3dwLm9wZW5lci5pc09wZW5cclxuICAgICAgICB8fCBwc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKClcclxuICAgICAgICB8fCAoIXRoaXMuaXNBY3RpdmUgJiYgIWFwcGVuZEhlYXZ5TmVhcmJ5KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgnYXBwZW5kSGVhdnknLCB7IHNsaWRlOiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaGVhdnlBcHBlbmRlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5jb250ZW50LmFwcGVuZCgpO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnYXBwZW5kSGVhdnlDb250ZW50JywgeyBzbGlkZTogdGhpcyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoaXMgc2xpZGUgaXMgYWN0aXZlIChzZWxlY3RlZCkuXHJcbiAgICpcclxuICAgKiBJZiBpdCdzIHBhcnQgb2Ygb3BlbmluZy9jbG9zaW5nIHRyYW5zaXRpb24gLVxyXG4gICAqIGFjdGl2YXRlKCkgd2lsbCB0cmlnZ2VyIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGlzIGVuZGVkLlxyXG4gICAqL1xyXG4gIGFjdGl2YXRlKCkge1xyXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLmFwcGVuZEhlYXZ5KCk7XHJcbiAgICB0aGlzLmNvbnRlbnQuYWN0aXZhdGUoKTtcclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnc2xpZGVBY3RpdmF0ZScsIHsgc2xpZGU6IHRoaXMgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHNsaWRlIGJlY29tZXMgaW5hY3RpdmUuXHJcbiAgICpcclxuICAgKiBTbGlkZSBjYW4gYmVjb21lIGluYWN0aXZlIG9ubHkgYWZ0ZXIgaXQgd2FzIGFjdGl2ZS5cclxuICAgKi9cclxuICBkZWFjdGl2YXRlKCkge1xyXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5jb250ZW50LmRlYWN0aXZhdGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyWm9vbUxldmVsICE9PSB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbCkge1xyXG4gICAgICAvLyBhbGxvdyBmaWx0ZXJpbmdcclxuICAgICAgdGhpcy5jYWxjdWxhdGVTaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVzZXQgem9vbSBsZXZlbFxyXG4gICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbiA9IDA7XHJcbiAgICB0aGlzLnpvb21BbmRQYW5Ub0luaXRpYWwoKTtcclxuICAgIHRoaXMuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgdGhpcy51cGRhdGVDb250ZW50U2l6ZSgpO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnc2xpZGVEZWFjdGl2YXRlJywgeyBzbGlkZTogdGhpcyB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzbGlkZSBzaG91bGQgZGVzdHJveSBpdHNlbGYsIGl0IHdpbGwgbmV2ZXIgYmUgdXNlZCBhZ2Fpbi5cclxuICAgKiAodW5iaW5kIGFsbCBldmVudHMgYW5kIGRlc3Ryb3kgaW50ZXJuYWwgY29tcG9uZW50cylcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5jb250ZW50Lmhhc1NsaWRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmNvbnRlbnQucmVtb3ZlKCk7XHJcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnc2xpZGVEZXN0cm95JywgeyBzbGlkZTogdGhpcyB9KTtcclxuICB9XHJcblxyXG4gIHJlc2l6ZSgpIHtcclxuICAgIGlmICh0aGlzLmN1cnJab29tTGV2ZWwgPT09IHRoaXMuem9vbUxldmVscy5pbml0aWFsIHx8ICF0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgIC8vIEtlZXAgaW5pdGlhbCB6b29tIGxldmVsIGlmIGl0IHdhcyBiZWZvcmUgdGhlIHJlc2l6ZSxcclxuICAgICAgLy8gYXMgd2VsbCBhcyB3aGVuIHRoaXMgc2xpZGUgaXMgbm90IGFjdGl2ZVxyXG5cclxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYW5kIHNjYWxlIHRvIG9yaWdpbmFsIHN0YXRlXHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gMDtcclxuICAgICAgdGhpcy56b29tQW5kUGFuVG9Jbml0aWFsKCk7XHJcbiAgICAgIHRoaXMuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZWFkanVzdCBwYW4gcG9zaXRpb24gaWYgaXQncyBiZXlvbmQgdGhlIGJvdW5kc1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcclxuICAgICAgdGhpcy5ib3VuZHMudXBkYXRlKHRoaXMuY3Vyclpvb21MZXZlbCk7XHJcbiAgICAgIHRoaXMucGFuVG8odGhpcy5wYW4ueCwgdGhpcy5wYW4ueSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgc2l6ZSB0byBjdXJyZW50IHNsaWRlIGNvbnRlbnQsXHJcbiAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBhbmQgc2NhbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZSBpZiBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGV2ZW4gaWYgZGltZW5zaW9ucyB3ZXJlbid0IGNoYW5nZWRcclxuICAgKi9cclxuICB1cGRhdGVDb250ZW50U2l6ZShmb3JjZSkge1xyXG4gICAgLy8gVXNlIGluaXRpYWwgem9vbSBsZXZlbFxyXG4gICAgLy8gaWYgcmVzb2x1dGlvbiBpcyBub3QgZGVmaW5lZCAodXNlciBkaWRuJ3Qgem9vbSB5ZXQpXHJcbiAgICBjb25zdCBzY2FsZU11bHRpcGxpZXIgPSB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uIHx8IHRoaXMuem9vbUxldmVscy5pbml0aWFsO1xyXG5cclxuICAgIGlmICghc2NhbGVNdWx0aXBsaWVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHNjYWxlTXVsdGlwbGllcikgfHwgdGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS54O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHNjYWxlTXVsdGlwbGllcikgfHwgdGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS55O1xyXG5cclxuICAgIGlmICghdGhpcy5zaXplQ2hhbmdlZCh3aWR0aCwgaGVpZ2h0KSAmJiAhZm9yY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jb250ZW50LnNldERpc3BsYXllZFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICovXHJcbiAgc2l6ZUNoYW5nZWQod2lkdGgsIGhlaWdodCkge1xyXG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLnByZXZEaXNwbGF5ZWRXaWR0aFxyXG4gICAgICAgIHx8IGhlaWdodCAhPT0gdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMucHJldkRpc3BsYXllZFdpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRoaXMucHJldkRpc3BsYXllZEhlaWdodCA9IGhlaWdodDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGxhY2Vob2xkZXJFbGVtZW50KCkge1xyXG4gICAgaWYgKHRoaXMuY29udGVudC5wbGFjZWhvbGRlcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnBsYWNlaG9sZGVyLmVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBab29tIGN1cnJlbnQgc2xpZGUgaW1hZ2UgdG8uLi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZXN0Wm9vbUxldmVsIERlc3RpbmF0aW9uIHpvb20gbGV2ZWwuXHJcbiAgICogQHBhcmFtIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gY2VudGVyUG9pbnRcclxuICAgKiBUcmFuc2Zvcm0gb3JpZ2luIGNlbnRlciBwb2ludCwgb3IgZmFsc2UgaWYgdmlld3BvcnQgY2VudGVyIHNob3VsZCBiZSB1c2VkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgZmFsc2V9IFt0cmFuc2l0aW9uRHVyYXRpb25dIFRyYW5zaXRpb24gZHVyYXRpb24sIG1heSBiZSBzZXQgdG8gMC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVCb3VuZHMgTWluaW11bSBhbmQgbWF4aW11bSB6b29tIGxldmVscyB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbj19IFJldHVybnMgdHJ1ZSBpZiBhbmltYXRlZC5cclxuICAgKi9cclxuICB6b29tVG8oZGVzdFpvb21MZXZlbCwgY2VudGVyUG9pbnQsIHRyYW5zaXRpb25EdXJhdGlvbiwgaWdub3JlQm91bmRzKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBpZiAoIXRoaXMuaXNab29tYWJsZSgpXHJcbiAgICAgICAgfHwgcHN3cC5tYWluU2Nyb2xsLmlzU2hpZnRlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwc3dwLmRpc3BhdGNoKCdiZWZvcmVab29tVG8nLCB7XHJcbiAgICAgIGRlc3Rab29tTGV2ZWwsIGNlbnRlclBvaW50LCB0cmFuc2l0aW9uRHVyYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHN0b3AgYWxsIHBhbiBhbmQgem9vbSB0cmFuc2l0aW9uc1xyXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcclxuXHJcbiAgICAvLyBpZiAoIWNlbnRlclBvaW50KSB7XHJcbiAgICAvLyAgIGNlbnRlclBvaW50ID0gcHN3cC5nZXRWaWV3cG9ydENlbnRlclBvaW50KCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgY29uc3QgcHJldlpvb21MZXZlbCA9IHRoaXMuY3Vyclpvb21MZXZlbDtcclxuXHJcbiAgICBpZiAoIWlnbm9yZUJvdW5kcykge1xyXG4gICAgICBkZXN0Wm9vbUxldmVsID0gY2xhbXAoZGVzdFpvb21MZXZlbCwgdGhpcy56b29tTGV2ZWxzLm1pbiwgdGhpcy56b29tTGV2ZWxzLm1heCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgKHRyYW5zaXRpb25EdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMucHN3cC5vcHRpb25zLnpvb21BbmltYXRpb25EdXJhdGlvbjtcclxuICAgIC8vIH1cclxuXHJcbiAgICB0aGlzLnNldFpvb21MZXZlbChkZXN0Wm9vbUxldmVsKTtcclxuICAgIHRoaXMucGFuLnggPSB0aGlzLmNhbGN1bGF0ZVpvb21Ub1Bhbk9mZnNldCgneCcsIGNlbnRlclBvaW50LCBwcmV2Wm9vbUxldmVsKTtcclxuICAgIHRoaXMucGFuLnkgPSB0aGlzLmNhbGN1bGF0ZVpvb21Ub1Bhbk9mZnNldCgneScsIGNlbnRlclBvaW50LCBwcmV2Wm9vbUxldmVsKTtcclxuICAgIHJvdW5kUG9pbnQodGhpcy5wYW4pO1xyXG5cclxuICAgIGNvbnN0IGZpbmlzaFRyYW5zaXRpb24gPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3NldFJlc29sdXRpb24oZGVzdFpvb21MZXZlbCk7XHJcbiAgICAgIHRoaXMuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXRyYW5zaXRpb25EdXJhdGlvbikge1xyXG4gICAgICBmaW5pc2hUcmFuc2l0aW9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwc3dwLmFuaW1hdGlvbnMuc3RhcnRUcmFuc2l0aW9uKHtcclxuICAgICAgICBpc1BhbjogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAnem9vbVRvJyxcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuY29udGFpbmVyLFxyXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRDdXJyZW50VHJhbnNmb3JtKCksXHJcbiAgICAgICAgb25Db21wbGV0ZTogZmluaXNoVHJhbnNpdGlvbixcclxuICAgICAgICBkdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGVhc2luZzogcHN3cC5vcHRpb25zLmVhc2luZ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7eyB4PzogbnVtYmVyLCB5PzogbnVtYmVyIH19IFtjZW50ZXJQb2ludF1cclxuICAgKi9cclxuICB0b2dnbGVab29tKGNlbnRlclBvaW50KSB7XHJcbiAgICB0aGlzLnpvb21UbyhcclxuICAgICAgdGhpcy5jdXJyWm9vbUxldmVsID09PSB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbFxyXG4gICAgICAgID8gdGhpcy56b29tTGV2ZWxzLnNlY29uZGFyeSA6IHRoaXMuem9vbUxldmVscy5pbml0aWFsLFxyXG4gICAgICBjZW50ZXJQb2ludCxcclxuICAgICAgdGhpcy5wc3dwLm9wdGlvbnMuem9vbUFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB6b29tIGxldmVsIHByb3BlcnR5IGFuZCByZWNhbGN1bGF0ZXMgbmV3IHBhbiBib3VuZHMsXHJcbiAgICogdW5saWtlIHpvb21UbyBpdCBkb2VzIG5vdCBhcHBseSB0cmFuc2Zvcm0gKHVzZSBhcHBseUN1cnJlbnRab29tUGFuKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJab29tTGV2ZWxcclxuICAgKi9cclxuICBzZXRab29tTGV2ZWwoY3Vyclpvb21MZXZlbCkge1xyXG4gICAgdGhpcy5jdXJyWm9vbUxldmVsID0gY3Vyclpvb21MZXZlbDtcclxuICAgIHRoaXMuYm91bmRzLnVwZGF0ZSh0aGlzLmN1cnJab29tTGV2ZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHBhbiBwb3NpdGlvbiBhZnRlciB6b29tIGF0IGEgZ2l2ZW4gYHBvaW50YC5cclxuICAgKlxyXG4gICAqIEFsd2F5cyBjYWxsIHNldFpvb21MZXZlbChuZXdab29tTGV2ZWwpIGJlZm9yZWhhbmQgdG8gcmVjYWxjdWxhdGVcclxuICAgKiBwYW4gYm91bmRzIGFjY29yZGluZyB0byB0aGUgbmV3IHpvb20gbGV2ZWwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyd4JyB8ICd5J30gYXhpc1xyXG4gICAqIEBwYXJhbSB7eyB4PzogbnVtYmVyOyB5PzogbnVtYmVyIH19IFtwb2ludF1cclxuICAgKiBwb2ludCBiYXNlZCBvbiB3aGljaCB6b29tIGlzIHBlcmZvcm1lZCwgdXN1YWxseSByZWZlcnMgdG8gdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24sXHJcbiAgICogaWYgZmFsc2UgLSB2aWV3cG9ydCBjZW50ZXIgd2lsbCBiZSB1c2VkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcHJldlpvb21MZXZlbCBab29tIGxldmVsIGJlZm9yZSBuZXcgem9vbSB3YXMgYXBwbGllZC5cclxuICAgKi9cclxuICBjYWxjdWxhdGVab29tVG9QYW5PZmZzZXQoYXhpcywgcG9pbnQsIHByZXZab29tTGV2ZWwpIHtcclxuICAgIGNvbnN0IHRvdGFsUGFuRGlzdGFuY2UgPSB0aGlzLmJvdW5kcy5tYXhbYXhpc10gLSB0aGlzLmJvdW5kcy5taW5bYXhpc107XHJcbiAgICBpZiAodG90YWxQYW5EaXN0YW5jZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuY2VudGVyW2F4aXNdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcG9pbnQpIHtcclxuICAgICAgcG9pbnQgPSB0aGlzLnBzd3AuZ2V0Vmlld3BvcnRDZW50ZXJQb2ludCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0aGlzLmN1cnJab29tTGV2ZWwgLyBwcmV2Wm9vbUxldmVsO1xyXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmNvcnJlY3RQYW4oXHJcbiAgICAgIGF4aXMsXHJcbiAgICAgICh0aGlzLnBhbltheGlzXSAtIHBvaW50W2F4aXNdKSAqIHpvb21GYWN0b3IgKyBwb2ludFtheGlzXVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHBhbiBhbmQga2VlcCBpdCB3aXRoaW4gYm91bmRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhblhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFuWVxyXG4gICAqL1xyXG4gIHBhblRvKHBhblgsIHBhblkpIHtcclxuICAgIHRoaXMucGFuLnggPSB0aGlzLmJvdW5kcy5jb3JyZWN0UGFuKCd4JywgcGFuWCk7XHJcbiAgICB0aGlzLnBhbi55ID0gdGhpcy5ib3VuZHMuY29ycmVjdFBhbigneScsIHBhblkpO1xyXG4gICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgc2xpZGUgaW4gdGhlIGN1cnJlbnQgc3RhdGUgY2FuIGJlIHBhbm5lZCBieSB0aGUgdXNlclxyXG4gICAqL1xyXG4gIGlzUGFubmFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy53aWR0aCAmJiAodGhpcy5jdXJyWm9vbUxldmVsID4gdGhpcy56b29tTGV2ZWxzLmZpdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgc2xpZGUgY2FuIGJlIHpvb21lZFxyXG4gICAqL1xyXG4gIGlzWm9vbWFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy53aWR0aCAmJiB0aGlzLmNvbnRlbnQuaXNab29tYWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgdHJhbnNmb3JtIGFuZCBzY2FsZSBiYXNlZCBvblxyXG4gICAqIHRoZSBjdXJyZW50IHBhbiBwb3NpdGlvbiAodGhpcy5wYW4pIGFuZCB6b29tIGxldmVsICh0aGlzLmN1cnJab29tTGV2ZWwpXHJcbiAgICovXHJcbiAgYXBwbHlDdXJyZW50Wm9vbVBhbigpIHtcclxuICAgIHRoaXMuX2FwcGx5Wm9vbVRyYW5zZm9ybSh0aGlzLnBhbi54LCB0aGlzLnBhbi55LCB0aGlzLmN1cnJab29tTGV2ZWwpO1xyXG4gICAgaWYgKHRoaXMgPT09IHRoaXMucHN3cC5jdXJyU2xpZGUpIHtcclxuICAgICAgdGhpcy5wc3dwLmRpc3BhdGNoKCd6b29tUGFuVXBkYXRlJywgeyBzbGlkZTogdGhpcyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHpvb21BbmRQYW5Ub0luaXRpYWwoKSB7XHJcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbDtcclxuXHJcbiAgICAvLyBwYW4gYWNjb3JkaW5nIHRvIHRoZSB6b29tIGxldmVsXHJcbiAgICB0aGlzLmJvdW5kcy51cGRhdGUodGhpcy5jdXJyWm9vbUxldmVsKTtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucGFuLCB0aGlzLmJvdW5kcy5jZW50ZXIpO1xyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdpbml0aWFsWm9vbVBhbicsIHsgc2xpZGU6IHRoaXMgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdHJhbnNsYXRlIGFuZCBzY2FsZSBiYXNlZCBvbiBjdXJyZW50IHJlc29sdXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbVxyXG4gICAqL1xyXG4gIF9hcHBseVpvb21UcmFuc2Zvcm0oeCwgeSwgem9vbSkge1xyXG4gICAgem9vbSAvPSB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uIHx8IHRoaXMuem9vbUxldmVscy5pbml0aWFsO1xyXG4gICAgc2V0VHJhbnNmb3JtKHRoaXMuY29udGFpbmVyLCB4LCB5LCB6b29tKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVNpemUoKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcblxyXG4gICAgZXF1YWxpemVQb2ludHMoXHJcbiAgICAgIHRoaXMucGFuQXJlYVNpemUsXHJcbiAgICAgIGdldFBhbkFyZWFTaXplKHBzd3Aub3B0aW9ucywgcHN3cC52aWV3cG9ydFNpemUsIHRoaXMuZGF0YSwgdGhpcy5pbmRleClcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy56b29tTGV2ZWxzLnVwZGF0ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5wYW5BcmVhU2l6ZSk7XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaCgnY2FsY1NsaWRlU2l6ZScsIHtcclxuICAgICAgc2xpZGU6IHRoaXNcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudFRyYW5zZm9ybSgpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jdXJyWm9vbUxldmVsIC8gKHRoaXMuY3VycmVudFJlc29sdXRpb24gfHwgdGhpcy56b29tTGV2ZWxzLmluaXRpYWwpO1xyXG4gICAgcmV0dXJuIHRvVHJhbnNmb3JtU3RyaW5nKHRoaXMucGFuLngsIHRoaXMucGFuLnksIHNjYWxlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCByZXNvbHV0aW9uIGFuZCByZS1yZW5kZXIgdGhlIGltYWdlLlxyXG4gICAqXHJcbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSByZWFsIGltYWdlIHNpemUgaXMgMjAwMHgxNTAwLFxyXG4gICAqIGFuZCByZXNvbHV0aW9uIGlzIDAuNSAtIGl0IHdpbGwgYmUgcmVuZGVyZWQgYXMgMTAwMHg3NTAuXHJcbiAgICpcclxuICAgKiBJbWFnZSB3aXRoIHpvb20gbGV2ZWwgMiBhbmQgcmVzb2x1dGlvbiAwLjUgaXNcclxuICAgKiB0aGUgc2FtZSBhcyBpbWFnZSB3aXRoIHpvb20gbGV2ZWwgMSBhbmQgcmVzb2x1dGlvbiAxLlxyXG4gICAqXHJcbiAgICogVXNlZCB0byBvcHRpbWl6ZSBhbmltYXRpb25zIGFuZCBtYWtlXHJcbiAgICogc3VyZSB0aGF0IGJyb3dzZXIgcmVuZGVycyBpbWFnZSBpbiBoaWdoZXN0IHF1YWxpdHkuXHJcbiAgICogQWxzbyB1c2VkIGJ5IHJlc3BvbnNpdmUgaW1hZ2VzIHRvIGxvYWQgdGhlIGNvcnJlY3Qgb25lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Jlc29sdXRpb25cclxuICAgKi9cclxuICBfc2V0UmVzb2x1dGlvbihuZXdSZXNvbHV0aW9uKSB7XHJcbiAgICBpZiAobmV3UmVzb2x1dGlvbiA9PT0gdGhpcy5jdXJyZW50UmVzb2x1dGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbiA9IG5ld1Jlc29sdXRpb247XHJcbiAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdyZXNvbHV0aW9uQ2hhbmdlZCcpO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9nZXN0dXJlcy5qcycpLmRlZmF1bHR9IEdlc3R1cmVzICovXHJcblxyXG5jb25zdCBQQU5fRU5EX0ZSSUNUSU9OID0gMC4zNTtcclxuY29uc3QgVkVSVElDQUxfRFJBR19GUklDVElPTiA9IDAuNjtcclxuXHJcbi8vIDEgY29ycmVzcG9uZHMgdG8gdGhlIHRoaXJkIG9mIHZpZXdwb3J0IGhlaWdodFxyXG5jb25zdCBNSU5fUkFUSU9fVE9fQ0xPU0UgPSAwLjQ7XHJcblxyXG4vLyBNaW5pbXVtIHNwZWVkIHJlcXVpcmVkIHRvIG5hdmlnYXRlXHJcbi8vIHRvIG5leHQgb3IgcHJldmlvdXMgc2xpZGVcclxuY29uc3QgTUlOX05FWFRfU0xJREVfU1BFRUQgPSAwLjU7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxWZWxvY2l0eVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjZWxlcmF0aW9uUmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcHJvamVjdChpbml0aWFsVmVsb2NpdHksIGRlY2VsZXJhdGlvblJhdGUpIHtcclxuICByZXR1cm4gaW5pdGlhbFZlbG9jaXR5ICogZGVjZWxlcmF0aW9uUmF0ZSAvICgxIC0gZGVjZWxlcmF0aW9uUmF0ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIHNpbmdsZSBwb2ludGVyIGRyYWdnaW5nXHJcbiAqL1xyXG5jbGFzcyBEcmFnSGFuZGxlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHZXN0dXJlc30gZ2VzdHVyZXNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xyXG4gICAgdGhpcy5nZXN0dXJlcyA9IGdlc3R1cmVzO1xyXG4gICAgdGhpcy5wc3dwID0gZ2VzdHVyZXMucHN3cDtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnN0YXJ0UGFuID0ge307XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQYW4sIHRoaXMucHN3cC5jdXJyU2xpZGUucGFuKTtcclxuICAgIHRoaXMucHN3cC5hbmltYXRpb25zLnN0b3BBbGwoKTtcclxuICB9XHJcblxyXG4gIGNoYW5nZSgpIHtcclxuICAgIGNvbnN0IHsgcDEsIHByZXZQMSwgZHJhZ0F4aXMsIHBzd3AgfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSB9ID0gcHN3cDtcclxuXHJcbiAgICBpZiAoZHJhZ0F4aXMgPT09ICd5J1xyXG4gICAgICAgICYmIHBzd3Aub3B0aW9ucy5jbG9zZU9uVmVydGljYWxEcmFnXHJcbiAgICAgICAgJiYgY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPD0gY3VyclNsaWRlLnpvb21MZXZlbHMuZml0XHJcbiAgICAgICAgJiYgIXRoaXMuZ2VzdHVyZXMuaXNNdWx0aXRvdWNoKSB7XHJcbiAgICAgIC8vIEhhbmRsZSB2ZXJ0aWNhbCBkcmFnIHRvIGNsb3NlXHJcbiAgICAgIGNvbnN0IHBhblkgPSBjdXJyU2xpZGUucGFuLnkgKyAocDEueSAtIHByZXZQMS55KTtcclxuICAgICAgaWYgKCFwc3dwLmRpc3BhdGNoKCd2ZXJ0aWNhbERyYWcnLCB7IHBhblkgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbigneScsIHBhblksIFZFUlRJQ0FMX0RSQUdfRlJJQ1RJT04pO1xyXG4gICAgICAgIGNvbnN0IGJnT3BhY2l0eSA9IDEgLSBNYXRoLmFicyh0aGlzLl9nZXRWZXJ0aWNhbERyYWdSYXRpbyhjdXJyU2xpZGUucGFuLnkpKTtcclxuICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KGJnT3BhY2l0eSk7XHJcbiAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbWFpblNjcm9sbENoYW5nZWQgPSB0aGlzLl9wYW5Pck1vdmVNYWluU2Nyb2xsKCd4Jyk7XHJcbiAgICAgIGlmICghbWFpblNjcm9sbENoYW5nZWQpIHtcclxuICAgICAgICB0aGlzLl9wYW5Pck1vdmVNYWluU2Nyb2xsKCd5Jyk7XHJcblxyXG4gICAgICAgIHJvdW5kUG9pbnQoY3VyclNsaWRlLnBhbik7XHJcbiAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZW5kKCkge1xyXG4gICAgY29uc3QgeyBwc3dwLCB2ZWxvY2l0eSB9ID0gdGhpcy5nZXN0dXJlcztcclxuICAgIGNvbnN0IHsgbWFpblNjcm9sbCB9ID0gcHN3cDtcclxuICAgIGxldCBpbmRleERpZmYgPSAwO1xyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7XHJcblxyXG4gICAgLy8gSGFuZGxlIG1haW4gc2Nyb2xsIGlmIGl0J3Mgc2hpZnRlZFxyXG4gICAgaWYgKG1haW5TY3JvbGwuaXNTaGlmdGVkKCkpIHtcclxuICAgICAgLy8gUG9zaXRpb24gb2YgdGhlIG1haW4gc2Nyb2xsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxyXG4gICAgICBjb25zdCBtYWluU2Nyb2xsU2hpZnREaWZmID0gbWFpblNjcm9sbC54IC0gbWFpblNjcm9sbC5nZXRDdXJyU2xpZGVYKCk7XHJcblxyXG4gICAgICAvLyBSYXRpbyBiZXR3ZWVuIDAgYW5kIDE6XHJcbiAgICAgIC8vIDAgLSBzbGlkZSBpcyBub3QgdmlzaWJsZSBhdCBhbGwsXHJcbiAgICAgIC8vIDAuNSAtIGhhbGYgb2YgdGhlIHNsaWRlIGlzIHZpY2libGVcclxuICAgICAgLy8gMSAtIHNsaWRlIGlzIGZ1bGx5IHZpc2libGVcclxuICAgICAgY29uc3QgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvID0gKG1haW5TY3JvbGxTaGlmdERpZmYgLyBwc3dwLnZpZXdwb3J0U2l6ZS54KTtcclxuXHJcbiAgICAgIC8vIEdvIG5leHQgc2xpZGUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIC0gaWYgdmVsb2NpdHkgYW5kIGl0cyBkaXJlY3Rpb24gaXMgbWF0Y2hlZFxyXG4gICAgICAvLyAgIGFuZCB3ZSBzZWUgYXQgbGVhc3QgdGlueSBwYXJ0IG9mIHRoZSBuZXh0IHNsaWRlXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIC0gb3IgaWYgd2Ugc2VlIGxlc3MgdGhhbiA1MCUgb2YgdGhlIGN1cnJlbnQgc2xpZGVcclxuICAgICAgLy8gICBhbmQgdmVsb2NpdHkgaXMgY2xvc2UgdG8gMFxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoKHZlbG9jaXR5LnggPCAtTUlOX05FWFRfU0xJREVfU1BFRUQgJiYgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvIDwgMClcclxuICAgICAgICAgIHx8ICh2ZWxvY2l0eS54IDwgMC4xICYmIGN1cnJlbnRTbGlkZVZpc2liaWxpdHlSYXRpbyA8IC0wLjUpKSB7XHJcbiAgICAgICAgLy8gR28gdG8gbmV4dCBzbGlkZVxyXG4gICAgICAgIGluZGV4RGlmZiA9IDE7XHJcbiAgICAgICAgdmVsb2NpdHkueCA9IE1hdGgubWluKHZlbG9jaXR5LngsIDApO1xyXG4gICAgICB9IGVsc2UgaWYgKCh2ZWxvY2l0eS54ID4gTUlOX05FWFRfU0xJREVfU1BFRUQgJiYgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvID4gMClcclxuICAgICAgICAgIHx8ICh2ZWxvY2l0eS54ID4gLTAuMSAmJiBjdXJyZW50U2xpZGVWaXNpYmlsaXR5UmF0aW8gPiAwLjUpKSB7XHJcbiAgICAgICAgLy8gR28gdG8gcHJldiBzbGlkZVxyXG4gICAgICAgIGluZGV4RGlmZiA9IC0xO1xyXG4gICAgICAgIHZlbG9jaXR5LnggPSBNYXRoLm1heCh2ZWxvY2l0eS54LCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbWFpblNjcm9sbC5tb3ZlSW5kZXhCeShpbmRleERpZmYsIHRydWUsIHZlbG9jaXR5LngpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc3RvcmUgem9vbSBsZXZlbFxyXG4gICAgaWYgKHBzd3AuY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPiBwc3dwLmN1cnJTbGlkZS56b29tTGV2ZWxzLm1heFxyXG4gICAgICAgIHx8IHRoaXMuZ2VzdHVyZXMuaXNNdWx0aXRvdWNoKSB7XHJcbiAgICAgIHRoaXMuZ2VzdHVyZXMuem9vbUxldmVscy5jb3JyZWN0Wm9vbVBhbih0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHdlIHJ1biB0d28gYW5pbWF0aW9ucyBpbnN0ZWFkIG9mIG9uZSxcclxuICAgICAgLy8gYXMgZWFjaCBheGlzIGhhcyBvd24gcGFuIGJvdW5kYXJpZXMgYW5kIHRodXMgZGlmZmVyZW50IHNwcmluZyBmdW5jdGlvblxyXG4gICAgICAvLyAoY29ycmVjdFpvb21QYW4gZG9lcyBub3QgaGF2ZSB0aGlzIGZ1bmN0aW9uYWxpdHksXHJcbiAgICAgIC8vICBpdCBhbmltYXRlcyBhbGwgcHJvcGVydGllcyB3aXRoIHNpbmdsZSB0aW1pbmcgZnVuY3Rpb24pXHJcbiAgICAgIHRoaXMuX2ZpbmlzaFBhbkdlc3R1cmVGb3JBeGlzKCd4Jyk7XHJcbiAgICAgIHRoaXMuX2ZpbmlzaFBhbkdlc3R1cmVGb3JBeGlzKCd5Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICovXHJcbiAgX2ZpbmlzaFBhbkdlc3R1cmVGb3JBeGlzKGF4aXMpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSBwc3dwO1xyXG4gICAgY29uc3QgeyB2ZWxvY2l0eSB9ID0gdGhpcy5nZXN0dXJlcztcclxuICAgIGNvbnN0IHsgcGFuLCBib3VuZHMgfSA9IGN1cnJTbGlkZTtcclxuICAgIGNvbnN0IHBhblBvcyA9IHBhbltheGlzXTtcclxuICAgIGNvbnN0IHJlc3RvcmVCZ09wYWNpdHkgPSAocHN3cC5iZ09wYWNpdHkgPCAxICYmIGF4aXMgPT09ICd5Jyk7XHJcblxyXG4gICAgLy8gMC45OTUgbWVhbnMgLSBzY3JvbGwgdmlldyBsb3NlcyAwLjUlIG9mIGl0cyB2ZWxvY2l0eSBwZXIgbWlsbGlzZWNvbmRcclxuICAgIC8vIEluY2Vhc2luZyB0aGlzIG51bWJlciB3aWxsIHJlZHVjZSB0cmF2ZWwgZGlzdGFuY2VcclxuICAgIGNvbnN0IGRlY2VsZXJhdGlvblJhdGUgPSAwLjk5NTsgLy8gMC45OVxyXG5cclxuICAgIC8vIFBhbiBwb3NpdGlvbiBpZiB0aGVyZSBpcyBubyBib3VuZHNcclxuICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gcGFuUG9zICsgcHJvamVjdCh2ZWxvY2l0eVtheGlzXSwgZGVjZWxlcmF0aW9uUmF0ZSk7XHJcblxyXG4gICAgaWYgKHJlc3RvcmVCZ09wYWNpdHkpIHtcclxuICAgICAgY29uc3QgdkRyYWdSYXRpbyA9IHRoaXMuX2dldFZlcnRpY2FsRHJhZ1JhdGlvKHBhblBvcyk7XHJcbiAgICAgIGNvbnN0IHByb2plY3RlZFZEcmFnUmF0aW8gPSB0aGlzLl9nZXRWZXJ0aWNhbERyYWdSYXRpbyhwcm9qZWN0ZWRQb3NpdGlvbik7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBhcmUgYWJvdmUgYW5kIG1vdmluZyB1cHdhcmRzLFxyXG4gICAgICAvLyBvciBpZiB3ZSBhcmUgYmVsb3cgYW5kIG1vdmluZyBkb3dud2FyZHNcclxuICAgICAgaWYgKCh2RHJhZ1JhdGlvIDwgMCAmJiBwcm9qZWN0ZWRWRHJhZ1JhdGlvIDwgLU1JTl9SQVRJT19UT19DTE9TRSlcclxuICAgICAgICAgIHx8ICh2RHJhZ1JhdGlvID4gMCAmJiBwcm9qZWN0ZWRWRHJhZ1JhdGlvID4gTUlOX1JBVElPX1RPX0NMT1NFKSkge1xyXG4gICAgICAgIHBzd3AuY2xvc2UoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQYW4gcG9zaXRpb24gd2l0aCBjb3JyZWN0ZWQgYm91bmRzXHJcbiAgICBjb25zdCBjb3JyZWN0ZWRQYW5Qb3NpdGlvbiA9IGJvdW5kcy5jb3JyZWN0UGFuKGF4aXMsIHByb2plY3RlZFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBFeGl0IGlmIHBhbiBwb3NpdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWRcclxuICAgIC8vIG9yIGlmIHNwZWVkIGl0IHRvbyBsb3dcclxuICAgIGlmIChwYW5Qb3MgPT09IGNvcnJlY3RlZFBhblBvc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPdmVyc2hvb3QgaWYgdGhlIGZpbmFsIHBvc2l0aW9uIGlzIG91dCBvZiBwYW4gYm91bmRzXHJcbiAgICBjb25zdCBkYW1waW5nUmF0aW8gPSAoY29ycmVjdGVkUGFuUG9zaXRpb24gPT09IHByb2plY3RlZFBvc2l0aW9uKSA/IDEgOiAwLjgyO1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxCZ09wYWNpdHkgPSBwc3dwLmJnT3BhY2l0eTtcclxuICAgIGNvbnN0IHRvdGFsUGFuRGlzdCA9IGNvcnJlY3RlZFBhblBvc2l0aW9uIC0gcGFuUG9zO1xyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdGFydFNwcmluZyh7XHJcbiAgICAgIG5hbWU6ICdwYW5HZXN0dXJlJyArIGF4aXMsXHJcbiAgICAgIGlzUGFuOiB0cnVlLFxyXG4gICAgICBzdGFydDogcGFuUG9zLFxyXG4gICAgICBlbmQ6IGNvcnJlY3RlZFBhblBvc2l0aW9uLFxyXG4gICAgICB2ZWxvY2l0eTogdmVsb2NpdHlbYXhpc10sXHJcbiAgICAgIGRhbXBpbmdSYXRpbyxcclxuICAgICAgb25VcGRhdGU6IChwb3MpID0+IHtcclxuICAgICAgICAvLyBBbmltYXRlIG9wYWNpdHkgb2YgYmFja2dyb3VuZCByZWxhdGl2ZSB0byBZIHBhbiBwb3NpdGlvbiBvZiBhbiBpbWFnZVxyXG4gICAgICAgIGlmIChyZXN0b3JlQmdPcGFjaXR5ICYmIHBzd3AuYmdPcGFjaXR5IDwgMSkge1xyXG4gICAgICAgICAgLy8gMCAtIHN0YXJ0IG9mIGFuaW1hdGlvbiwgMSAtIGVuZCBvZiBhbmltYXRpb25cclxuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvblByb2dyZXNzUmF0aW8gPSAxIC0gKGNvcnJlY3RlZFBhblBvc2l0aW9uIC0gcG9zKSAvIHRvdGFsUGFuRGlzdDtcclxuXHJcbiAgICAgICAgICAvLyBXZSBjbGFtcCBvcGFjaXR5IHRvIGtlZXAgaXQgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICAgICAgLy8gQXMgcHJvZ3Jlc3MgcmF0aW8gY2FuIGJlIGxhcmdlciB0aGFuIDEgZHVlIHRvIG92ZXJzaG9vdCxcclxuICAgICAgICAgIC8vIGFuZCB3ZSBkbyBub3Qgd2FudCB0byBib3VuY2Ugb3BhY2l0eS5cclxuICAgICAgICAgIHBzd3AuYXBwbHlCZ09wYWNpdHkoY2xhbXAoXHJcbiAgICAgICAgICAgIGluaXRpYWxCZ09wYWNpdHkgKyAoMSAtIGluaXRpYWxCZ09wYWNpdHkpICogYW5pbWF0aW9uUHJvZ3Jlc3NSYXRpbyxcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgMVxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYW5bYXhpc10gPSBNYXRoLmZsb29yKHBvcyk7XHJcbiAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCxcclxuICAgKiBvci9hbmQgdXBkYXRlIHBhbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBzbGlkZS5cclxuICAgKlxyXG4gICAqIFNob3VsZCByZXR1cm4gdHJ1ZSBpZiBpdCBjaGFuZ2VzIChvciBjYW4gY2hhbmdlKSBtYWluIHNjcm9sbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHsneCcgfCAneSd9IGF4aXNcclxuICAgKi9cclxuICBfcGFuT3JNb3ZlTWFpblNjcm9sbChheGlzKSB7XHJcbiAgICBjb25zdCB7IHAxLCBwc3dwLCBkcmFnQXhpcywgcHJldlAxLCBpc011bHRpdG91Y2ggfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSwgbWFpblNjcm9sbCB9ID0gcHN3cDtcclxuICAgIGNvbnN0IGRlbHRhID0gKHAxW2F4aXNdIC0gcHJldlAxW2F4aXNdKTtcclxuICAgIGNvbnN0IG5ld01haW5TY3JvbGxYID0gbWFpblNjcm9sbC54ICsgZGVsdGE7XHJcblxyXG4gICAgaWYgKCFkZWx0YSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWx3YXlzIG1vdmUgbWFpbiBzY3JvbGwgaWYgaW1hZ2UgY2FuIG5vdCBiZSBwYW5uZWRcclxuICAgIGlmIChheGlzID09PSAneCcgJiYgIWN1cnJTbGlkZS5pc1Bhbm5hYmxlKCkgJiYgIWlzTXVsdGl0b3VjaCkge1xyXG4gICAgICBtYWluU2Nyb2xsLm1vdmVUbyhuZXdNYWluU2Nyb2xsWCwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjaGFuZ2VkIG1haW4gc2Nyb2xsXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBib3VuZHMgfSA9IGN1cnJTbGlkZTtcclxuICAgIGNvbnN0IG5ld1BhbiA9IGN1cnJTbGlkZS5wYW5bYXhpc10gKyBkZWx0YTtcclxuXHJcbiAgICBpZiAocHN3cC5vcHRpb25zLmFsbG93UGFuVG9OZXh0XHJcbiAgICAgICAgJiYgZHJhZ0F4aXMgPT09ICd4J1xyXG4gICAgICAgICYmIGF4aXMgPT09ICd4J1xyXG4gICAgICAgICYmICFpc011bHRpdG91Y2gpIHtcclxuICAgICAgY29uc3QgY3VyclNsaWRlTWFpblNjcm9sbFggPSBtYWluU2Nyb2xsLmdldEN1cnJTbGlkZVgoKTtcclxuXHJcbiAgICAgIC8vIFBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAgY29uc3QgbWFpblNjcm9sbFNoaWZ0RGlmZiA9IG1haW5TY3JvbGwueCAtIGN1cnJTbGlkZU1haW5TY3JvbGxYO1xyXG5cclxuICAgICAgY29uc3QgaXNMZWZ0VG9SaWdodCA9IGRlbHRhID4gMDtcclxuICAgICAgY29uc3QgaXNSaWdodFRvTGVmdCA9ICFpc0xlZnRUb1JpZ2h0O1xyXG5cclxuICAgICAgaWYgKG5ld1BhbiA+IGJvdW5kcy5taW5bYXhpc10gJiYgaXNMZWZ0VG9SaWdodCkge1xyXG4gICAgICAgIC8vIFBhbm5pbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBiZXlvbmQgdGhlIGxlZnQgZWRnZVxyXG5cclxuICAgICAgICAvLyBXZXRoZXIgdGhlIGltYWdlIHdhcyBhdCBtaW5pbXVtIHBhbiBwb3NpdGlvbiAob3IgbGVzcylcclxuICAgICAgICAvLyB3aGVuIHRoaXMgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQuXHJcbiAgICAgICAgLy8gTWluaW11bSBwYW4gcG9zaXRpb24gcmVmZXJzIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGltYWdlLlxyXG4gICAgICAgIGNvbnN0IHdhc0F0TWluUGFuUG9zaXRpb24gPSAoYm91bmRzLm1pbltheGlzXSA8PSB0aGlzLnN0YXJ0UGFuW2F4aXNdKTtcclxuXHJcbiAgICAgICAgaWYgKHdhc0F0TWluUGFuUG9zaXRpb24pIHtcclxuICAgICAgICAgIG1haW5TY3JvbGwubW92ZVRvKG5ld01haW5TY3JvbGxYLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgbmV3UGFuKTtcclxuICAgICAgICAgIC8vY3VyclNsaWRlLnBhbltheGlzXSA9IG5ld1BhbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobmV3UGFuIDwgYm91bmRzLm1heFtheGlzXSAmJiBpc1JpZ2h0VG9MZWZ0KSB7XHJcbiAgICAgICAgLy8gUGFuaW5nIGZyb20gcmlnaHQgdG8gbGVmdCwgYmV5b25kIHRoZSByaWdodCBlZGdlXHJcblxyXG4gICAgICAgIC8vIE1heGltdW0gcGFuIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgICAgY29uc3Qgd2FzQXRNYXhQYW5Qb3NpdGlvbiA9ICh0aGlzLnN0YXJ0UGFuW2F4aXNdIDw9IGJvdW5kcy5tYXhbYXhpc10pO1xyXG5cclxuICAgICAgICBpZiAod2FzQXRNYXhQYW5Qb3NpdGlvbikge1xyXG4gICAgICAgICAgbWFpblNjcm9sbC5tb3ZlVG8obmV3TWFpblNjcm9sbFgsIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgICAgLy9jdXJyU2xpZGUucGFuW2F4aXNdID0gbmV3UGFuO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkXHJcbiAgICAgICAgaWYgKG1haW5TY3JvbGxTaGlmdERpZmYgIT09IDApIHtcclxuICAgICAgICAgIC8vIElmIG1haW4gc2Nyb2xsIGlzIHNoaWZ0ZWQgcmlnaHRcclxuICAgICAgICAgIGlmIChtYWluU2Nyb2xsU2hpZnREaWZmID4gMCAvKiYmIGlzUmlnaHRUb0xlZnQqLykge1xyXG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1heChuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG1haW5TY3JvbGxTaGlmdERpZmYgPCAwIC8qJiYgaXNMZWZ0VG9SaWdodCovKSB7XHJcbiAgICAgICAgICAgIC8vIE1haW4gc2Nyb2xsIGlzIHNoaWZ0ZWQgbGVmdCAoUG9zaXRpb24gaXMgbGVzcyB0aGFuIDAgY29tcGFyaW5nIHRvIHRoZSB2aWV3cG9ydCAwKVxyXG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1pbihuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFdlIGFyZSB3aXRoaW4gcGFuIGJvdW5kcywgc28ganVzdCBwYW5cclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xyXG4gICAgICAgIC8vIERvIG5vdCBwYW4gdmVydGljYWxseSBpZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkIG9cclxuICAgICAgICBpZiAoIW1haW5TY3JvbGwuaXNTaGlmdGVkKCkgJiYgYm91bmRzLm1pbi55ICE9PSBib3VuZHMubWF4LnkpIHtcclxuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgbmV3UGFuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvL1xyXG4gIC8vIElmIHdlIG1vdmUgYWJvdmUgLSB0aGUgcmF0aW8gaXMgbmVnYXRpdmVcclxuICAvLyBJZiB3ZSBtb3ZlIGJlbG93IHRoZSByYXRpbyBpcyBwb3NpdGl2ZVxyXG5cclxuICAvKipcclxuICAgKiBSZWxhdGlvbiBiZXR3ZWVuIHBhbiBZIHBvc2l0aW9uIGFuZCB0aGlyZCBvZiB2aWV3cG9ydCBoZWlnaHQuXHJcbiAgICpcclxuICAgKiBXaGVuIHdlIGFyZSBhdCBpbml0aWFsIHBvc2l0aW9uIChjZW50ZXIgYm91bmRzKSAtIHRoZSByYXRpbyBpcyAwLFxyXG4gICAqIGlmIHBvc2l0aW9uIGlzIHNoaWZ0ZWQgdXB3YXJkcyAtIHRoZSByYXRpbyBpcyBuZWdhdGl2ZSxcclxuICAgKiBpZiBwb3NpdGlvbiBpcyBzaGlmdGVkIGRvd253YXJkcyAtIHRoZSByYXRpbyBpcyBwb3NpdGl2ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhblkgVGhlIGN1cnJlbnQgcGFuIFkgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgX2dldFZlcnRpY2FsRHJhZ1JhdGlvKHBhblkpIHtcclxuICAgIHJldHVybiAocGFuWSAtIHRoaXMucHN3cC5jdXJyU2xpZGUuYm91bmRzLmNlbnRlci55KVxyXG4gICAgICAgICAgICAvICh0aGlzLnBzd3Audmlld3BvcnRTaXplLnkgLyAzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwYW4gcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgc2xpZGUuXHJcbiAgICogQXBwbHkgZnJpY3Rpb24gaWYgdGhlIHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgcGFuIGJvdW5kcyxcclxuICAgKiBvciBpZiBjdXN0b20gZnJpY3Rpb24gaXMgZGVmaW5lZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHsneCcgfCAneSd9IGF4aXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG90ZW50aWFsUGFuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBjdXN0b21GcmljdGlvbiAoMC4xIC0gMSlcclxuICAgKi9cclxuICBfc2V0UGFuV2l0aEZyaWN0aW9uKGF4aXMsIHBvdGVudGlhbFBhbiwgY3VzdG9tRnJpY3Rpb24pIHtcclxuICAgIGNvbnN0IHsgcGFuLCBib3VuZHMgfSA9IHRoaXMucHN3cC5jdXJyU2xpZGU7XHJcbiAgICBjb25zdCBjb3JyZWN0ZWRQYW4gPSBib3VuZHMuY29ycmVjdFBhbihheGlzLCBwb3RlbnRpYWxQYW4pO1xyXG4gICAgLy8gSWYgd2UgYXJlIG91dCBvZiBwYW4gYm91bmRzXHJcbiAgICBpZiAoY29ycmVjdGVkUGFuICE9PSBwb3RlbnRpYWxQYW4gfHwgY3VzdG9tRnJpY3Rpb24pIHtcclxuICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLnJvdW5kKHBvdGVudGlhbFBhbiAtIHBhbltheGlzXSk7XHJcbiAgICAgIHBhbltheGlzXSArPSBkZWx0YSAqIChjdXN0b21GcmljdGlvbiB8fCBQQU5fRU5EX0ZSSUNUSU9OKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhbltheGlzXSA9IHBvdGVudGlhbFBhbjtcclxuICAgIH1cclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2VzdHVyZXMuanMnKS5kZWZhdWx0fSBHZXN0dXJlcyAqL1xyXG5cclxuY29uc3QgVVBQRVJfWk9PTV9GUklDVElPTiA9IDAuMDU7XHJcbmNvbnN0IExPV0VSX1pPT01fRlJJQ1RJT04gPSAwLjE1O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgY2VudGVyIHBvaW50IGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge1BvaW50fSBwXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRab29tUG9pbnRzQ2VudGVyKHAsIHAxLCBwMikge1xyXG4gIHAueCA9IChwMS54ICsgcDIueCkgLyAyO1xyXG4gIHAueSA9IChwMS55ICsgcDIueSkgLyAyO1xyXG4gIHJldHVybiBwO1xyXG59XHJcblxyXG5jbGFzcyBab29tSGFuZGxlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtHZXN0dXJlc30gZ2VzdHVyZXNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xyXG4gICAgdGhpcy5nZXN0dXJlcyA9IGdlc3R1cmVzO1xyXG4gICAgdGhpcy5wc3dwID0gdGhpcy5nZXN0dXJlcy5wc3dwO1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMuX3N0YXJ0UGFuID0ge307XHJcblxyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMuX3N0YXJ0Wm9vbVBvaW50ID0ge307XHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5fem9vbVBvaW50ID0ge307XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMuX3N0YXJ0Wm9vbUxldmVsID0gdGhpcy5wc3dwLmN1cnJTbGlkZS5jdXJyWm9vbUxldmVsO1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5fc3RhcnRQYW4sIHRoaXMucHN3cC5jdXJyU2xpZGUucGFuKTtcclxuICAgIHRoaXMucHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcclxuICAgIHRoaXMuX3dhc092ZXJGaXRab29tTGV2ZWwgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNoYW5nZSgpIHtcclxuICAgIGNvbnN0IHsgcDEsIHN0YXJ0UDEsIHAyLCBzdGFydFAyLCBwc3dwIH0gPSB0aGlzLmdlc3R1cmVzO1xyXG4gICAgY29uc3QgeyBjdXJyU2xpZGUgfSA9IHBzd3A7XHJcbiAgICBjb25zdCBtaW5ab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5taW47XHJcbiAgICBjb25zdCBtYXhab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5tYXg7XHJcblxyXG4gICAgaWYgKCFjdXJyU2xpZGUuaXNab29tYWJsZSgpIHx8IHBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Wm9vbVBvaW50c0NlbnRlcih0aGlzLl9zdGFydFpvb21Qb2ludCwgc3RhcnRQMSwgc3RhcnRQMik7XHJcbiAgICBnZXRab29tUG9pbnRzQ2VudGVyKHRoaXMuX3pvb21Qb2ludCwgcDEsIHAyKTtcclxuXHJcbiAgICBsZXQgY3Vyclpvb21MZXZlbCA9ICgxIC8gZ2V0RGlzdGFuY2VCZXR3ZWVuKHN0YXJ0UDEsIHN0YXJ0UDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgKiBnZXREaXN0YW5jZUJldHdlZW4ocDEsIHAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgKiB0aGlzLl9zdGFydFpvb21MZXZlbDtcclxuXHJcbiAgICAvLyBzbGlnaHRseSBvdmVyIHRoZSB6b29tLmZpdFxyXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPiBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsICsgKGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwgLyAxNSkpIHtcclxuICAgICAgdGhpcy5fd2FzT3ZlckZpdFpvb21MZXZlbCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwpIHtcclxuICAgICAgaWYgKHBzd3Aub3B0aW9ucy5waW5jaFRvQ2xvc2VcclxuICAgICAgICAgICYmICF0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsXHJcbiAgICAgICAgICAmJiB0aGlzLl9zdGFydFpvb21MZXZlbCA8PSBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgICAgLy8gZmFkZSBvdXQgYmFja2dyb3VuZCBpZiB6b29taW5nIG91dFxyXG4gICAgICAgIGNvbnN0IGJnT3BhY2l0eSA9IDEgLSAoKG1pblpvb21MZXZlbCAtIGN1cnJab29tTGV2ZWwpIC8gKG1pblpvb21MZXZlbCAvIDEuMikpO1xyXG4gICAgICAgIGlmICghcHN3cC5kaXNwYXRjaCgncGluY2hDbG9zZScsIHsgYmdPcGFjaXR5IH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgIHBzd3AuYXBwbHlCZ09wYWNpdHkoYmdPcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgYmVsb3cgdGhlIG1pblxyXG4gICAgICAgIGN1cnJab29tTGV2ZWwgPSBtaW5ab29tTGV2ZWwgLSAobWluWm9vbUxldmVsIC0gY3Vyclpvb21MZXZlbCkgKiBMT1dFUl9aT09NX0ZSSUNUSU9OO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGN1cnJab29tTGV2ZWwgPiBtYXhab29tTGV2ZWwpIHtcclxuICAgICAgLy8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgYWJvdmUgdGhlIG1heFxyXG4gICAgICBjdXJyWm9vbUxldmVsID0gbWF4Wm9vbUxldmVsICsgKGN1cnJab29tTGV2ZWwgLSBtYXhab29tTGV2ZWwpICogVVBQRVJfWk9PTV9GUklDVElPTjtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyU2xpZGUucGFuLnggPSB0aGlzLl9jYWxjdWxhdGVQYW5Gb3Jab29tTGV2ZWwoJ3gnLCBjdXJyWm9vbUxldmVsKTtcclxuICAgIGN1cnJTbGlkZS5wYW4ueSA9IHRoaXMuX2NhbGN1bGF0ZVBhbkZvclpvb21MZXZlbCgneScsIGN1cnJab29tTGV2ZWwpO1xyXG5cclxuICAgIGN1cnJTbGlkZS5zZXRab29tTGV2ZWwoY3Vyclpvb21MZXZlbCk7XHJcbiAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gIH1cclxuXHJcbiAgZW5kKCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgeyBjdXJyU2xpZGUgfSA9IHBzd3A7XHJcbiAgICBpZiAoY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPCBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsXHJcbiAgICAgICAgJiYgIXRoaXMuX3dhc092ZXJGaXRab29tTGV2ZWxcclxuICAgICAgICAmJiBwc3dwLm9wdGlvbnMucGluY2hUb0Nsb3NlKSB7XHJcbiAgICAgIHBzd3AuY2xvc2UoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuY29ycmVjdFpvb21QYW4oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHsneCcgfCAneSd9IGF4aXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3Vyclpvb21MZXZlbFxyXG4gICAqL1xyXG4gIF9jYWxjdWxhdGVQYW5Gb3Jab29tTGV2ZWwoYXhpcywgY3Vyclpvb21MZXZlbCkge1xyXG4gICAgY29uc3Qgem9vbUZhY3RvciA9IGN1cnJab29tTGV2ZWwgLyB0aGlzLl9zdGFydFpvb21MZXZlbDtcclxuICAgIHJldHVybiB0aGlzLl96b29tUG9pbnRbYXhpc11cclxuICAgICAgICAgICAgLSAoKHRoaXMuX3N0YXJ0Wm9vbVBvaW50W2F4aXNdIC0gdGhpcy5fc3RhcnRQYW5bYXhpc10pICogem9vbUZhY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3JyZWN0IGN1cnJab29tTGV2ZWwgYW5kIHBhbiBpZiB0aGV5IGFyZVxyXG4gICAqIGJleW9uZCBtaW5pbXVtIG9yIG1heGltdW0gdmFsdWVzLlxyXG4gICAqIFdpdGggYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlR2VzdHVyZVxyXG4gICAqIFdldGhlciBnZXN0dXJlIGNvb3JkaW5hdGVzIHNob3VsZCBiZSBpZ25vcmVkIHdoZW4gY2FsY3VsYXRpbmcgZGVzdGluYXRpb24gcGFuIHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGNvcnJlY3Rab29tUGFuKGlnbm9yZUdlc3R1cmUpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSBwc3dwO1xyXG5cclxuICAgIGlmICghY3VyclNsaWRlLmlzWm9vbWFibGUoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3pvb21Qb2ludC54ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWdub3JlR2VzdHVyZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJldlpvb21MZXZlbCA9IGN1cnJTbGlkZS5jdXJyWm9vbUxldmVsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IGRlc3RpbmF0aW9uWm9vbUxldmVsO1xyXG4gICAgbGV0IGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSA9IHRydWU7XHJcblxyXG4gICAgaWYgKHByZXZab29tTGV2ZWwgPCBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsKSB7XHJcbiAgICAgIGRlc3RpbmF0aW9uWm9vbUxldmVsID0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbDtcclxuICAgICAgLy8gem9vbSB0byBtaW5cclxuICAgIH0gZWxzZSBpZiAocHJldlpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heCkge1xyXG4gICAgICBkZXN0aW5hdGlvblpvb21MZXZlbCA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heDtcclxuICAgICAgLy8gem9vbSB0byBtYXhcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSA9IGZhbHNlO1xyXG4gICAgICBkZXN0aW5hdGlvblpvb21MZXZlbCA9IHByZXZab29tTGV2ZWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5pdGlhbEJnT3BhY2l0eSA9IHBzd3AuYmdPcGFjaXR5O1xyXG4gICAgY29uc3QgcmVzdG9yZUJnT3BhY2l0eSA9IHBzd3AuYmdPcGFjaXR5IDwgMTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsUGFuID0gZXF1YWxpemVQb2ludHMoe30sIGN1cnJTbGlkZS5wYW4pO1xyXG4gICAgbGV0IGRlc3RpbmF0aW9uUGFuID0gZXF1YWxpemVQb2ludHMoe30sIGluaXRpYWxQYW4pO1xyXG5cclxuICAgIGlmIChpZ25vcmVHZXN0dXJlKSB7XHJcbiAgICAgIHRoaXMuX3pvb21Qb2ludC54ID0gMDtcclxuICAgICAgdGhpcy5fem9vbVBvaW50LnkgPSAwO1xyXG4gICAgICB0aGlzLl9zdGFydFpvb21Qb2ludC54ID0gMDtcclxuICAgICAgdGhpcy5fc3RhcnRab29tUG9pbnQueSA9IDA7XHJcbiAgICAgIHRoaXMuX3N0YXJ0Wm9vbUxldmVsID0gcHJldlpvb21MZXZlbDtcclxuICAgICAgZXF1YWxpemVQb2ludHModGhpcy5fc3RhcnRQYW4sIGluaXRpYWxQYW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UpIHtcclxuICAgICAgZGVzdGluYXRpb25QYW4gPSB7XHJcbiAgICAgICAgeDogdGhpcy5fY2FsY3VsYXRlUGFuRm9yWm9vbUxldmVsKCd4JywgZGVzdGluYXRpb25ab29tTGV2ZWwpLFxyXG4gICAgICAgIHk6IHRoaXMuX2NhbGN1bGF0ZVBhbkZvclpvb21MZXZlbCgneScsIGRlc3RpbmF0aW9uWm9vbUxldmVsKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB6b29tIGxldmVsLCBzbyBwYW4gYm91bmRzIGFyZSB1cGRhdGVkIGFjY29yZGluZyB0byBpdFxyXG4gICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChkZXN0aW5hdGlvblpvb21MZXZlbCk7XHJcblxyXG4gICAgZGVzdGluYXRpb25QYW4gPSB7XHJcbiAgICAgIHg6IGN1cnJTbGlkZS5ib3VuZHMuY29ycmVjdFBhbigneCcsIGRlc3RpbmF0aW9uUGFuLngpLFxyXG4gICAgICB5OiBjdXJyU2xpZGUuYm91bmRzLmNvcnJlY3RQYW4oJ3knLCBkZXN0aW5hdGlvblBhbi55KVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZXR1cm4gem9vbSBsZXZlbCBhbmQgaXRzIGJvdW5kcyB0byBpbml0aWFsXHJcbiAgICBjdXJyU2xpZGUuc2V0Wm9vbUxldmVsKHByZXZab29tTGV2ZWwpO1xyXG5cclxuICAgIGxldCBwYW5OZWVkc0NoYW5nZSA9IHRydWU7XHJcbiAgICBpZiAocG9pbnRzRXF1YWwoZGVzdGluYXRpb25QYW4sIGluaXRpYWxQYW4pKSB7XHJcbiAgICAgIHBhbk5lZWRzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwYW5OZWVkc0NoYW5nZSAmJiAhY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlICYmICFyZXN0b3JlQmdPcGFjaXR5KSB7XHJcbiAgICAgIC8vIHVwZGF0ZSByZXNvbHV0aW9uIGFmdGVyIGdlc3R1cmVcclxuICAgICAgY3VyclNsaWRlLl9zZXRSZXNvbHV0aW9uKGRlc3RpbmF0aW9uWm9vbUxldmVsKTtcclxuICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuXHJcbiAgICAgIC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcclxuXHJcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RhcnRTcHJpbmcoe1xyXG4gICAgICBpc1BhbjogdHJ1ZSxcclxuICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgIGVuZDogMTAwMCxcclxuICAgICAgdmVsb2NpdHk6IDAsXHJcbiAgICAgIGRhbXBpbmdSYXRpbzogMSxcclxuICAgICAgbmF0dXJhbEZyZXF1ZW5jeTogNDAsXHJcbiAgICAgIG9uVXBkYXRlOiAobm93KSA9PiB7XHJcbiAgICAgICAgbm93IC89IDEwMDA7IC8vIDAgLSBzdGFydCwgMSAtIGVuZFxyXG5cclxuICAgICAgICBpZiAocGFuTmVlZHNDaGFuZ2UgfHwgY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlKSB7XHJcbiAgICAgICAgICBpZiAocGFuTmVlZHNDaGFuZ2UpIHtcclxuICAgICAgICAgICAgY3VyclNsaWRlLnBhbi54ID0gaW5pdGlhbFBhbi54ICsgKGRlc3RpbmF0aW9uUGFuLnggLSBpbml0aWFsUGFuLngpICogbm93O1xyXG4gICAgICAgICAgICBjdXJyU2xpZGUucGFuLnkgPSBpbml0aWFsUGFuLnkgKyAoZGVzdGluYXRpb25QYW4ueSAtIGluaXRpYWxQYW4ueSkgKiBub3c7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdab29tTGV2ZWwgPSBwcmV2Wm9vbUxldmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGRlc3RpbmF0aW9uWm9vbUxldmVsIC0gcHJldlpvb21MZXZlbCkgKiBub3c7XHJcbiAgICAgICAgICAgIGN1cnJTbGlkZS5zZXRab29tTGV2ZWwobmV3Wm9vbUxldmVsKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBiYWNrZ3JvdW5kIG9wYWNpdHlcclxuICAgICAgICBpZiAocmVzdG9yZUJnT3BhY2l0eSAmJiBwc3dwLmJnT3BhY2l0eSA8IDEpIHtcclxuICAgICAgICAgIC8vIFdlIGNsYW1wIG9wYWNpdHkgdG8ga2VlcCBpdCBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAgICAgICAvLyBBcyBwcm9ncmVzcyByYXRpbyBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBkdWUgdG8gb3ZlcnNob290LFxyXG4gICAgICAgICAgLy8gYW5kIHdlIGRvIG5vdCB3YW50IHRvIGJvdW5jZSBvcGFjaXR5LlxyXG4gICAgICAgICAgcHN3cC5hcHBseUJnT3BhY2l0eShjbGFtcChcclxuICAgICAgICAgICAgaW5pdGlhbEJnT3BhY2l0eSArICgxIC0gaW5pdGlhbEJnT3BhY2l0eSkgKiBub3csIDAsIDFcclxuICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgIC8vIHVwZGF0ZSByZXNvbHV0aW9uIGFmdGVyIHRyYW5zaXRpb24gZW5kc1xyXG4gICAgICAgIGN1cnJTbGlkZS5fc2V0UmVzb2x1dGlvbihkZXN0aW5hdGlvblpvb21MZXZlbCk7XHJcbiAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XG5cbi8qKlxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKiBAdGVtcGxhdGUgUFxyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkFkZFBvc3RmaXg8VCwgUD59IEFkZFBvc3RmaXg8VCwgUD5cclxuICovXHJcblxyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9nZXN0dXJlcy5qcycpLmRlZmF1bHR9IEdlc3R1cmVzICovXHJcblxyXG4vKiogQHR5cGVkZWYgeydpbWFnZUNsaWNrJyB8ICdiZ0NsaWNrJyB8ICd0YXAnIHwgJ2RvdWJsZVRhcCd9IEFjdGlvbnMgKi9cclxuLyoqIEB0eXBlZGVmIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gUG9pbnQgKi9cclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSB0YXAgd2FzIHBlcmZvcm1lZCBvbiB0aGUgbWFpbiBzbGlkZVxyXG4gKiAocmF0aGVyIHRoYW4gY29udHJvbHMgb3IgY2FwdGlvbikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gZGlkVGFwT25NYWluQ29udGVudChldmVudCkge1xyXG4gIHJldHVybiAhISgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcucHN3cF9fY29udGFpbmVyJykpO1xyXG59XHJcblxyXG4vKipcclxuICogVGFwLCBkb3VibGUtdGFwIGhhbmRsZXIuXHJcbiAqL1xyXG5jbGFzcyBUYXBIYW5kbGVyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge0dlc3R1cmVzfSBnZXN0dXJlc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGdlc3R1cmVzKSB7XHJcbiAgICB0aGlzLmdlc3R1cmVzID0gZ2VzdHVyZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50XHJcbiAgICovXHJcbiAgY2xpY2socG9pbnQsIG9yaWdpbmFsRXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldENsYXNzTGlzdCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCkuY2xhc3NMaXN0O1xyXG4gICAgY29uc3QgaXNJbWFnZUNsaWNrID0gdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX19pbWcnKTtcclxuICAgIGNvbnN0IGlzQmFja2dyb3VuZENsaWNrID0gdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX19pdGVtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX196b29tLXdyYXAnKTtcclxuXHJcbiAgICBpZiAoaXNJbWFnZUNsaWNrKSB7XHJcbiAgICAgIHRoaXMuX2RvQ2xpY2tPclRhcEFjdGlvbignaW1hZ2VDbGljaycsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaXNCYWNrZ3JvdW5kQ2xpY2spIHtcclxuICAgICAgdGhpcy5fZG9DbGlja09yVGFwQWN0aW9uKCdiZ0NsaWNrJywgcG9pbnQsIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gb3JpZ2luYWxFdmVudFxyXG4gICAqL1xyXG4gIHRhcChwb2ludCwgb3JpZ2luYWxFdmVudCkge1xyXG4gICAgaWYgKGRpZFRhcE9uTWFpbkNvbnRlbnQob3JpZ2luYWxFdmVudCkpIHtcclxuICAgICAgdGhpcy5fZG9DbGlja09yVGFwQWN0aW9uKCd0YXAnLCBwb2ludCwgb3JpZ2luYWxFdmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2ZW50XHJcbiAgICovXHJcbiAgZG91YmxlVGFwKHBvaW50LCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICBpZiAoZGlkVGFwT25NYWluQ29udGVudChvcmlnaW5hbEV2ZW50KSkge1xyXG4gICAgICB0aGlzLl9kb0NsaWNrT3JUYXBBY3Rpb24oJ2RvdWJsZVRhcCcsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QWN0aW9uc30gYWN0aW9uTmFtZVxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnRcclxuICAgKi9cclxuICBfZG9DbGlja09yVGFwQWN0aW9uKGFjdGlvbk5hbWUsIHBvaW50LCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXMuZ2VzdHVyZXM7XHJcbiAgICBjb25zdCB7IGN1cnJTbGlkZSB9ID0gcHN3cDtcclxuICAgIGNvbnN0IGFjdGlvbkZ1bGxOYW1lID0gLyoqIEB0eXBlIHtBZGRQb3N0Zml4PEFjdGlvbnMsICdBY3Rpb24nPn0gKi8gKGFjdGlvbk5hbWUgKyAnQWN0aW9uJyk7XHJcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IHBzd3Aub3B0aW9uc1thY3Rpb25GdWxsTmFtZV07XHJcblxyXG4gICAgaWYgKHBzd3AuZGlzcGF0Y2goYWN0aW9uRnVsbE5hbWUsIHsgcG9pbnQsIG9yaWdpbmFsRXZlbnQgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBvcHRpb25WYWx1ZS5jYWxsKHBzd3AsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAob3B0aW9uVmFsdWUpIHtcclxuICAgICAgY2FzZSAnY2xvc2UnOlxyXG4gICAgICBjYXNlICduZXh0JzpcclxuICAgICAgICBwc3dwW29wdGlvblZhbHVlXSgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd6b29tJzpcclxuICAgICAgICBjdXJyU2xpZGUudG9nZ2xlWm9vbShwb2ludCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3pvb20tb3ItY2xvc2UnOlxyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgY2xpY2sgem9vbXMgY3VycmVudCBpbWFnZSxcclxuICAgICAgICAvLyBpZiBpdCBjYW4gbm90IGJlIHpvb21lZCAtIGdhbGxlcnkgd2lsbCBiZSBjbG9zZWRcclxuICAgICAgICBpZiAoY3VyclNsaWRlLmlzWm9vbWFibGUoKVxyXG4gICAgICAgICAgICAmJiBjdXJyU2xpZGUuem9vbUxldmVscy5zZWNvbmRhcnkgIT09IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwpIHtcclxuICAgICAgICAgIGN1cnJTbGlkZS50b2dnbGVab29tKHBvaW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBzd3Aub3B0aW9ucy5jbGlja1RvQ2xvc2VOb25ab29tYWJsZSkge1xyXG4gICAgICAgICAgcHN3cC5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9nZ2xlLWNvbnRyb2xzJzpcclxuICAgICAgICB0aGlzLmdlc3R1cmVzLnBzd3AuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdwc3dwLS11aS12aXNpYmxlJyk7XHJcbiAgICAgICAgLy8gaWYgKF9jb250cm9sc1Zpc2libGUpIHtcclxuICAgICAgICAvLyAgIF91aS5oaWRlQ29udHJvbHMoKTtcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgX3VpLnNob3dDb250cm9scygpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUG9pbnR9IFBvaW50ICovXHJcblxyXG4vLyBIb3cgZmFyIHNob3VsZCB1c2VyIHNob3VsZCBkcmFnXHJcbi8vIHVudGlsIHdlIGNhbiBkZXRlcm1pbmUgdGhhdCB0aGUgZ2VzdHVyZSBpcyBzd2lwZSBhbmQgaXRzIGRpcmVjdGlvblxyXG5jb25zdCBBWElTX1NXSVBFX0hZU1RFUklTSVMgPSAxMDtcclxuLy9jb25zdCBQQU5fRU5EX0ZSSUNUSU9OID0gMC4zNTtcclxuXHJcbmNvbnN0IERPVUJMRV9UQVBfREVMQVkgPSAzMDA7IC8vIG1zXHJcbmNvbnN0IE1JTl9UQVBfRElTVEFOQ0UgPSAyNTsgLy8gcHhcclxuXHJcbi8qKlxyXG4gKiBHZXN0dXJlcyBjbGFzcyBiaW5kIHRvdWNoLCBwb2ludGVyIG9yIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgZW1pdHMgZHJhZyB0byBkcmFnLWhhbmRsZXIgYW5kIHpvb20gZXZlbnRzIHpvb20taGFuZGxlci5cclxuICpcclxuICogRHJhZyBhbmQgem9vbSBldmVudHMgYXJlIGVtaXRlZCBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcbiAqIGFuZCBvbmx5IHdoZW4gb25lIG9mIHBvaW50ZXJzIHdhcyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gKi9cclxuY2xhc3MgR2VzdHVyZXMge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcblxyXG4gICAgLyoqIEB0eXBlIHsneCcgfCAneSd9ICovXHJcbiAgICB0aGlzLmRyYWdBeGlzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIHBvaW50IG9iamVjdHMgYXJlIGRlZmluZWQgb25jZSBhbmQgcmV1c2VkXHJcbiAgICAvLyBQaG90b1N3aXBlIGtlZXBzIHRyYWNrIG9ubHkgb2YgdHdvIHBvaW50ZXJzLCBvdGhlcnMgYXJlIGlnbm9yZWRcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnAxID0ge307IC8vIHRoZSBmaXJzdCBwcmVzc2VkIHBvaW50ZXJcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnAyID0ge307IC8vIHRoZSBzZWNvbmQgcHJlc3NlZCBwb2ludGVyXHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5wcmV2UDEgPSB7fTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLnByZXZQMiA9IHt9O1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMuc3RhcnRQMSA9IHt9O1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMuc3RhcnRQMiA9IHt9O1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cclxuICAgIHRoaXMudmVsb2NpdHkgPSB7fTtcclxuXHJcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xyXG4gICAgdGhpcy5fbGFzdFN0YXJ0UDEgPSB7fTtcclxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXHJcbiAgICB0aGlzLl9pbnRlcnZhbFAxID0ge307XHJcbiAgICB0aGlzLl9udW1BY3RpdmVQb2ludHMgPSAwO1xyXG4gICAgLyoqIEB0eXBlIHtQb2ludFtdfSAqL1xyXG4gICAgdGhpcy5fb25nb2luZ1BvaW50ZXJzID0gW107XHJcblxyXG4gICAgdGhpcy5fdG91Y2hFdmVudEVuYWJsZWQgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XHJcbiAgICB0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkID0gISEod2luZG93LlBvaW50ZXJFdmVudCk7XHJcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2ggPSB0aGlzLl90b3VjaEV2ZW50RW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xyXG5cclxuICAgIGlmICghdGhpcy5zdXBwb3J0c1RvdWNoKSB7XHJcbiAgICAgIC8vIGRpc2FibGUgcGFuIHRvIG5leHQgc2xpZGUgZm9yIG5vbi10b3VjaCBkZXZpY2VzXHJcbiAgICAgIHBzd3Aub3B0aW9ucy5hbGxvd1BhblRvTmV4dCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhZyA9IG5ldyBEcmFnSGFuZGxlcih0aGlzKTtcclxuICAgIHRoaXMuem9vbUxldmVscyA9IG5ldyBab29tSGFuZGxlcih0aGlzKTtcclxuICAgIHRoaXMudGFwSGFuZGxlciA9IG5ldyBUYXBIYW5kbGVyKHRoaXMpO1xyXG5cclxuICAgIHBzd3Aub24oJ2JpbmRFdmVudHMnLCAoKSA9PiB7XHJcbiAgICAgIHBzd3AuZXZlbnRzLmFkZChwc3dwLnNjcm9sbFdyYXAsICdjbGljaycsIGUgPT4gdGhpcy5fb25DbGljayhlKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50RW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuX2JpbmRFdmVudHMoJ3BvaW50ZXInLCAnZG93bicsICd1cCcsICdjYW5jZWwnKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl90b3VjaEV2ZW50RW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuX2JpbmRFdmVudHMoJ3RvdWNoJywgJ3N0YXJ0JywgJ2VuZCcsICdjYW5jZWwnKTtcclxuXHJcbiAgICAgICAgLy8gSW4gcHJldmlvdXMgdmVyc2lvbnMgd2UgYWxzbyBib3VuZCBtb3VzZSBldmVudCBoZXJlLFxyXG4gICAgICAgIC8vIGluIGNhc2UgZGV2aWNlIHN1cHBvcnRzIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cyxcclxuICAgICAgICAvLyBidXQgbmV3ZXIgdmVyc2lvbnMgb2YgYnJvd3NlcnMgbm93IHN1cHBvcnQgUG9pbnRlckV2ZW50LlxyXG5cclxuICAgICAgICAvLyBvbiBpT1MxMCBpZiB5b3UgYmluZCB0b3VjaG1vdmUvZW5kIGFmdGVyIHRvdWNoc3RhcnQsXHJcbiAgICAgICAgLy8gYW5kIHlvdSBkb24ndCBwcmV2ZW50RGVmYXVsdCB0b3VjaHN0YXJ0ICh3aGljaCBQaG90b1N3aXBlIGRvZXMpLFxyXG4gICAgICAgIC8vIHByZXZlbnREZWZhdWx0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdG91Y2htb3ZlIGFuZCB0b3VjaGVuZC5cclxuICAgICAgICAvLyBVbmxlc3MgeW91IGJpbmQgaXQgcHJldmlvdXNseS5cclxuICAgICAgICBwc3dwLnNjcm9sbFdyYXAub250b3VjaG1vdmUgPSAoKSA9PiB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIHBzd3Auc2Nyb2xsV3JhcC5vbnRvdWNoZW5kID0gKCkgPT4ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCdtb3VzZScsICdkb3duJywgJ3VwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0geydtb3VzZScgfCAndG91Y2gnIHwgJ3BvaW50ZXInfSBwcmVmXHJcbiAgICogQHBhcmFtIHsnZG93bicgfCAnc3RhcnQnfSBkb3duXHJcbiAgICogQHBhcmFtIHsndXAnIHwgJ2VuZCd9IHVwXHJcbiAgICogQHBhcmFtIHsnY2FuY2VsJ30gW2NhbmNlbF1cclxuICAgKi9cclxuICBfYmluZEV2ZW50cyhwcmVmLCBkb3duLCB1cCwgY2FuY2VsKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7IGV2ZW50cyB9ID0gcHN3cDtcclxuXHJcbiAgICBjb25zdCBjYW5jZWxFdmVudCA9IGNhbmNlbCA/IHByZWYgKyBjYW5jZWwgOiAnJztcclxuXHJcbiAgICBldmVudHMuYWRkKHBzd3Auc2Nyb2xsV3JhcCwgcHJlZiArIGRvd24sIHRoaXMub25Qb2ludGVyRG93bi5iaW5kKHRoaXMpKTtcclxuICAgIGV2ZW50cy5hZGQod2luZG93LCBwcmVmICsgJ21vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XHJcbiAgICBldmVudHMuYWRkKHdpbmRvdywgcHJlZiArIHVwLCB0aGlzLm9uUG9pbnRlclVwLmJpbmQodGhpcykpO1xyXG4gICAgaWYgKGNhbmNlbEV2ZW50KSB7XHJcbiAgICAgIGV2ZW50cy5hZGQocHN3cC5zY3JvbGxXcmFwLCBjYW5jZWxFdmVudCwgdGhpcy5vblBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgb25Qb2ludGVyRG93bihlKSB7XHJcbiAgICAvLyBXZSBkbyBub3QgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgdG91Y2ggZXZlbnRzXHJcbiAgICAvLyB0byBhbGxvdyBicm93c2VyIHRvIHNob3cgbmF0aXZlIGRpYWxvZyBvbiBsb25ncHJlc3NcclxuICAgIC8vICh0aGUgb25lIHRoYXQgYWxsb3dzIHRvIHNhdmUgaW1hZ2Ugb3Igb3BlbiBpdCBpbiBuZXcgdGFiKS5cclxuICAgIC8vXHJcbiAgICAvLyBEZXNrdG9wIFNhZmFyaSBhbGxvd3MgdG8gZHJhZyBpbWFnZXMgd2hlbiBwcmV2ZW50RGVmYXVsdCBpc24ndCBjYWxsZWQgb24gbW91c2Vkb3duLFxyXG4gICAgLy8gZXZlbiB0aG91Z2ggcHJldmVudERlZmF1bHQgSVMgY2FsbGVkIG9uIG1vdXNlbW92ZS4gVGhhdCdzIHdoeSB3ZSBwcmV2ZW50RGVmYXVsdCBtb3VzZWRvd24uXHJcbiAgICBsZXQgaXNNb3VzZVBvaW50ZXI7XHJcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XHJcbiAgICAgIGlzTW91c2VQb2ludGVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGxvdyBkcmFnZ2luZyBvbmx5IHZpYSBsZWZ0IG1vdXNlIGJ1dHRvbi5cclxuICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LmJ1dHRvblxyXG4gICAgaWYgKGlzTW91c2VQb2ludGVyICYmIGUuYnV0dG9uID4gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIC8vIGlmIFBob3RvU3dpcGUgaXMgb3BlbmluZyBvciBjbG9zaW5nXHJcbiAgICBpZiAoIXBzd3Aub3BlbmVyLmlzT3Blbikge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHN3cC5kaXNwYXRjaCgncG9pbnRlckRvd24nLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTW91c2VQb2ludGVyKSB7XHJcbiAgICAgIHBzd3AubW91c2VEZXRlY3RlZCgpO1xyXG5cclxuICAgICAgLy8gcHJldmVudERlZmF1bHQgbW91c2UgZXZlbnQgdG8gcHJldmVudFxyXG4gICAgICAvLyBicm93c2VyIGltYWdlIGRyYWcgZmVhdHVyZVxyXG4gICAgICB0aGlzLl9wcmV2ZW50UG9pbnRlckV2ZW50QmVoYXZpb3VyKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlUG9pbnRzKGUsICdkb3duJyk7XHJcblxyXG4gICAgdGhpcy5wb2ludGVyRG93biA9IHRydWU7XHJcblxyXG4gICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA9PT0gMSkge1xyXG4gICAgICB0aGlzLmRyYWdBeGlzID0gbnVsbDtcclxuICAgICAgLy8gd2UgbmVlZCB0byBzdG9yZSBpbml0aWFsIHBvaW50IHRvIGRldGVybWluZSB0aGUgbWFpbiBheGlzLFxyXG4gICAgICAvLyBkcmFnIGlzIGFjdGl2YXRlZCBvbmx5IGFmdGVyIHRoZSBheGlzIGlzIGRldGVybWluZWRcclxuICAgICAgZXF1YWxpemVQb2ludHModGhpcy5zdGFydFAxLCB0aGlzLnAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID4gMSkge1xyXG4gICAgICAvLyBUYXAgb3IgZG91YmxlIHRhcCBzaG91bGQgbm90IHRyaWdnZXIgaWYgbW9yZSB0aGFuIG9uZSBwb2ludGVyXHJcbiAgICAgIHRoaXMuX2NsZWFyVGFwVGltZXIoKTtcclxuICAgICAgdGhpcy5pc011bHRpdG91Y2ggPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pc011bHRpdG91Y2ggPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgb25Qb2ludGVyTW92ZShlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGFsd2F5cyBwcmV2ZW50RGVmYXVsdCBtb3ZlIGV2ZW50XHJcblxyXG4gICAgaWYgKCF0aGlzLl9udW1BY3RpdmVQb2ludHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVBvaW50cyhlLCAnbW92ZScpO1xyXG5cclxuICAgIGlmICh0aGlzLnBzd3AuZGlzcGF0Y2goJ3BvaW50ZXJNb3ZlJywgeyBvcmlnaW5hbEV2ZW50OiBlIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDEgJiYgIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICBpZiAoIXRoaXMuZHJhZ0F4aXMpIHtcclxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVEcmFnRGlyZWN0aW9uKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYWcgYXhpcyB3YXMgZGV0ZWN0ZWQsIGVtaXQgZHJhZy5zdGFydFxyXG4gICAgICBpZiAodGhpcy5kcmFnQXhpcyAmJiAhdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNab29taW5nKSB7XHJcbiAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy56b29tTGV2ZWxzLmVuZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jbGVhclRhcFRpbWVyKCk7IC8vIFRhcCBjYW4gbm90IHRyaWdnZXIgYWZ0ZXIgZHJhZ1xyXG5cclxuICAgICAgICAvLyBBZGp1c3Qgc3RhcnRpbmcgcG9pbnRcclxuICAgICAgICB0aGlzLl91cGRhdGVTdGFydFBvaW50cygpO1xyXG4gICAgICAgIHRoaXMuX2ludGVydmFsVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgLy90aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9pbnRlcnZhbFRpbWU7XHJcbiAgICAgICAgdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgZXF1YWxpemVQb2ludHModGhpcy5faW50ZXJ2YWxQMSwgdGhpcy5wMSk7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAwO1xyXG4gICAgICAgIHRoaXMuZHJhZy5zdGFydCgpO1xyXG5cclxuICAgICAgICB0aGlzLl9yYWZTdG9wTG9vcCgpO1xyXG4gICAgICAgIHRoaXMuX3JhZlJlbmRlckxvb3AoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPiAxICYmICF0aGlzLmlzWm9vbWluZykge1xyXG4gICAgICB0aGlzLl9maW5pc2hEcmFnKCk7XHJcblxyXG4gICAgICB0aGlzLmlzWm9vbWluZyA9IHRydWU7XHJcblxyXG4gICAgICAvLyBBZGp1c3Qgc3RhcnRpbmcgcG9pbnRzXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXJ0UG9pbnRzKCk7XHJcblxyXG4gICAgICB0aGlzLnpvb21MZXZlbHMuc3RhcnQoKTtcclxuXHJcbiAgICAgIHRoaXMuX3JhZlN0b3BMb29wKCk7XHJcbiAgICAgIHRoaXMuX3JhZlJlbmRlckxvb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2ZpbmlzaERyYWcoKSB7XHJcbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gVHJ5IHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eSxcclxuICAgICAgLy8gaWYgaXQgd2Fzbid0IGNhbGN1bGF0ZWQgeWV0IGluIGRyYWcuY2hhbmdlXHJcbiAgICAgIGlmICghdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVmVsb2NpdHkodHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZHJhZy5lbmQoKTtcclxuICAgICAgdGhpcy5kcmFnQXhpcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZVxyXG4gICAqL1xyXG4gIG9uUG9pbnRlclVwKGUpIHtcclxuICAgIGlmICghdGhpcy5fbnVtQWN0aXZlUG9pbnRzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVQb2ludHMoZSwgJ3VwJyk7XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgncG9pbnRlclVwJywgeyBvcmlnaW5hbEV2ZW50OiBlIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDApIHtcclxuICAgICAgdGhpcy5wb2ludGVyRG93biA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9yYWZTdG9wTG9vcCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaERyYWcoKTtcclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1pvb21pbmcgJiYgIXRoaXMuaXNNdWx0aXRvdWNoKSB7XHJcbiAgICAgICAgLy90aGlzLnpvb21MZXZlbHMuY29ycmVjdFpvb21QYW4oKTtcclxuICAgICAgICB0aGlzLl9maW5pc2hUYXAoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzIDwgMiAmJiB0aGlzLmlzWm9vbWluZykge1xyXG4gICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnpvb21MZXZlbHMuZW5kKCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID09PSAxKSB7XHJcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSAxIHBvaW50IGxlZnQsIHdlIG5lZWQgdG8gcmVpbml0aWF0ZSBkcmFnXHJcbiAgICAgICAgdGhpcy5kcmFnQXhpcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhcnRQb2ludHMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmFmUmVuZGVyTG9vcCgpIHtcclxuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgfHwgdGhpcy5pc1pvb21pbmcpIHtcclxuICAgICAgdGhpcy5fdXBkYXRlVmVsb2NpdHkoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCBwb2ludGVyIG1vdmVkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICAgIGlmICghcG9pbnRzRXF1YWwodGhpcy5wMSwgdGhpcy5wcmV2UDEpKSB7XHJcbiAgICAgICAgICB0aGlzLmRyYWcuY2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgLyogaWYgKHRoaXMuaXNab29taW5nKSAqLyB7XHJcbiAgICAgICAgaWYgKCFwb2ludHNFcXVhbCh0aGlzLnAxLCB0aGlzLnByZXZQMSlcclxuICAgICAgICAgICAgfHwgIXBvaW50c0VxdWFsKHRoaXMucDIsIHRoaXMucHJldlAyKSkge1xyXG4gICAgICAgICAgdGhpcy56b29tTGV2ZWxzLmNoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdXBkYXRlUHJldlBvaW50cygpO1xyXG4gICAgICB0aGlzLnJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yYWZSZW5kZXJMb29wLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHZlbG9jaXR5IGF0IDUwbXMgaW50ZXJ2YWxcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXHJcbiAgICovXHJcbiAgX3VwZGF0ZVZlbG9jaXR5KGZvcmNlKSB7XHJcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGltZSAtIHRoaXMuX2ludGVydmFsVGltZTtcclxuXHJcbiAgICBpZiAoZHVyYXRpb24gPCA1MCAmJiAhZm9yY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0aGlzLnZlbG9jaXR5LnggPSB0aGlzLl9nZXRWZWxvY2l0eSgneCcsIGR1cmF0aW9uKTtcclxuICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuX2dldFZlbG9jaXR5KCd5JywgZHVyYXRpb24pO1xyXG5cclxuICAgIHRoaXMuX2ludGVydmFsVGltZSA9IHRpbWU7XHJcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLl9pbnRlcnZhbFAxLCB0aGlzLnAxKTtcclxuICAgIHRoaXMuX3ZlbG9jaXR5Q2FsY3VsYXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgX2ZpbmlzaFRhcChlKSB7XHJcbiAgICBjb25zdCB7IG1haW5TY3JvbGwgfSA9IHRoaXMucHN3cDtcclxuXHJcbiAgICAvLyBEbyBub3QgdHJpZ2dlciB0YXAgZXZlbnRzIGlmIG1haW4gc2Nyb2xsIGlzIHNoaWZ0ZWRcclxuICAgIGlmIChtYWluU2Nyb2xsLmlzU2hpZnRlZCgpKSB7XHJcbiAgICAgIC8vIHJlc3RvcmUgbWFpbiBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgLy8gKHVzdWFsbHkgaGFwcGVucyBpZiBzdG9wcGVkIGluIHRoZSBtaWRkbGUgb2YgYW5pbWF0aW9uKVxyXG4gICAgICBtYWluU2Nyb2xsLm1vdmVJbmRleEJ5KDAsIHRydWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gbm90IHRyaWdnZXIgdGFwIGZvciB0b3VjaGNhbmNlbCBvciBwb2ludGVyY2FuY2VsXHJcbiAgICBpZiAoZS50eXBlLmluZGV4T2YoJ2NhbmNlbCcpID4gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJpZ2dlciBjbGljayBpbnN0ZWFkIG9mIHRhcCBmb3IgbW91c2UgZXZlbnRzXHJcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xyXG4gICAgICB0aGlzLnRhcEhhbmRsZXIuY2xpY2sodGhpcy5zdGFydFAxLCBlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc2FibGUgZGVsYXkgaWYgdGhlcmUgaXMgbm8gZG91YmxlVGFwQWN0aW9uXHJcbiAgICBjb25zdCB0YXBEZWxheSA9IHRoaXMucHN3cC5vcHRpb25zLmRvdWJsZVRhcEFjdGlvbiA/IERPVUJMRV9UQVBfREVMQVkgOiAwO1xyXG5cclxuICAgIC8vIElmIHRhcFRpbWVyIGlzIGRlZmluZWQgLSB3ZSB0YXBwZWQgcmVjZW50bHksXHJcbiAgICAvLyBjaGVjayBpZiB0aGUgY3VycmVudCB0YXAgaXMgY2xvc2UgdG8gdGhlIHByZXZpb3VzIG9uZSxcclxuICAgIC8vIGlmIHllcyAtIHRyaWdnZXIgZG91YmxlIHRhcFxyXG4gICAgaWYgKHRoaXMuX3RhcFRpbWVyKSB7XHJcbiAgICAgIHRoaXMuX2NsZWFyVGFwVGltZXIoKTtcclxuICAgICAgLy8gQ2hlY2sgaWYgdHdvIHRhcHMgd2VyZSBtb3JlIG9yIGxlc3Mgb24gdGhlIHNhbWUgcGxhY2VcclxuICAgICAgaWYgKGdldERpc3RhbmNlQmV0d2Vlbih0aGlzLl9sYXN0U3RhcnRQMSwgdGhpcy5zdGFydFAxKSA8IE1JTl9UQVBfRElTVEFOQ0UpIHtcclxuICAgICAgICB0aGlzLnRhcEhhbmRsZXIuZG91YmxlVGFwKHRoaXMuc3RhcnRQMSwgZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX2xhc3RTdGFydFAxLCB0aGlzLnN0YXJ0UDEpO1xyXG4gICAgICB0aGlzLl90YXBUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFwSGFuZGxlci50YXAodGhpcy5zdGFydFAxLCBlKTtcclxuICAgICAgICB0aGlzLl9jbGVhclRhcFRpbWVyKCk7XHJcbiAgICAgIH0sIHRhcERlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NsZWFyVGFwVGltZXIoKSB7XHJcbiAgICBpZiAodGhpcy5fdGFwVGltZXIpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RhcFRpbWVyKTtcclxuICAgICAgdGhpcy5fdGFwVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHZlbG9jaXR5IGZvciBheGlzXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAgICovXHJcbiAgX2dldFZlbG9jaXR5KGF4aXMsIGR1cmF0aW9uKSB7XHJcbiAgICAvLyBkaXNwbGFjZW1lbnQgaXMgbGlrZSBkaXN0YW5jZSwgYnV0IGNhbiBiZSBuZWdhdGl2ZS5cclxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMucDFbYXhpc10gLSB0aGlzLl9pbnRlcnZhbFAxW2F4aXNdO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhkaXNwbGFjZW1lbnQpID4gMSAmJiBkdXJhdGlvbiA+IDUpIHtcclxuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudCAvIGR1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmFmU3RvcExvb3AoKSB7XHJcbiAgICBpZiAodGhpcy5yYWYpIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xyXG4gICAgICB0aGlzLnJhZiA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXHJcbiAgX3ByZXZlbnRQb2ludGVyRXZlbnRCZWhhdmlvdXIoZSkge1xyXG4gICAgLy8gVE9ETyBmaW5kIGEgd2F5IHRvIGRpc2FibGUgZS5wcmV2ZW50RGVmYXVsdCBvbiBzb21lIGVsZW1lbnRzXHJcbiAgICAvLyAgICAgIHZpYSBldmVudCBvciBzb21lIGNsYXNzIG9yIHNvbWV0aGluZ1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZXMgYW5kIG5vcm1hbGl6ZXMgcG9pbnRzIGZyb20gdGhlIHRvdWNoLCBtb3VzZSBvciBwb2ludGVyIGV2ZW50LlxyXG4gICAqIFVwZGF0ZXMgcDEgYW5kIHAyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudCB8IFRvdWNoRXZlbnR9IGVcclxuICAgKiBAcGFyYW0geyd1cCcgfCAnZG93bicgfCAnbW92ZSd9IHBvaW50ZXJUeXBlIE5vcm1hbGl6ZWQgcG9pbnRlciB0eXBlXHJcbiAgICovXHJcbiAgX3VwZGF0ZVBvaW50cyhlLCBwb2ludGVyVHlwZSkge1xyXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcclxuICAgICAgY29uc3QgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtQb2ludGVyRXZlbnR9ICovIChlKTtcclxuICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGN1cnJlbnQgcG9pbnRlciBpbiBvbmdvaW5nIHBvaW50ZXJzIGJ5IGl0cyBJRFxyXG4gICAgICBjb25zdCBwb2ludGVySW5kZXggPSB0aGlzLl9vbmdvaW5nUG9pbnRlcnMuZmluZEluZGV4KChvbmdvaW5nUG9pbmVyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG9uZ29pbmdQb2luZXIuaWQgPT09IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSAndXAnICYmIHBvaW50ZXJJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgLy8gcmVsZWFzZSB0aGUgcG9pbnRlciAtIHJlbW92ZSBpdCBmcm9tIG9uZ29pbmdcclxuICAgICAgICB0aGlzLl9vbmdvaW5nUG9pbnRlcnMuc3BsaWNlKHBvaW50ZXJJbmRleCwgMSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09ICdkb3duJyAmJiBwb2ludGVySW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgLy8gYWRkIG5ldyBwb2ludGVyXHJcbiAgICAgICAgdGhpcy5fb25nb2luZ1BvaW50ZXJzLnB1c2godGhpcy5fY29udmVydEV2ZW50UG9zVG9Qb2ludChwb2ludGVyRXZlbnQsIHt9KSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlckluZGV4ID4gLTEpIHtcclxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcG9pbnRlclxyXG4gICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQocG9pbnRlckV2ZW50LCB0aGlzLl9vbmdvaW5nUG9pbnRlcnNbcG9pbnRlckluZGV4XSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IHRoaXMuX29uZ29pbmdQb2ludGVycy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB1cGRhdGUgcG9pbnRzIHRoYXQgUGhvdG9Td2lwZSB1c2VzXHJcbiAgICAgIC8vIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgc2NhbGVcclxuICAgICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA+IDApIHtcclxuICAgICAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnAxLCB0aGlzLl9vbmdvaW5nUG9pbnRlcnNbMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID4gMSkge1xyXG4gICAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucDIsIHRoaXMuX29uZ29pbmdQb2ludGVyc1sxXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHRvdWNoRXZlbnQgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovIChlKTtcclxuXHJcbiAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IDA7XHJcbiAgICAgIGlmICh0b3VjaEV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+IC0xKSB7XHJcbiAgICAgICAgLy8gVG91Y2ggRXZlbnRcclxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVG91Y2hFdmVudFxyXG4gICAgICAgIGlmICh0b3VjaEV2ZW50LnRvdWNoZXMgJiYgdG91Y2hFdmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQodG91Y2hFdmVudC50b3VjaGVzWzBdLCB0aGlzLnAxKTtcclxuICAgICAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cysrO1xyXG4gICAgICAgICAgaWYgKHRvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQodG91Y2hFdmVudC50b3VjaGVzWzFdLCB0aGlzLnAyKTtcclxuICAgICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE1vdXNlIEV2ZW50XHJcbiAgICAgICAgdGhpcy5fY29udmVydEV2ZW50UG9zVG9Qb2ludCgvKiogQHR5cGUge1BvaW50ZXJFdmVudH0gKi8gKGUpLCB0aGlzLnAxKTtcclxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09ICd1cCcpIHtcclxuICAgICAgICAgIC8vIGNsZWFyIGFsbCBwb2ludHMgb24gbW91c2V1cFxyXG4gICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGUgcG9pbnRzIHRoYXQgd2VyZSB1c2VkIGR1cmluZyBwcmV2aW91cyByQUYgdGlja1xyXG4gIF91cGRhdGVQcmV2UG9pbnRzKCkge1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5wcmV2UDEsIHRoaXMucDEpO1xyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy5wcmV2UDIsIHRoaXMucDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gdXBkYXRlIHBvaW50cyBhdCB0aGUgc3RhcnQgb2YgZ2VzdHVyZVxyXG4gIF91cGRhdGVTdGFydFBvaW50cygpIHtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQMSwgdGhpcy5wMSk7XHJcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnN0YXJ0UDIsIHRoaXMucDIpO1xyXG4gICAgdGhpcy5fdXBkYXRlUHJldlBvaW50cygpO1xyXG4gIH1cclxuXHJcbiAgX2NhbGN1bGF0ZURyYWdEaXJlY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKCkpIHtcclxuICAgICAgLy8gaWYgbWFpbiBzY3JvbGwgcG9zaXRpb24gaXMgc2hpZnRlZCDigJMgZGlyZWN0aW9uIGlzIGFsd2F5cyBob3Jpem9udGFsXHJcbiAgICAgIHRoaXMuZHJhZ0F4aXMgPSAneCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjYWxjdWxhdGUgZGVsdGEgb2YgdGhlIGxhc3QgdG91Y2htb3ZlIHRpY2tcclxuICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHRoaXMucDEueCAtIHRoaXMuc3RhcnRQMS54KSAtIE1hdGguYWJzKHRoaXMucDEueSAtIHRoaXMuc3RhcnRQMS55KTtcclxuXHJcbiAgICAgIGlmIChkaWZmICE9PSAwKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgcG9pbnRlciB3YXMgc2hpZnRlZCBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxyXG4gICAgICAgIGNvbnN0IGF4aXNUb0NoZWNrID0gZGlmZiA+IDAgPyAneCcgOiAneSc7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnAxW2F4aXNUb0NoZWNrXSAtIHRoaXMuc3RhcnRQMVtheGlzVG9DaGVja10pID49IEFYSVNfU1dJUEVfSFlTVEVSSVNJUykge1xyXG4gICAgICAgICAgdGhpcy5kcmFnQXhpcyA9IGF4aXNUb0NoZWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdG91Y2gsIHBvaW50ZXIgb3IgbW91c2UgZXZlbnRcclxuICAgKiB0byBQaG90b1N3aXBlIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1RvdWNoIHwgUG9pbnRlckV2ZW50fSBlXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcFxyXG4gICAqL1xyXG4gIF9jb252ZXJ0RXZlbnRQb3NUb1BvaW50KGUsIHApIHtcclxuICAgIHAueCA9IGUucGFnZVggLSB0aGlzLnBzd3Aub2Zmc2V0Lng7XHJcbiAgICBwLnkgPSBlLnBhZ2VZIC0gdGhpcy5wc3dwLm9mZnNldC55O1xyXG5cclxuICAgIGlmICgncG9pbnRlcklkJyBpbiBlKSB7XHJcbiAgICAgIHAuaWQgPSBlLnBvaW50ZXJJZDtcclxuICAgIH0gZWxzZSBpZiAoZS5pZGVudGlmaWVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcC5pZCA9IGUuaWRlbnRpZmllcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGVcclxuICAgKi9cclxuICBfb25DbGljayhlKSB7XHJcbiAgICAvLyBEbyBub3QgYWxsb3cgY2xpY2sgZXZlbnQgdG8gcGFzcyB0aHJvdWdoIGFmdGVyIGRyYWdcclxuICAgIGlmICh0aGlzLnBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL3NsaWRlLmpzJykuZGVmYXVsdH0gU2xpZGUgKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7eyBlbDogSFRNTERpdkVsZW1lbnQ7IHNsaWRlPzogU2xpZGUgfX0gSXRlbUhvbGRlciAqL1xyXG5cclxuY29uc3QgTUFJTl9TQ1JPTExfRU5EX0ZSSUNUSU9OID0gMC4zNTtcclxuXHJcblxyXG4vLyBjb25zdCBNSU5fU1dJUEVfVFJBTlNJVElPTl9EVVJBVElPTiA9IDI1MDtcclxuLy8gY29uc3QgTUFYX1NXSVBFX1RSQUJTSVRJT05fRFVSQVRJT04gPSA1MDA7XHJcbi8vIGNvbnN0IERFRkFVTFRfU1dJUEVfVFJBTlNJVElPTl9EVVJBVElPTiA9IDMzMztcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIG1vdmVtZW50IG9mIHRoZSBtYWluIHNjcm9sbGluZyBjb250YWluZXJcclxuICogKGZvciBleGFtcGxlLCBpdCByZXBvc2l0aW9ucyB3aGVuIHVzZXIgc3dpcGVzIGxlZnQgb3IgcmlnaHQpLlxyXG4gKlxyXG4gKiBBbHNvIHN0b3JlcyBpdHMgc3RhdGUuXHJcbiAqL1xyXG5jbGFzcyBNYWluU2Nyb2xsIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XHJcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xyXG4gICAgdGhpcy54ID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2xpZGVXaWR0aCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKiogQHR5cGUge0l0ZW1Ib2xkZXJbXX0gKi9cclxuICAgIHRoaXMuaXRlbUhvbGRlcnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5yZXNldFBvc2l0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3NpdGlvbiB0aGUgc2Nyb2xsZXIgYW5kIHNsaWRlIGNvbnRhaW5lcnNcclxuICAgKiBhY2NvcmRpbmcgdG8gdmlld3BvcnQgc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlc2l6ZVNsaWRlcyBXaGV0aGVyIHNsaWRlcyBjb250ZW50IHNob3VsZCByZXNpemVkXHJcbiAgICovXHJcbiAgcmVzaXplKHJlc2l6ZVNsaWRlcykge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgY29uc3QgbmV3U2xpZGVXaWR0aCA9IE1hdGgucm91bmQoXHJcbiAgICAgIHBzd3Audmlld3BvcnRTaXplLnggKyBwc3dwLnZpZXdwb3J0U2l6ZS54ICogcHN3cC5vcHRpb25zLnNwYWNpbmdcclxuICAgICk7XHJcbiAgICAvLyBNb2JpbGUgYnJvd3NlcnMgbWlnaHQgdHJpZ2dlciBhIHJlc2l6ZSBldmVudCBkdXJpbmcgYSBnZXN0dXJlLlxyXG4gICAgLy8gKGR1ZSB0byB0b29sYmFyIGFwcGVhcmluZyBvciBoaWRpbmcpLlxyXG4gICAgLy8gQXZvaWQgcmUtYWRqdXN0aW5nIG1haW4gc2Nyb2xsIHBvc2l0aW9uIGlmIHdpZHRoIHdhc24ndCBjaGFuZ2VkXHJcbiAgICBjb25zdCBzbGlkZVdpZHRoQ2hhbmdlZCA9IChuZXdTbGlkZVdpZHRoICE9PSB0aGlzLnNsaWRlV2lkdGgpO1xyXG5cclxuICAgIGlmIChzbGlkZVdpZHRoQ2hhbmdlZCkge1xyXG4gICAgICB0aGlzLnNsaWRlV2lkdGggPSBuZXdTbGlkZVdpZHRoO1xyXG4gICAgICB0aGlzLm1vdmVUbyh0aGlzLmdldEN1cnJTbGlkZVgoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pdGVtSG9sZGVycy5mb3JFYWNoKChpdGVtSG9sZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoc2xpZGVXaWR0aENoYW5nZWQpIHtcclxuICAgICAgICBzZXRUcmFuc2Zvcm0oaXRlbUhvbGRlci5lbCwgKGluZGV4ICsgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGlzLnNsaWRlV2lkdGgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzaXplU2xpZGVzICYmIGl0ZW1Ib2xkZXIuc2xpZGUpIHtcclxuICAgICAgICBpdGVtSG9sZGVyLnNsaWRlLnJlc2l6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IFggcG9zaXRpb24gb2YgdGhlIG1haW4gc2Nyb2xsZXIgdG8gemVyb1xyXG4gICAqL1xyXG4gIHJlc2V0UG9zaXRpb24oKSB7XHJcbiAgICAvLyBQb3NpdGlvbiBvbiB0aGUgbWFpbiBzY3JvbGxlciAob2Zmc2V0KVxyXG4gICAgLy8gaXQgaXMgaW5kZXBlbmRlbnQgZnJvbSBzbGlkZSBpbmRleFxyXG4gICAgdGhpcy5fY3VyclBvc2l0aW9uSW5kZXggPSAwO1xyXG4gICAgdGhpcy5fcHJldlBvc2l0aW9uSW5kZXggPSAwO1xyXG5cclxuICAgIC8vIFRoaXMgd2lsbCBmb3JjZSByZWNhbGN1bGF0aW9uIG9mIHNpemUgb24gbmV4dCByZXNpemUoKVxyXG4gICAgdGhpcy5zbGlkZVdpZHRoID0gMDtcclxuXHJcbiAgICAvLyBfY29udGFpbmVyU2hpZnRJbmRleCp2aWV3cG9ydFNpemUgd2lsbCBnaXZlIHlvdSBhbW91bnQgb2YgdHJhbnNmb3JtIG9mIHRoZSBjdXJyZW50IHNsaWRlXHJcbiAgICB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4ID0gLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW5kIGFwcGVuZCBhcnJheSBvZiB0aHJlZSBpdGVtc1xyXG4gICAqIHRoYXQgaG9sZCBkYXRhIGFib3V0IHNsaWRlcyBpbiBET01cclxuICAgKi9cclxuICBhcHBlbmRIb2xkZXJzKCkge1xyXG4gICAgdGhpcy5pdGVtSG9sZGVycyA9IFtdO1xyXG5cclxuICAgIC8vIGFwcGVuZCBvdXIgdGhyZWUgc2xpZGUgaG9sZGVycyAtXHJcbiAgICAvLyBwcmV2aW91cywgY3VycmVudCwgYW5kIG5leHRcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudCgncHN3cF9faXRlbScsIGZhbHNlLCB0aGlzLnBzd3AuY29udGFpbmVyKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlZGVzY3JpcHRpb24nLCAnc2xpZGUnKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcblxyXG4gICAgICAvLyBoaWRlIG5lYXJieSBpdGVtIGhvbGRlcnMgdW50aWwgaW5pdGlhbCB6b29tIGFuaW1hdGlvbiBmaW5pc2hlcyAodG8gYXZvaWQgZXh0cmEgUGFpbnRzKVxyXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gKGkgPT09IDEpID8gJ2Jsb2NrJyA6ICdub25lJztcclxuXHJcbiAgICAgIHRoaXMuaXRlbUhvbGRlcnMucHVzaCh7XHJcbiAgICAgICAgZWwsXHJcbiAgICAgICAgLy9pbmRleDogLTFcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBtYWluIHNjcm9sbCBjYW4gYmUgaG9yaXpvbnRhbGx5IHN3aXBlZCB0byB0aGUgbmV4dCBvciBwcmV2aW91cyBzbGlkZS5cclxuICAgKi9cclxuICBjYW5CZVN3aXBlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnBzd3AuZ2V0TnVtSXRlbXMoKSA+IDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIG1haW4gc2Nyb2xsIGJ5IFggYW1vdW50IG9mIHNsaWRlcy5cclxuICAgKiBGb3IgZXhhbXBsZTpcclxuICAgKiAgIGAtMWAgd2lsbCBtb3ZlIHRvIHRoZSBwcmV2aW91cyBzbGlkZSxcclxuICAgKiAgICBgMGAgd2lsbCByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHNsaWRlLFxyXG4gICAqICAgIGAzYCB3aWxsIG1vdmUgdGhyZWUgc2xpZGVzIGZvcndhcmRcclxuICAgKlxyXG4gICAqIElmIGxvb3Agb3B0aW9uIGlzIGVuYWJsZWQgLSBpbmRleCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgbG9vcGVkIHRvbyxcclxuICAgKiAoZm9yIGV4YW1wbGUgYC0xYCB3aWxsIG1vdmUgdG8gdGhlIGxhc3Qgc2xpZGUgb2YgdGhlIGdhbGxlcnkpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBhbmltYXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSB2ZWxvY2l0eVhcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBpbmRleCB3YXMgY2hhbmdlZCBvciBub3RcclxuICAgKi9cclxuICBtb3ZlSW5kZXhCeShkaWZmLCBhbmltYXRlLCB2ZWxvY2l0eVgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGxldCBuZXdJbmRleCA9IHBzd3AucG90ZW50aWFsSW5kZXggKyBkaWZmO1xyXG4gICAgY29uc3QgbnVtU2xpZGVzID0gcHN3cC5nZXROdW1JdGVtcygpO1xyXG5cclxuICAgIGlmIChwc3dwLmNhbkxvb3AoKSkge1xyXG4gICAgICBuZXdJbmRleCA9IHBzd3AuZ2V0TG9vcGVkSW5kZXgobmV3SW5kZXgpO1xyXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IChkaWZmICsgbnVtU2xpZGVzKSAlIG51bVNsaWRlcztcclxuICAgICAgaWYgKGRpc3RhbmNlIDw9IG51bVNsaWRlcyAvIDIpIHtcclxuICAgICAgICAvLyBnbyBmb3J3YXJkXHJcbiAgICAgICAgZGlmZiA9IGRpc3RhbmNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGdvIGJhY2t3YXJkc1xyXG4gICAgICAgIGRpZmYgPSBkaXN0YW5jZSAtIG51bVNsaWRlcztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xyXG4gICAgICAgIG5ld0luZGV4ID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChuZXdJbmRleCA+PSBudW1TbGlkZXMpIHtcclxuICAgICAgICBuZXdJbmRleCA9IG51bVNsaWRlcyAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgZGlmZiA9IG5ld0luZGV4IC0gcHN3cC5wb3RlbnRpYWxJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICBwc3dwLnBvdGVudGlhbEluZGV4ID0gbmV3SW5kZXg7XHJcbiAgICB0aGlzLl9jdXJyUG9zaXRpb25JbmRleCAtPSBkaWZmO1xyXG5cclxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wTWFpblNjcm9sbCgpO1xyXG5cclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uWCA9IHRoaXMuZ2V0Q3VyclNsaWRlWCgpO1xyXG4gICAgaWYgKCFhbmltYXRlKSB7XHJcbiAgICAgIHRoaXMubW92ZVRvKGRlc3RpbmF0aW9uWCk7XHJcbiAgICAgIHRoaXMudXBkYXRlQ3Vyckl0ZW0oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBzd3AuYW5pbWF0aW9ucy5zdGFydFNwcmluZyh7XHJcbiAgICAgICAgaXNNYWluU2Nyb2xsOiB0cnVlLFxyXG4gICAgICAgIHN0YXJ0OiB0aGlzLngsXHJcbiAgICAgICAgZW5kOiBkZXN0aW5hdGlvblgsXHJcbiAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5WCB8fCAwLFxyXG4gICAgICAgIG5hdHVyYWxGcmVxdWVuY3k6IDMwLFxyXG4gICAgICAgIGRhbXBpbmdSYXRpbzogMSwgLy8wLjcsXHJcbiAgICAgICAgb25VcGRhdGU6ICh4KSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm1vdmVUbyh4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMudXBkYXRlQ3Vyckl0ZW0oKTtcclxuICAgICAgICAgIHBzd3AuYXBwZW5kSGVhdnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IGN1cnJEaWZmID0gcHN3cC5wb3RlbnRpYWxJbmRleCAtIHBzd3AuY3VyckluZGV4O1xyXG4gICAgICBpZiAocHN3cC5jYW5Mb29wKCkpIHtcclxuICAgICAgICBjb25zdCBjdXJyRGlzdGFuY2UgPSAoY3VyckRpZmYgKyBudW1TbGlkZXMpICUgbnVtU2xpZGVzO1xyXG4gICAgICAgIGlmIChjdXJyRGlzdGFuY2UgPD0gbnVtU2xpZGVzIC8gMikge1xyXG4gICAgICAgICAgLy8gZ28gZm9yd2FyZFxyXG4gICAgICAgICAgY3VyckRpZmYgPSBjdXJyRGlzdGFuY2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGdvIGJhY2t3YXJkc1xyXG4gICAgICAgICAgY3VyckRpZmYgPSBjdXJyRGlzdGFuY2UgLSBudW1TbGlkZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGb3JjZS1hcHBlbmQgbmV3IHNsaWRlcyBkdXJpbmcgdHJhbnNpdGlvblxyXG4gICAgICAvLyBpZiBkaWZmZXJlbmNlIGJldHdlZW4gc2xpZGVzIGlzIG1vcmUgdGhhbiAxXHJcbiAgICAgIGlmIChNYXRoLmFicyhjdXJyRGlmZikgPiAxKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDdXJySXRlbSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRpZmYpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBYIHBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCBmb3IgdGhlIGN1cnJlbnQgc2xpZGVcclxuICAgKiAoaWdub3JlcyBwb3NpdGlvbiBkdXJpbmcgZHJhZ2dpbmcpXHJcbiAgICovXHJcbiAgZ2V0Q3VyclNsaWRlWCgpIHtcclxuICAgIHJldHVybiB0aGlzLnNsaWRlV2lkdGggKiB0aGlzLl9jdXJyUG9zaXRpb25JbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgc2Nyb2xsIHBvc2l0aW9uIGlzIHNoaWZ0ZWQuXHJcbiAgICogRm9yIGV4YW1wbGUsIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHNjcm9sbCBpcyBiZWluZyBkcmFnZ2VkIG9yIGFuaW1hdGVkLlxyXG4gICAqL1xyXG4gIGlzU2hpZnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnggIT09IHRoaXMuZ2V0Q3VyclNsaWRlWCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNsaWRlcyBYIHBvc2l0aW9ucyBhbmQgc2V0IHRoZWlyIGNvbnRlbnRcclxuICAgKi9cclxuICB1cGRhdGVDdXJySXRlbSgpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHBvc2l0aW9uRGlmZmVyZW5jZSA9IHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4IC0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XHJcblxyXG4gICAgaWYgKCFwb3NpdGlvbkRpZmZlcmVuY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4ID0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XHJcblxyXG4gICAgcHN3cC5jdXJySW5kZXggPSBwc3dwLnBvdGVudGlhbEluZGV4O1xyXG5cclxuICAgIGxldCBkaWZmQWJzID0gTWF0aC5hYnMocG9zaXRpb25EaWZmZXJlbmNlKTtcclxuICAgIGxldCB0ZW1wSG9sZGVyO1xyXG5cclxuICAgIGlmIChkaWZmQWJzID49IDMpIHtcclxuICAgICAgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCArPSBwb3NpdGlvbkRpZmZlcmVuY2UgKyAocG9zaXRpb25EaWZmZXJlbmNlID4gMCA/IC0zIDogMyk7XHJcbiAgICAgIGRpZmZBYnMgPSAzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZkFiczsgaSsrKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbkRpZmZlcmVuY2UgPiAwKSB7XHJcbiAgICAgICAgdGVtcEhvbGRlciA9IHRoaXMuaXRlbUhvbGRlcnMuc2hpZnQoKTtcclxuICAgICAgICB0aGlzLml0ZW1Ib2xkZXJzWzJdID0gdGVtcEhvbGRlcjsgLy8gbW92ZSBmaXJzdCB0byBsYXN0XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXgrKztcclxuXHJcbiAgICAgICAgc2V0VHJhbnNmb3JtKHRlbXBIb2xkZXIuZWwsICh0aGlzLl9jb250YWluZXJTaGlmdEluZGV4ICsgMikgKiB0aGlzLnNsaWRlV2lkdGgpO1xyXG5cclxuICAgICAgICBwc3dwLnNldENvbnRlbnQodGVtcEhvbGRlciwgKHBzd3AuY3VyckluZGV4IC0gZGlmZkFicykgKyBpICsgMik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGVtcEhvbGRlciA9IHRoaXMuaXRlbUhvbGRlcnMucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pdGVtSG9sZGVycy51bnNoaWZ0KHRlbXBIb2xkZXIpOyAvLyBtb3ZlIGxhc3QgdG8gZmlyc3RcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleC0tO1xyXG5cclxuICAgICAgICBzZXRUcmFuc2Zvcm0odGVtcEhvbGRlci5lbCwgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCAqIHRoaXMuc2xpZGVXaWR0aCk7XHJcblxyXG4gICAgICAgIHBzd3Auc2V0Q29udGVudCh0ZW1wSG9sZGVyLCAocHN3cC5jdXJySW5kZXggKyBkaWZmQWJzKSAtIGkgLSAyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IHRyYW5zZnJvbSBldmVyeSA1MGlzaCBuYXZpZ2F0aW9ucyBpbiBvbmUgZGlyZWN0aW9uLlxyXG4gICAgLy9cclxuICAgIC8vIE90aGVyd2lzZSB0cmFuc2Zvcm0gd2lsbCBrZWVwIGdyb3dpbmcgaW5kZWZpbml0ZWx5LFxyXG4gICAgLy8gd2hpY2ggbWlnaHQgY2F1c2UgaXNzdWVzIGFzIGJyb3dzZXJzIGhhdmUgYSBtYXhpbXVtIHRyYW5zZm9ybSBsaW1pdC5cclxuICAgIC8vIEkgd2Fzbid0IGFibGUgdG8gcmVhY2ggaXQsIGJ1dCBqdXN0IHRvIGJlIHNhZmUuXHJcbiAgICAvLyBUaGlzIHNob3VsZCBub3QgY2F1c2Ugbm90aWNhYmxlIGxhZy5cclxuICAgIGlmIChNYXRoLmFicyh0aGlzLl9jb250YWluZXJTaGlmdEluZGV4KSA+IDUwICYmICF0aGlzLmlzU2hpZnRlZCgpKSB7XHJcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xyXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhbiB0cmFuc2l0aW9uIG1pZ2h0IGJlIHJ1bm5pbmcgKGFuZCBjb25zbnRhbnRseSB1cGRhdGluZyBwYW4gcG9zaXRpb24pXHJcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RvcEFsbFBhbigpO1xyXG5cclxuICAgIHRoaXMuaXRlbUhvbGRlcnMuZm9yRWFjaCgoaXRlbUhvbGRlciwgaSkgPT4ge1xyXG4gICAgICBpZiAoaXRlbUhvbGRlci5zbGlkZSkge1xyXG4gICAgICAgIC8vIFNsaWRlIGluIHRoZSAybmQgaG9sZGVyIGlzIGFsd2F5cyBhY3RpdmVcclxuICAgICAgICBpdGVtSG9sZGVyLnNsaWRlLnNldElzQWN0aXZlKGkgPT09IDEpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBwc3dwLmN1cnJTbGlkZSA9IHRoaXMuaXRlbUhvbGRlcnNbMV0uc2xpZGU7XHJcbiAgICBwc3dwLmNvbnRlbnRMb2FkZXIudXBkYXRlTGF6eShwb3NpdGlvbkRpZmZlcmVuY2UpO1xyXG5cclxuICAgIGlmIChwc3dwLmN1cnJTbGlkZSkge1xyXG4gICAgICBwc3dwLmN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaCgnY2hhbmdlJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBYIHBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCBjb250YWluZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZHJhZ2dpbmdcclxuICAgKi9cclxuICBtb3ZlVG8oeCwgZHJhZ2dpbmcpIHtcclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgbGV0IG5ld1NsaWRlSW5kZXhPZmZzZXQ7XHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIGxldCBkZWx0YTtcclxuXHJcbiAgICBpZiAoIXRoaXMucHN3cC5jYW5Mb29wKCkgJiYgZHJhZ2dpbmcpIHtcclxuICAgICAgLy8gQXBwbHkgZnJpY3Rpb25cclxuICAgICAgbmV3U2xpZGVJbmRleE9mZnNldCA9ICgodGhpcy5zbGlkZVdpZHRoICogdGhpcy5fY3VyclBvc2l0aW9uSW5kZXgpIC0geCkgLyB0aGlzLnNsaWRlV2lkdGg7XHJcbiAgICAgIG5ld1NsaWRlSW5kZXhPZmZzZXQgKz0gdGhpcy5wc3dwLmN1cnJJbmRleDtcclxuICAgICAgZGVsdGEgPSBNYXRoLnJvdW5kKHggLSB0aGlzLngpO1xyXG5cclxuICAgICAgaWYgKChuZXdTbGlkZUluZGV4T2Zmc2V0IDwgMCAmJiBkZWx0YSA+IDApXHJcbiAgICAgICAgICB8fCAobmV3U2xpZGVJbmRleE9mZnNldCA+PSB0aGlzLnBzd3AuZ2V0TnVtSXRlbXMoKSAtIDEgJiYgZGVsdGEgPCAwKSkge1xyXG4gICAgICAgIHggPSB0aGlzLnggKyAoZGVsdGEgKiBNQUlOX1NDUk9MTF9FTkRfRlJJQ1RJT04pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHNldFRyYW5zZm9ybSh0aGlzLnBzd3AuY29udGFpbmVyLCB4KTtcclxuXHJcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ21vdmVNYWluU2Nyb2xsJywgeyB4LCBkcmFnZ2luZyB9KTtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuXHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuTWV0aG9kczxUPn0gTWV0aG9kczxUPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiAtIE1hbmFnZXMga2V5Ym9hcmQgc2hvcnRjdXRzLlxyXG4gKiAtIEhlcHMgdHJhcCBmb2N1cyB3aXRoaW4gcGhvdG9zd2lwZS5cclxuICovXHJcbmNsYXNzIEtleWJvYXJkIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XHJcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xyXG5cclxuICAgIHBzd3Aub24oJ2JpbmRFdmVudHMnLCAoKSA9PiB7XHJcbiAgICAgIC8vIERpYWxvZyB3YXMgbGlrZWx5IG9wZW5lZCBieSBrZXlib2FyZCBpZiBpbml0aWFsIHBvaW50IGlzIG5vdCBkZWZpbmVkXHJcbiAgICAgIGlmICghcHN3cC5vcHRpb25zLmluaXRpYWxQb2ludGVyUG9zKSB7XHJcbiAgICAgICAgLy8gZm9jdXMgY2F1c2VzIGxheW91dCxcclxuICAgICAgICAvLyB3aGljaCBjYXVzZXMgbGFnIGR1cmluZyB0aGUgYW5pbWF0aW9uLFxyXG4gICAgICAgIC8vIHRoYXQncyB3aHkgd2UgZGVsYXkgaXQgdW50aWwgdGhlIG9wZW5lciB0cmFuc2l0aW9uIGVuZHNcclxuICAgICAgICB0aGlzLl9mb2N1c1Jvb3QoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHN3cC5ldmVudHMuYWRkKGRvY3VtZW50LCAnZm9jdXNpbicsIHRoaXMuX29uRm9jdXNJbi5iaW5kKHRoaXMpKTtcclxuICAgICAgcHN3cC5ldmVudHMuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGxhc3RBY3RpdmVFbGVtZW50ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgcHN3cC5vbignZGVzdHJveScsICgpID0+IHtcclxuICAgICAgaWYgKHBzd3Aub3B0aW9ucy5yZXR1cm5Gb2N1c1xyXG4gICAgICAgICAgJiYgbGFzdEFjdGl2ZUVsZW1lbnRcclxuICAgICAgICAgICYmIHRoaXMuX3dhc0ZvY3VzZWQpIHtcclxuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9mb2N1c1Jvb3QoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3dhc0ZvY3VzZWQpIHtcclxuICAgICAgdGhpcy5wc3dwLmVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgdGhpcy5fd2FzRm9jdXNlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcclxuICAgKi9cclxuICBfb25LZXlEb3duKGUpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuXHJcbiAgICBpZiAocHN3cC5kaXNwYXRjaCgna2V5ZG93bicsIHsgb3JpZ2luYWxFdmVudDogZSB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3BlY2lhbEtleVVzZWQoZSkpIHtcclxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgc3BlY2lhbCBrZXkgcHJlc3NlZFxyXG4gICAgICAvLyB0byBwcmV2ZW50IGZyb20gb3ZlcnJpZGluZyBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uc1xyXG4gICAgICAvLyBmb3IgZXhhbXBsZSwgaW4gQ2hyb21lIG9uIE1hYyBjbWQrYXJyb3ctbGVmdCByZXR1cm5zIHRvIHByZXZpb3VzIHBhZ2VcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAdHlwZSB7TWV0aG9kczxQaG90b1N3aXBlPn0gKi9cclxuICAgIGxldCBrZXlkb3duQWN0aW9uO1xyXG4gICAgLyoqIEB0eXBlIHsneCcgfCAneSd9ICovXHJcbiAgICBsZXQgYXhpcztcclxuICAgIGxldCBpc0ZvcndhcmQ7XHJcblxyXG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcclxuICAgICAgY2FzZSAyNzogLy8gZXNjXHJcbiAgICAgICAgaWYgKHBzd3Aub3B0aW9ucy5lc2NLZXkpIHtcclxuICAgICAgICAgIGtleWRvd25BY3Rpb24gPSAnY2xvc2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA5MDogLy8geiBrZXlcclxuICAgICAgICBrZXlkb3duQWN0aW9uID0gJ3RvZ2dsZVpvb20nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM3OiAvLyBsZWZ0XHJcbiAgICAgICAgYXhpcyA9ICd4JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzODogLy8gdG9wXHJcbiAgICAgICAgYXhpcyA9ICd5JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOTogLy8gcmlnaHRcclxuICAgICAgICBheGlzID0gJ3gnO1xyXG4gICAgICAgIGlzRm9yd2FyZCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDA6IC8vIGJvdHRvbVxyXG4gICAgICAgIGlzRm9yd2FyZCA9IHRydWU7XHJcbiAgICAgICAgYXhpcyA9ICd5JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA5OiAvLyB0YWJcclxuICAgICAgICB0aGlzLl9mb2N1c1Jvb3QoKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20ga2V5XHJcbiAgICBpZiAoYXhpcykge1xyXG4gICAgICAvLyBwcmV2ZW50IHBhZ2Ugc2Nyb2xsXHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSBwc3dwO1xyXG5cclxuICAgICAgaWYgKHBzd3Aub3B0aW9ucy5hcnJvd0tleXNcclxuICAgICAgICAgICYmIGF4aXMgPT09ICd4J1xyXG4gICAgICAgICAgJiYgcHN3cC5nZXROdW1JdGVtcygpID4gMSkge1xyXG4gICAgICAgIGtleWRvd25BY3Rpb24gPSBpc0ZvcndhcmQgPyAnbmV4dCcgOiAncHJldic7XHJcbiAgICAgIH0gZWxzZSBpZiAoY3VyclNsaWRlICYmIGN1cnJTbGlkZS5jdXJyWm9vbUxldmVsID4gY3VyclNsaWRlLnpvb21MZXZlbHMuZml0KSB7XHJcbiAgICAgICAgLy8gdXAvZG93biBhcnJvdyBrZXlzIHBhbiB0aGUgaW1hZ2UgdmVydGljYWxseVxyXG4gICAgICAgIC8vIGxlZnQvcmlnaHQgYXJyb3cga2V5cyBwYW4gaG9yaXpvbnRhbGx5LlxyXG4gICAgICAgIC8vIFVubGVzcyB0aGVyZSBpcyBvbmx5IG9uZSBpbWFnZSxcclxuICAgICAgICAvLyBvciBhcnJvd0tleXMgb3B0aW9uIGlzIGRpc2FibGVkXHJcbiAgICAgICAgY3VyclNsaWRlLnBhbltheGlzXSArPSBpc0ZvcndhcmQgPyAtODAgOiA4MDtcclxuICAgICAgICBjdXJyU2xpZGUucGFuVG8oY3VyclNsaWRlLnBhbi54LCBjdXJyU2xpZGUucGFuLnkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleWRvd25BY3Rpb24pIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBwc3dwW2tleWRvd25BY3Rpb25dKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFwIGZvY3VzIGluc2lkZSBwaG90b3N3aXBlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGVcclxuICAgKi9cclxuICBfb25Gb2N1c0luKGUpIHtcclxuICAgIGNvbnN0IHsgdGVtcGxhdGUgfSA9IHRoaXMucHN3cDtcclxuICAgIGlmIChkb2N1bWVudCAhPT0gZS50YXJnZXRcclxuICAgICAgICAmJiB0ZW1wbGF0ZSAhPT0gZS50YXJnZXRcclxuICAgICAgICAmJiAhdGVtcGxhdGUuY29udGFpbnMoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZS50YXJnZXQpKSkge1xyXG4gICAgICAvLyBmb2N1cyByb290IGVsZW1lbnRcclxuICAgICAgdGVtcGxhdGUuZm9jdXMoKTtcclxuICAgIH1cclxuICB9XHJcbn1cblxuY29uc3QgREVGQVVMVF9FQVNJTkcgPSAnY3ViaWMtYmV6aWVyKC40LDAsLjIyLDEpJztcclxuXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2FuaW1hdGlvbnMuanMnKS5BbmltYXRpb25Qcm9wc30gQW5pbWF0aW9uUHJvcHMgKi9cclxuXHJcbi8qKlxyXG4gKiBSdW5zIENTUyB0cmFuc2l0aW9uLlxyXG4gKi9cclxuY2xhc3MgQ1NTQW5pbWF0aW9uIHtcclxuICAvKipcclxuICAgKiBvbkNvbXBsZXRlIGNhbiBiZSB1bnByZWRpY3RhYmxlLCBiZSBjYXJlZnVsIGFib3V0IGN1cnJlbnQgc3RhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgIGNvbnN0IHtcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgIG9uRmluaXNoXHJcbiAgICAgIC8vIG9wYWNpdHlcclxuICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICBsZXQge1xyXG4gICAgICBkdXJhdGlvbixcclxuICAgICAgZWFzaW5nLFxyXG4gICAgfSA9IHByb3BzO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi9cclxuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDtcclxuXHJcbiAgICAvLyBzdXBwb3J0IG9ubHkgdHJhbnNmb3JtIGFuZCBvcGFjaXR5XHJcbiAgICBjb25zdCBwcm9wID0gdHJhbnNmb3JtID8gJ3RyYW5zZm9ybScgOiAnb3BhY2l0eSc7XHJcbiAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1twcm9wXTtcclxuXHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgdGhpcy5fb25Db21wbGV0ZSA9IG9uQ29tcGxldGU7XHJcblxyXG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAzMzM7XHJcbiAgICBlYXNpbmcgPSBlYXNpbmcgfHwgREVGQVVMVF9FQVNJTkc7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLl9vblRyYW5zaXRpb25FbmQgPSB0aGlzLl9vblRyYW5zaXRpb25FbmQuYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBVc2luZyB0aW1lb3V0IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgYW5pbWF0aW9uXHJcbiAgICAvLyBzdGFydHMgZXZlbiBpZiB0aGUgYW5pbWF0ZWQgcHJvcGVydHkgd2FzIGNoYW5nZWQgcmVjZW50bHksXHJcbiAgICAvLyBvdGhlcndpc2UgdHJhbnNpdGlvbmVuZCBtaWdodCBub3QgZmlyZSBvciB0cmFuc2l0b24gd29uJ3Qgc3RhcnQuXHJcbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRyYW5zaXRpb25zLyNzdGFydGluZ1xyXG4gICAgLy9cclxuICAgIC8vIMKvXFxfKOODhClfL8KvXHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHRoaXMuX2hlbHBlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRhcmdldCwgcHJvcCwgZHVyYXRpb24sIGVhc2luZyk7XHJcbiAgICAgIHRoaXMuX2hlbHBlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uY2FuY2VsJywgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIFNhZmFyaSBvY2Nhc2lvbmFsbHkgZG9lcyBub3QgZW1pdCB0cmFuc2l0aW9uZW5kIGV2ZW50XHJcbiAgICAgICAgLy8gaWYgZWxlbWVudCBwcm9wZXJ5IHdhcyBtb2RpZmllZCBkdXJpbmcgdGhlIHRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIGNhdXNlZCBieSByZXNpemUgb3IgdGhpcmQgcGFydHkgY29tcG9uZW50LFxyXG4gICAgICAgIC8vIHVzaW5nIHRpbWVvdXQgYXMgYSBzYWZldHkgZmFsbGJhY2tcclxuICAgICAgICB0aGlzLl9oZWxwZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9maW5hbGl6ZUFuaW1hdGlvbigpO1xyXG4gICAgICAgIH0sIGR1cmF0aW9uICsgNTAwKTtcclxuICAgICAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBwcm9wVmFsdWU7XHJcbiAgICAgIH0sIDMwKTsgLy8gRG8gbm90IHJlZHVjZSB0aGlzIG51bWJlclxyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBlXHJcbiAgICovXHJcbiAgX29uVHJhbnNpdGlvbkVuZChlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuX3RhcmdldCkge1xyXG4gICAgICB0aGlzLl9maW5hbGl6ZUFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfZmluYWxpemVBbmltYXRpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XHJcbiAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5vbkZpbmlzaCgpO1xyXG4gICAgICBpZiAodGhpcy5fb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuX29uQ29tcGxldGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRGVzdHJveSBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBvbkZpbmlzaFxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5faGVscGVyVGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5faGVscGVyVGltZW91dCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUcmFuc2l0aW9uU3R5bGUodGhpcy5fdGFyZ2V0KTtcclxuICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCBmYWxzZSk7XHJcbiAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmNhbmNlbCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xyXG4gICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xyXG4gICAgICB0aGlzLl9maW5hbGl6ZUFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxufVxuXG5jb25zdCBERUZBVUxUX05BVFVSQUxfRlJFUVVFTkNZID0gMTI7XHJcbmNvbnN0IERFRkFVTFRfREFNUElOR19SQVRJTyA9IDAuNzU7XHJcblxyXG4vKipcclxuICogU3ByaW5nIGVhc2luZyBoZWxwZXJcclxuICovXHJcbmNsYXNzIFNwcmluZ0Vhc2VyIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbFZlbG9jaXR5IEluaXRpYWwgdmVsb2NpdHksIHB4IHBlciBtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYW1waW5nUmF0aW9cclxuICAgKiBEZXRlcm1pbmVzIGhvdyBib3VuY3kgYW5pbWF0aW9uIHdpbGwgYmUuXHJcbiAgICogRnJvbSAwIHRvIDEsIDAgLSBhbHdheXMgb3ZlcnNob290LCAxIC0gZG8gbm90IG92ZXJzaG9vdC5cclxuICAgKiBcIm92ZXJzaG9vdFwiIHJlZmVycyB0byBwYXJ0IG9mIGFuaW1hdGlvbiB0aGF0XHJcbiAgICogZ29lcyBiZXlvbmQgdGhlIGZpbmFsIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5hdHVyYWxGcmVxdWVuY3lcclxuICAgKiBEZXRlcm1pbmVzIGhvdyBmYXN0IGFuaW1hdGlvbiB3aWxsIHNsb3cgZG93bi5cclxuICAgKiBUaGUgaGlnaGVyIHZhbHVlIC0gdGhlIHN0aWZmZXIgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSxcclxuICAgKiBhbmQgdGhlIGZhc3RlciBpdCB3aWxsIHNsb3cgZG93bi5cclxuICAgKiBSZWNvbW1lbmRlZCB2YWx1ZSBmcm9tIDEwIHRvIDUwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZlbG9jaXR5LCBkYW1waW5nUmF0aW8sIG5hdHVyYWxGcmVxdWVuY3kpIHtcclxuICAgIHRoaXMudmVsb2NpdHkgPSBpbml0aWFsVmVsb2NpdHkgKiAxMDAwOyAvLyBjb252ZXJ0IHRvIFwicGl4ZWxzIHBlciBzZWNvbmRcIlxyXG5cclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhbXBpbmdfcmF0aW9cclxuICAgIHRoaXMuX2RhbXBpbmdSYXRpbyA9IGRhbXBpbmdSYXRpbyB8fCBERUZBVUxUX0RBTVBJTkdfUkFUSU87XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmF0dXJhbF9mcmVxdWVuY3lcclxuICAgIHRoaXMuX25hdHVyYWxGcmVxdWVuY3kgPSBuYXR1cmFsRnJlcXVlbmN5IHx8IERFRkFVTFRfTkFUVVJBTF9GUkVRVUVOQ1k7XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhbXBpbmdSYXRpbyA8IDEpIHtcclxuICAgICAgdGhpcy5fZGFtcGVkRnJlcXVlbmN5ID0gdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNxcnQoMSAtIHRoaXMuX2RhbXBpbmdSYXRpbyAqIHRoaXMuX2RhbXBpbmdSYXRpbyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFQb3NpdGlvbiBEaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgZW5kIHBvc2l0aW9uIG9mIHRoZSBhbmltYXRpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIEZyYW1lIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gRGlzcGxhY2VtZW50LCByZWxhdGl2ZSB0byB0aGUgZW5kIHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGVhc2VGcmFtZShkZWx0YVBvc2l0aW9uLCBkZWx0YVRpbWUpIHtcclxuICAgIC8vIEluc3BpcmVkIGJ5IEFwcGxlIFdlYmtpdCBhbmQgQW5kcm9pZCBzcHJpbmcgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25cclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09zY2lsbGF0aW9uXHJcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYW1waW5nX3JhdGlvXHJcbiAgICAvLyB3ZSBpZ25vcmUgbWFzcyAoYXNzdW1lIHRoYXQgaXQncyAxa2cpXHJcblxyXG4gICAgbGV0IGRpc3BsYWNlbWVudCA9IDA7XHJcbiAgICBsZXQgY29lZmY7XHJcblxyXG4gICAgZGVsdGFUaW1lIC89IDEwMDA7XHJcblxyXG4gICAgY29uc3QgbmF0dXJhbER1bXBpbmdQb3cgPSBNYXRoLkUgKiogKC10aGlzLl9kYW1waW5nUmF0aW8gKiB0aGlzLl9uYXR1cmFsRnJlcXVlbmN5ICogZGVsdGFUaW1lKTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGFtcGluZ1JhdGlvID09PSAxKSB7XHJcbiAgICAgIGNvZWZmID0gdGhpcy52ZWxvY2l0eSArIHRoaXMuX25hdHVyYWxGcmVxdWVuY3kgKiBkZWx0YVBvc2l0aW9uO1xyXG5cclxuICAgICAgZGlzcGxhY2VtZW50ID0gKGRlbHRhUG9zaXRpb24gKyBjb2VmZiAqIGRlbHRhVGltZSkgKiBuYXR1cmFsRHVtcGluZ1BvdztcclxuXHJcbiAgICAgIHRoaXMudmVsb2NpdHkgPSBkaXNwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKiAoLXRoaXMuX25hdHVyYWxGcmVxdWVuY3kpICsgY29lZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKiBuYXR1cmFsRHVtcGluZ1BvdztcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGFtcGluZ1JhdGlvIDwgMSkge1xyXG4gICAgICBjb2VmZiA9ICgxIC8gdGhpcy5fZGFtcGVkRnJlcXVlbmN5KVxyXG4gICAgICAgICAgICAgICAgKiAodGhpcy5fZGFtcGluZ1JhdGlvICogdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeSAqIGRlbHRhUG9zaXRpb24gKyB0aGlzLnZlbG9jaXR5KTtcclxuXHJcbiAgICAgIGNvbnN0IGR1bXBlZEZDb3MgPSBNYXRoLmNvcyh0aGlzLl9kYW1wZWRGcmVxdWVuY3kgKiBkZWx0YVRpbWUpO1xyXG4gICAgICBjb25zdCBkdW1wZWRGU2luID0gTWF0aC5zaW4odGhpcy5fZGFtcGVkRnJlcXVlbmN5ICogZGVsdGFUaW1lKTtcclxuXHJcbiAgICAgIGRpc3BsYWNlbWVudCA9IG5hdHVyYWxEdW1waW5nUG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgKiAoZGVsdGFQb3NpdGlvbiAqIGR1bXBlZEZDb3MgKyBjb2VmZiAqIGR1bXBlZEZTaW4pO1xyXG5cclxuICAgICAgdGhpcy52ZWxvY2l0eSA9IGRpc3BsYWNlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqICgtdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGlzLl9kYW1waW5nUmF0aW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBuYXR1cmFsRHVtcGluZ1Bvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAqICgtdGhpcy5fZGFtcGVkRnJlcXVlbmN5ICogZGVsdGFQb3NpdGlvbiAqIGR1bXBlZEZTaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLl9kYW1wZWRGcmVxdWVuY3kgKiBjb2VmZiAqIGR1bXBlZEZDb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE92ZXJkYW1wZWQgKD4xKSBkYW1waW5nIHJhdGlvIGlzIG5vdCBzdXBwb3J0ZWRcclxuXHJcbiAgICByZXR1cm4gZGlzcGxhY2VtZW50O1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9hbmltYXRpb25zLmpzJykuQW5pbWF0aW9uUHJvcHN9IEFuaW1hdGlvblByb3BzICovXHJcblxyXG5jbGFzcyBTcHJpbmdBbmltYXRpb24ge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHN0YXJ0LFxyXG4gICAgICBlbmQsXHJcbiAgICAgIHZlbG9jaXR5LFxyXG4gICAgICBvblVwZGF0ZSxcclxuICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgb25GaW5pc2gsXHJcbiAgICAgIGRhbXBpbmdSYXRpbyxcclxuICAgICAgbmF0dXJhbEZyZXF1ZW5jeVxyXG4gICAgfSA9IHByb3BzO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi9cclxuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDtcclxuXHJcbiAgICBjb25zdCBlYXNlciA9IG5ldyBTcHJpbmdFYXNlcih2ZWxvY2l0eSwgZGFtcGluZ1JhdGlvLCBuYXR1cmFsRnJlcXVlbmN5KTtcclxuICAgIGxldCBwcmV2VGltZSA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgZGVsdGFQb3NpdGlvbiA9IHN0YXJ0IC0gZW5kO1xyXG5cclxuICAgIGNvbnN0IGFuaW1hdGlvbkxvb3AgPSAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9yYWYpIHtcclxuICAgICAgICBkZWx0YVBvc2l0aW9uID0gZWFzZXIuZWFzZUZyYW1lKGRlbHRhUG9zaXRpb24sIERhdGUubm93KCkgLSBwcmV2VGltZSk7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgdGhlIGFuaW1hdGlvbiBpZiB2ZWxvY2l0eSBpcyBsb3cgYW5kIHBvc2l0aW9uIGlzIGNsb3NlIHRvIGVuZFxyXG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVBvc2l0aW9uKSA8IDEgJiYgTWF0aC5hYnMoZWFzZXIudmVsb2NpdHkpIDwgNTApIHtcclxuICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgIG9uVXBkYXRlKGVuZCk7XHJcbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLm9uRmluaXNoKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByZXZUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgIG9uVXBkYXRlKGRlbHRhUG9zaXRpb24gKyBlbmQpO1xyXG4gICAgICAgICAgdGhpcy5fcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uTG9vcCk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXN0cm95IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IG9uRmluaXNoXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICh0aGlzLl9yYWYgPj0gMCkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWYpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcmFmID0gbnVsbDtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtTcHJpbmdBbmltYXRpb24gfCBDU1NBbmltYXRpb259IEFuaW1hdGlvbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvblByb3BzXHJcbiAqXHJcbiAqIEBwcm9wIHtIVE1MRWxlbWVudD19IHRhcmdldFxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gbmFtZVxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyPX0gc3RhcnRcclxuICogQHByb3Age251bWJlcj19IGVuZFxyXG4gKiBAcHJvcCB7bnVtYmVyPX0gZHVyYXRpb25cclxuICogQHByb3Age251bWJlcj19IHZlbG9jaXR5XHJcbiAqIEBwcm9wIHtudW1iZXI9fSBkYW1waW5nUmF0aW9cclxuICogQHByb3Age251bWJlcj19IG5hdHVyYWxGcmVxdWVuY3lcclxuICpcclxuICogQHByb3AgeyhlbmQ6IG51bWJlcikgPT4gdm9pZH0gW29uVXBkYXRlXVxyXG4gKiBAcHJvcCB7KCkgPT4gdm9pZH0gW29uQ29tcGxldGVdXHJcbiAqIEBwcm9wIHsoKSA9PiB2b2lkfSBbb25GaW5pc2hdXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSB0cmFuc2Zvcm1cclxuICogQHByb3Age3N0cmluZz19IG9wYWNpdHlcclxuICogQHByb3Age3N0cmluZz19IGVhc2luZ1xyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGlzUGFuXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gaXNNYWluU2Nyb2xsXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgYW5pbWF0aW9uc1xyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9ucyB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvbltdfSAqL1xyXG4gICAgdGhpcy5hY3RpdmVBbmltYXRpb25zID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0FuaW1hdGlvblByb3BzfSBwcm9wc1xyXG4gICAqL1xyXG4gIHN0YXJ0U3ByaW5nKHByb3BzKSB7XHJcbiAgICB0aGlzLl9zdGFydChwcm9wcywgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0FuaW1hdGlvblByb3BzfSBwcm9wc1xyXG4gICAqL1xyXG4gIHN0YXJ0VHJhbnNpdGlvbihwcm9wcykge1xyXG4gICAgdGhpcy5fc3RhcnQocHJvcHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1NwcmluZ1xyXG4gICAqL1xyXG4gIF9zdGFydChwcm9wcywgaXNTcHJpbmcpIHtcclxuICAgIC8qKiBAdHlwZSB7QW5pbWF0aW9ufSAqL1xyXG4gICAgbGV0IGFuaW1hdGlvbjtcclxuICAgIGlmIChpc1NwcmluZykge1xyXG4gICAgICBhbmltYXRpb24gPSBuZXcgU3ByaW5nQW5pbWF0aW9uKHByb3BzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFuaW1hdGlvbiA9IG5ldyBDU1NBbmltYXRpb24ocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICBhbmltYXRpb24ub25GaW5pc2ggPSAoKSA9PiB0aGlzLnN0b3AoYW5pbWF0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBbmltYXRpb259IGFuaW1hdGlvblxyXG4gICAqL1xyXG4gIHN0b3AoYW5pbWF0aW9uKSB7XHJcbiAgICBhbmltYXRpb24uZGVzdHJveSgpO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgdGhpcy5hY3RpdmVBbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wQWxsKCkgeyAvLyBfc3RvcEFsbEFuaW1hdGlvbnNcclxuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcclxuICAgICAgYW5pbWF0aW9uLmRlc3Ryb3koKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hY3RpdmVBbmltYXRpb25zID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGFsbCBwYW4gb3Igem9vbSB0cmFuc2l0aW9uc1xyXG4gICAqL1xyXG4gIHN0b3BBbGxQYW4oKSB7XHJcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuZmlsdGVyKChhbmltYXRpb24pID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvbi5wcm9wcy5pc1Bhbikge1xyXG4gICAgICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3RvcE1haW5TY3JvbGwoKSB7XHJcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuZmlsdGVyKChhbmltYXRpb24pID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvbi5wcm9wcy5pc01haW5TY3JvbGwpIHtcclxuICAgICAgICBhbmltYXRpb24uZGVzdHJveSgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBtYWluIHNjcm9sbCB0cmFuc2l0aW9uIGlzIHJ1bm5pbmdcclxuICAgKi9cclxuICAvLyBpc01haW5TY3JvbGxSdW5uaW5nKCkge1xyXG4gIC8vICAgcmV0dXJuIHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5zb21lKChhbmltYXRpb24pID0+IHtcclxuICAvLyAgICAgcmV0dXJuIGFuaW1hdGlvbi5wcm9wcy5pc01haW5TY3JvbGw7XHJcbiAgLy8gICB9KTtcclxuICAvLyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgcGFuIG9yIHpvb20gdHJhbnNpdGlvbiBpcyBydW5uaW5nXHJcbiAgICovXHJcbiAgaXNQYW5SdW5uaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5zb21lKChhbmltYXRpb24pID0+IHtcclxuICAgICAgcmV0dXJuIGFuaW1hdGlvbi5wcm9wcy5pc1BhbjtcclxuICAgIH0pO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgc2Nyb2xsIHdoZWVsLlxyXG4gKiBDYW4gcGFuIGFuZCB6b29tIGN1cnJlbnQgc2xpZGUgaW1hZ2UuXHJcbiAqL1xyXG5jbGFzcyBTY3JvbGxXaGVlbCB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHN3cCkge1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuICAgIHBzd3AuZXZlbnRzLmFkZChwc3dwLmVsZW1lbnQsICd3aGVlbCcsIHRoaXMuX29uV2hlZWwuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gZVxyXG4gICAqL1xyXG4gIF9vbldoZWVsKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlIH0gPSB0aGlzLnBzd3A7XHJcbiAgICBsZXQgeyBkZWx0YVgsIGRlbHRhWSB9ID0gZTtcclxuXHJcbiAgICBpZiAoIWN1cnJTbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgnd2hlZWwnLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGUuY3RybEtleSB8fCB0aGlzLnBzd3Aub3B0aW9ucy53aGVlbFRvWm9vbSkge1xyXG4gICAgICAvLyB6b29tXHJcbiAgICAgIGlmIChjdXJyU2xpZGUuaXNab29tYWJsZSgpKSB7XHJcbiAgICAgICAgbGV0IHpvb21GYWN0b3IgPSAtZGVsdGFZO1xyXG4gICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xyXG4gICAgICAgICAgem9vbUZhY3RvciAqPSAwLjA1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB6b29tRmFjdG9yICo9IGUuZGVsdGFNb2RlID8gMSA6IDAuMDAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6b29tRmFjdG9yID0gMiAqKiB6b29tRmFjdG9yO1xyXG5cclxuICAgICAgICBjb25zdCBkZXN0Wm9vbUxldmVsID0gY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgKiB6b29tRmFjdG9yO1xyXG4gICAgICAgIGN1cnJTbGlkZS56b29tVG8oZGVzdFpvb21MZXZlbCwge1xyXG4gICAgICAgICAgeDogZS5jbGllbnRYLFxyXG4gICAgICAgICAgeTogZS5jbGllbnRZXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHBhblxyXG4gICAgICBpZiAoY3VyclNsaWRlLmlzUGFubmFibGUoKSkge1xyXG4gICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xyXG4gICAgICAgICAgLy8gMTggLSBhdmVyYWdlIGxpbmUgaGVpZ2h0XHJcbiAgICAgICAgICBkZWx0YVggKj0gMTg7XHJcbiAgICAgICAgICBkZWx0YVkgKj0gMTg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyU2xpZGUucGFuVG8oXHJcbiAgICAgICAgICBjdXJyU2xpZGUucGFuLnggLSBkZWx0YVgsXHJcbiAgICAgICAgICBjdXJyU2xpZGUucGFuLnkgLSBkZWx0YVlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3R5cGVzLmpzJykuTWV0aG9kczxUPn0gTWV0aG9kczxUPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVSUVsZW1lbnRNYXJrdXBQcm9wc1xyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGlzQ3VzdG9tU1ZHXHJcbiAqIEBwcm9wIHtzdHJpbmd9IGlubmVyXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBvdXRsaW5lSURcclxuICogQHByb3Age251bWJlciB8IHN0cmluZ30gW3NpemVdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVJRWxlbWVudERhdGFcclxuICogQHByb3Age0RlZmF1bHRVSUVsZW1lbnRzIHwgc3RyaW5nfSBbbmFtZV1cclxuICogQHByb3Age3N0cmluZz19IGNsYXNzTmFtZVxyXG4gKiBAcHJvcCB7VUlFbGVtZW50TWFya3VwPX0gaHRtbFxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGlzQnV0dG9uXHJcbiAqIEBwcm9wIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IFt0YWdOYW1lXVxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gdGl0bGVcclxuICogQHByb3Age3N0cmluZz19IGFyaWFMYWJlbFxyXG4gKiBAcHJvcCB7KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwc3dwOiBQaG90b1N3aXBlKSA9PiB2b2lkfSBbb25Jbml0XVxyXG4gKiBAcHJvcCB7TWV0aG9kczxQaG90b1N3aXBlPiB8ICgoZTogTW91c2VFdmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQsIHBzd3A6IFBob3RvU3dpcGUpID0+IHZvaWQpfSBbb25DbGlja11cclxuICogQHByb3AgeydiYXInIHwgJ3dyYXBwZXInIHwgJ3Jvb3QnfSBbYXBwZW5kVG9dXHJcbiAqIEBwcm9wIHtudW1iZXI9fSBvcmRlclxyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7J2Fycm93UHJldicgfCAnYXJyb3dOZXh0JyB8ICdjbG9zZScgfCAnem9vbScgfCAnY291bnRlcid9IERlZmF1bHRVSUVsZW1lbnRzICovXHJcblxyXG4vKiogQHR5cGVkZWYge3N0cmluZyB8IFVJRWxlbWVudE1hcmt1cFByb3BzfSBVSUVsZW1lbnRNYXJrdXAgKi9cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1VJRWxlbWVudE1hcmt1cH0gW2h0bWxEYXRhXVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRWxlbWVudEhUTUwoaHRtbERhdGEpIHtcclxuICBpZiAodHlwZW9mIGh0bWxEYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgLy8gQWxsb3cgZGV2ZWxvcGVycyB0byBwcm92aWRlIGZ1bGwgc3ZnLFxyXG4gICAgLy8gRm9yIGV4YW1wbGU6XHJcbiAgICAvLyA8c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInBzd3BfX2ljblwiPlxyXG4gICAgLy8gICA8cGF0aCBkPVwiLi4uXCIgLz5cclxuICAgIC8vICAgPGNpcmNsZSAuLi4gLz5cclxuICAgIC8vIDwvc3ZnPlxyXG4gICAgLy8gQ2FuIGFsc28gYmUgYW55IEhUTUwgc3RyaW5nLlxyXG4gICAgcmV0dXJuIGh0bWxEYXRhO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFodG1sRGF0YSB8fCAhaHRtbERhdGEuaXNDdXN0b21TVkcpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGNvbnN0IHN2Z0RhdGEgPSBodG1sRGF0YTtcclxuICBsZXQgb3V0ID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJwc3dwX19pY25cIiB2aWV3Qm94PVwiMCAwICVkICVkXCIgd2lkdGg9XCIlZFwiIGhlaWdodD1cIiVkXCI+JztcclxuICAvLyByZXBsYWNlIGFsbCAlZCB3aXRoIHNpemVcclxuICBvdXQgPSBvdXQuc3BsaXQoJyVkJykuam9pbigvKiogQHR5cGUge3N0cmluZ30gKi8gKHN2Z0RhdGEuc2l6ZSB8fCAzMikpO1xyXG5cclxuICAvLyBJY29ucyBtYXkgY29udGFpbiBvdXRsaW5lL3NoYWRvdyxcclxuICAvLyB0byBtYWtlIGl0IHdlIFwiY2xvbmVcIiBiYXNlIGljb24gc2hhcGUgYW5kIGFkZCBib3JkZXIgdG8gaXQuXHJcbiAgLy8gSWNvbiBpdHNlbGYgYW5kIGJvcmRlciBhcmUgc3R5bGVkIHZpYSBDU1MuXHJcbiAgLy9cclxuICAvLyBQcm9wZXJ0eSBzaGFkb3dJRCBkZWZpbmVzIElEIG9mIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgY2xvbmVkLlxyXG4gIGlmIChzdmdEYXRhLm91dGxpbmVJRCkge1xyXG4gICAgb3V0ICs9ICc8dXNlIGNsYXNzPVwicHN3cF9faWNuLXNoYWRvd1wiIHhsaW5rOmhyZWY9XCIjJyArIHN2Z0RhdGEub3V0bGluZUlEICsgJ1wiLz4nO1xyXG4gIH1cclxuXHJcbiAgb3V0ICs9IHN2Z0RhdGEuaW5uZXI7XHJcblxyXG4gIG91dCArPSAnPC9zdmc+JztcclxuXHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuY2xhc3MgVUlFbGVtZW50IHtcclxuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKiBAcGFyYW0ge1VJRWxlbWVudERhdGF9IGRhdGFcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihwc3dwLCBkYXRhKSB7XHJcbiAgICBjb25zdCBuYW1lID0gZGF0YS5uYW1lIHx8IGRhdGEuY2xhc3NOYW1lO1xyXG4gICAgbGV0IGVsZW1lbnRIVE1MID0gZGF0YS5odG1sO1xyXG5cclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XHJcbiAgICBpZiAocHN3cC5vcHRpb25zW25hbWVdID09PSBmYWxzZSkge1xyXG4gICAgICAvLyBleGl0IGlmIGVsZW1lbnQgaXMgZGlzYWJsZWQgZnJvbSBvcHRpb25zXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGxvdyB0byBvdmVycmlkZSBTVkcgaWNvbnMgZnJvbSBvcHRpb25zXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2t1cCBvbmx5IGJ5IGBkYXRhLm5hbWVgIG1heWJlP1xyXG4gICAgaWYgKHR5cGVvZiBwc3dwLm9wdGlvbnNbbmFtZSArICdTVkcnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gYXJyb3dQcmV2U1ZHXHJcbiAgICAgIC8vIGFycm93TmV4dFNWR1xyXG4gICAgICAvLyBjbG9zZVNWR1xyXG4gICAgICAvLyB6b29tU1ZHXHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XHJcbiAgICAgIGVsZW1lbnRIVE1MID0gcHN3cC5vcHRpb25zW25hbWUgKyAnU1ZHJ107XHJcbiAgICB9XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaCgndWlFbGVtZW50Q3JlYXRlJywgeyBkYXRhIH0pO1xyXG5cclxuICAgIGxldCBjbGFzc05hbWUgPSAnJztcclxuICAgIGlmIChkYXRhLmlzQnV0dG9uKSB7XHJcbiAgICAgIGNsYXNzTmFtZSArPSAncHN3cF9fYnV0dG9uICc7XHJcbiAgICAgIGNsYXNzTmFtZSArPSAoZGF0YS5jbGFzc05hbWUgfHwgYHBzd3BfX2J1dHRvbi0tJHtkYXRhLm5hbWV9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjbGFzc05hbWUgKz0gKGRhdGEuY2xhc3NOYW1lIHx8IGBwc3dwX18ke2RhdGEubmFtZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xyXG4gICAgbGV0IGVsZW1lbnQ7XHJcbiAgICBsZXQgdGFnTmFtZSA9IGRhdGEuaXNCdXR0b24gPyAoZGF0YS50YWdOYW1lIHx8ICdidXR0b24nKSA6IChkYXRhLnRhZ05hbWUgfHwgJ2RpdicpO1xyXG4gICAgdGFnTmFtZSA9IC8qKiBAdHlwZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSAqLyAodGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgdGFnTmFtZSk7XHJcblxyXG4gICAgaWYgKGRhdGEuaXNCdXR0b24pIHtcclxuICAgICAgLy8gY3JlYXRlIGJ1dHRvbiBlbGVtZW50XHJcbiAgICAgIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgdGFnTmFtZSk7XHJcbiAgICAgIGlmICh0YWdOYW1lID09PSAnYnV0dG9uJykge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovIChlbGVtZW50KS50eXBlID0gJ2J1dHRvbic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB7IHRpdGxlIH0gPSBkYXRhO1xyXG4gICAgICBjb25zdCB7IGFyaWFMYWJlbCB9ID0gZGF0YTtcclxuXHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XHJcbiAgICAgIGlmICh0eXBlb2YgcHN3cC5vcHRpb25zW25hbWUgKyAnVGl0bGUnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2t1cCBvbmx5IGJ5IGBkYXRhLm5hbWVgIG1heWJlP1xyXG4gICAgICAgIHRpdGxlID0gcHN3cC5vcHRpb25zW25hbWUgKyAnVGl0bGUnXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgICAgZWxlbWVudC50aXRsZSA9IHRpdGxlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXJpYUxhYmVsIHx8IHRpdGxlKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGVsZW1lbnQpLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGFyaWFMYWJlbCB8fCB0aXRsZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IGFkZEVsZW1lbnRIVE1MKGVsZW1lbnRIVE1MKTtcclxuXHJcbiAgICBpZiAoZGF0YS5vbkluaXQpIHtcclxuICAgICAgZGF0YS5vbkluaXQoZWxlbWVudCwgcHN3cCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRhdGEub25DbGljaykge1xyXG4gICAgICBlbGVtZW50Lm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5vbkNsaWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcHN3cFtkYXRhLm9uQ2xpY2tdKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRhdGEub25DbGljayhlLCBlbGVtZW50LCBwc3dwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVG9wIGJhciBpcyBkZWZhdWx0IHBvc2l0aW9uXHJcbiAgICBjb25zdCBhcHBlbmRUbyA9IGRhdGEuYXBwZW5kVG8gfHwgJ2Jhcic7XHJcbiAgICBsZXQgY29udGFpbmVyO1xyXG4gICAgaWYgKGFwcGVuZFRvID09PSAnYmFyJykge1xyXG4gICAgICBpZiAoIXBzd3AudG9wQmFyKSB7XHJcbiAgICAgICAgcHN3cC50b3BCYXIgPSBjcmVhdGVFbGVtZW50KCdwc3dwX190b3AtYmFyIHBzd3BfX2hpZGUtb24tY2xvc2UnLCAnZGl2JywgcHN3cC5zY3JvbGxXcmFwKTtcclxuICAgICAgfVxyXG4gICAgICBjb250YWluZXIgPSBwc3dwLnRvcEJhcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGVsZW1lbnQgb3V0c2lkZSBvZiB0b3AgYmFyIGdldHMgYSBzZWNvbmRhcnkgY2xhc3NcclxuICAgICAgLy8gdGhhdCBtYWtlcyBlbGVtZW50IGZhZGUgb3V0IG9uIGNsb3NlXHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncHN3cF9faGlkZS1vbi1jbG9zZScpO1xyXG5cclxuICAgICAgaWYgKGFwcGVuZFRvID09PSAnd3JhcHBlcicpIHtcclxuICAgICAgICBjb250YWluZXIgPSBwc3dwLnNjcm9sbFdyYXA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gcm9vdCBlbGVtZW50XHJcbiAgICAgICAgY29udGFpbmVyID0gcHN3cC5lbGVtZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBzd3AuYXBwbHlGaWx0ZXJzKCd1aUVsZW1lbnQnLCBlbGVtZW50LCBkYXRhKSk7XHJcbiAgfVxyXG59XG5cbi8qXHJcbiAgQmFja3dhcmQgYW5kIGZvcndhcmQgYXJyb3cgYnV0dG9uc1xyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzTmV4dEJ1dHRvblxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEFycm93QnV0dG9uKGVsZW1lbnQsIHBzd3AsIGlzTmV4dEJ1dHRvbikge1xyXG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncHN3cF9fYnV0dG9uLS1hcnJvdycpO1xyXG4gIC8vIFRPRE86IHRoaXMgc2hvdWxkIHBvaW50IHRvIGEgdW5pcXVlIGlkIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCAncHN3cF9faXRlbXMnKTtcclxuICBwc3dwLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICBpZiAoIXBzd3Aub3B0aW9ucy5sb29wKSB7XHJcbiAgICAgIGlmIChpc05leHRCdXR0b24pIHtcclxuICAgICAgICAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL1xyXG4gICAgICAgIChlbGVtZW50KS5kaXNhYmxlZCA9ICEocHN3cC5jdXJySW5kZXggPCBwc3dwLmdldE51bUl0ZW1zKCkgLSAxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL1xyXG4gICAgICAgIChlbGVtZW50KS5kaXNhYmxlZCA9ICEocHN3cC5jdXJySW5kZXggPiAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKiogQHR5cGUge1VJRWxlbWVudERhdGF9ICovXHJcbmNvbnN0IGFycm93UHJldiA9IHtcclxuICBuYW1lOiAnYXJyb3dQcmV2JyxcclxuICBjbGFzc05hbWU6ICdwc3dwX19idXR0b24tLWFycm93LS1wcmV2JyxcclxuICB0aXRsZTogJ1ByZXZpb3VzJyxcclxuICBvcmRlcjogMTAsXHJcbiAgaXNCdXR0b246IHRydWUsXHJcbiAgYXBwZW5kVG86ICd3cmFwcGVyJyxcclxuICBodG1sOiB7XHJcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcclxuICAgIHNpemU6IDYwLFxyXG4gICAgaW5uZXI6ICc8cGF0aCBkPVwiTTI5IDQzbC0zIDMtMTYtMTYgMTYtMTYgMyAzLTEzIDEzIDEzIDEzelwiIGlkPVwicHN3cF9faWNuLWFycm93XCIvPicsXHJcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tYXJyb3cnXHJcbiAgfSxcclxuICBvbkNsaWNrOiAncHJldicsXHJcbiAgb25Jbml0OiBpbml0QXJyb3dCdXR0b25cclxufTtcclxuXHJcbi8qKiBAdHlwZSB7VUlFbGVtZW50RGF0YX0gKi9cclxuY29uc3QgYXJyb3dOZXh0ID0ge1xyXG4gIG5hbWU6ICdhcnJvd05leHQnLFxyXG4gIGNsYXNzTmFtZTogJ3Bzd3BfX2J1dHRvbi0tYXJyb3ctLW5leHQnLFxyXG4gIHRpdGxlOiAnTmV4dCcsXHJcbiAgb3JkZXI6IDExLFxyXG4gIGlzQnV0dG9uOiB0cnVlLFxyXG4gIGFwcGVuZFRvOiAnd3JhcHBlcicsXHJcbiAgaHRtbDoge1xyXG4gICAgaXNDdXN0b21TVkc6IHRydWUsXHJcbiAgICBzaXplOiA2MCxcclxuICAgIGlubmVyOiAnPHVzZSB4bGluazpocmVmPVwiI3Bzd3BfX2ljbi1hcnJvd1wiLz4nLFxyXG4gICAgb3V0bGluZUlEOiAncHN3cF9faWNuLWFycm93J1xyXG4gIH0sXHJcbiAgb25DbGljazogJ25leHQnLFxyXG4gIG9uSW5pdDogKGVsLCBwc3dwKSA9PiB7XHJcbiAgICBpbml0QXJyb3dCdXR0b24oZWwsIHBzd3AsIHRydWUpO1xyXG4gIH1cclxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdWktZWxlbWVudC5qcycpLlVJRWxlbWVudERhdGF9IFVJRWxlbWVudERhdGEgKi9cclxuY29uc3QgY2xvc2VCdXR0b24gPSB7XHJcbiAgbmFtZTogJ2Nsb3NlJyxcclxuICB0aXRsZTogJ0Nsb3NlJyxcclxuICBvcmRlcjogMjAsXHJcbiAgaXNCdXR0b246IHRydWUsXHJcbiAgaHRtbDoge1xyXG4gICAgaXNDdXN0b21TVkc6IHRydWUsXHJcbiAgICBpbm5lcjogJzxwYXRoIGQ9XCJNMjQgMTBsLTItMi02IDYtNi02LTIgMiA2IDYtNiA2IDIgMiA2LTYgNiA2IDItMi02LTZ6XCIgaWQ9XCJwc3dwX19pY24tY2xvc2VcIi8+JyxcclxuICAgIG91dGxpbmVJRDogJ3Bzd3BfX2ljbi1jbG9zZSdcclxuICB9LFxyXG4gIG9uQ2xpY2s6ICdjbG9zZSdcclxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdWktZWxlbWVudC5qcycpLlVJRWxlbWVudERhdGF9IFVJRWxlbWVudERhdGEgKi9cclxuY29uc3Qgem9vbUJ1dHRvbiA9IHtcclxuICBuYW1lOiAnem9vbScsXHJcbiAgdGl0bGU6ICdab29tJyxcclxuICBvcmRlcjogMTAsXHJcbiAgaXNCdXR0b246IHRydWUsXHJcbiAgaHRtbDoge1xyXG4gICAgaXNDdXN0b21TVkc6IHRydWUsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxyXG4gICAgaW5uZXI6ICc8cGF0aCBkPVwiTTE3LjQyNiAxOS45MjZhNiA2IDAgMSAxIDEuNS0xLjVMMjMgMjIuNSAyMS41IDI0bC00LjA3NC00LjA3NHpcIiBpZD1cInBzd3BfX2ljbi16b29tXCIvPidcclxuICAgICAgICAgICsgJzxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInBzd3BfX3pvb20taWNuLWJhci1oXCIgZD1cIk0xMSAxNnYtMmg2djJ6XCIvPidcclxuICAgICAgICAgICsgJzxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInBzd3BfX3pvb20taWNuLWJhci12XCIgZD1cIk0xMyAxMmgydjZoLTJ6XCIvPicsXHJcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tem9vbSdcclxuICB9LFxyXG4gIG9uQ2xpY2s6ICd0b2dnbGVab29tJ1xyXG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xyXG5jb25zdCBsb2FkaW5nSW5kaWNhdG9yID0ge1xyXG4gIG5hbWU6ICdwcmVsb2FkZXInLFxyXG4gIGFwcGVuZFRvOiAnYmFyJyxcclxuICBvcmRlcjogNyxcclxuICBodG1sOiB7XHJcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICBpbm5lcjogJzxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0yMS4yIDE2YTUuMiA1LjIgMCAxIDEtNS4yLTUuMlY4YTggOCAwIDEgMCA4IDhoLTIuOFpcIiBpZD1cInBzd3BfX2ljbi1sb2FkaW5nXCIvPicsXHJcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tbG9hZGluZydcclxuICB9LFxyXG4gIG9uSW5pdDogKGluZGljYXRvckVsZW1lbnQsIHBzd3ApID0+IHtcclxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cclxuICAgIGxldCBpc1Zpc2libGU7XHJcbiAgICAvKiogQHR5cGUge05vZGVKUy5UaW1lb3V0fSAqL1xyXG4gICAgbGV0IGRlbGF5VGltZW91dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHRvZ2dsZUluZGljYXRvckNsYXNzID0gKGNsYXNzTmFtZSwgYWRkKSA9PiB7XHJcbiAgICAgIGluZGljYXRvckVsZW1lbnQuY2xhc3NMaXN0W2FkZCA/ICdhZGQnIDogJ3JlbW92ZSddKCdwc3dwX19wcmVsb2FkZXItLScgKyBjbGFzc05hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzZXRJbmRpY2F0b3JWaXNpYmlsaXR5ID0gKHZpc2libGUpID0+IHtcclxuICAgICAgaWYgKGlzVmlzaWJsZSAhPT0gdmlzaWJsZSkge1xyXG4gICAgICAgIGlzVmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgdG9nZ2xlSW5kaWNhdG9yQ2xhc3MoJ2FjdGl2ZScsIHZpc2libGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZVByZWxvYWRlclZpc2liaWxpdHkgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghcHN3cC5jdXJyU2xpZGUuY29udGVudC5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgIHNldEluZGljYXRvclZpc2liaWxpdHkoZmFsc2UpO1xyXG4gICAgICAgIGlmIChkZWxheVRpbWVvdXQpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChkZWxheVRpbWVvdXQpO1xyXG4gICAgICAgICAgZGVsYXlUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWRlbGF5VGltZW91dCkge1xyXG4gICAgICAgIC8vIGRpc3BsYXkgbG9hZGluZyBpbmRpY2F0b3Igd2l0aCBkZWxheVxyXG4gICAgICAgIGRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgc2V0SW5kaWNhdG9yVmlzaWJpbGl0eShwc3dwLmN1cnJTbGlkZS5jb250ZW50LmlzTG9hZGluZygpKTtcclxuICAgICAgICAgIGRlbGF5VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfSwgcHN3cC5vcHRpb25zLnByZWxvYWRlckRlbGF5KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwc3dwLm9uKCdjaGFuZ2UnLCB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KTtcclxuXHJcbiAgICBwc3dwLm9uKCdsb2FkQ29tcGxldGUnLCAoZSkgPT4ge1xyXG4gICAgICBpZiAocHN3cC5jdXJyU2xpZGUgPT09IGUuc2xpZGUpIHtcclxuICAgICAgICB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGV4cG9zZSB0aGUgbWV0aG9kXHJcbiAgICBwc3dwLnVpLnVwZGF0ZVByZWxvYWRlclZpc2liaWxpdHkgPSB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5O1xyXG4gIH1cclxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdWktZWxlbWVudC5qcycpLlVJRWxlbWVudERhdGF9IFVJRWxlbWVudERhdGEgKi9cclxuY29uc3QgY291bnRlckluZGljYXRvciA9IHtcclxuICBuYW1lOiAnY291bnRlcicsXHJcbiAgb3JkZXI6IDUsXHJcbiAgb25Jbml0OiAoY291bnRlckVsZW1lbnQsIHBzd3ApID0+IHtcclxuICAgIHBzd3Aub24oJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgY291bnRlckVsZW1lbnQuaW5uZXJUZXh0ID0gKHBzd3AuY3VyckluZGV4ICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgcHN3cC5vcHRpb25zLmluZGV4SW5kaWNhdG9yU2VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHBzd3AuZ2V0TnVtSXRlbXMoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcblxyXG4vKipcclxuICogU2V0IHNwZWNpYWwgY2xhc3Mgb24gZWxlbWVudCB3aGVuIGltYWdlIGlzIHpvb21lZC5cclxuICpcclxuICogQnkgZGVmYXVsdCBpdCBpcyB1c2VkIHRvIGFkanVzdFxyXG4gKiB6b29tIGljb24gYW5kIHpvb20gY3Vyc29yIHZpYSBDU1MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNab29tZWRJblxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Wm9vbWVkSW4oZWwsIGlzWm9vbWVkSW4pIHtcclxuICBlbC5jbGFzc0xpc3RbaXNab29tZWRJbiA/ICdhZGQnIDogJ3JlbW92ZSddKCdwc3dwLS16b29tZWQtaW4nKTtcclxufVxyXG5cclxuY2xhc3MgVUkge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcblxyXG4gICAgLyoqIEB0eXBlIHsoKSA9PiB2b2lkfSAqL1xyXG4gICAgdGhpcy51cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5fbGFzdFVwZGF0ZWRab29tTGV2ZWwgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBpbml0KCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuICAgIC8qKiBAdHlwZSB7VUlFbGVtZW50RGF0YVtdfSAqL1xyXG4gICAgdGhpcy51aUVsZW1lbnRzRGF0YSA9IFtcclxuICAgICAgY2xvc2VCdXR0b24sXHJcbiAgICAgIGFycm93UHJldixcclxuICAgICAgYXJyb3dOZXh0LFxyXG4gICAgICB6b29tQnV0dG9uLFxyXG4gICAgICBsb2FkaW5nSW5kaWNhdG9yLFxyXG4gICAgICBjb3VudGVySW5kaWNhdG9yXHJcbiAgICBdO1xyXG5cclxuICAgIHBzd3AuZGlzcGF0Y2goJ3VpUmVnaXN0ZXInKTtcclxuXHJcbiAgICAvLyBzb3J0IGJ5IG9yZGVyXHJcbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgLy8gZGVmYXVsdCBvcmRlciBpcyAwXHJcbiAgICAgIHJldHVybiAoYS5vcmRlciB8fCAwKSAtIChiLm9yZGVyIHx8IDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHsoVUlFbGVtZW50IHwgVUlFbGVtZW50RGF0YSlbXX0gKi9cclxuICAgIHRoaXMuaXRlbXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhLmZvckVhY2goKHVpRWxlbWVudERhdGEpID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3RlckVsZW1lbnQodWlFbGVtZW50RGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBwc3dwLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgIHBzd3AuZWxlbWVudC5jbGFzc0xpc3RbcHN3cC5nZXROdW1JdGVtcygpID09PSAxID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ3Bzd3AtLW9uZS1zbGlkZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcHN3cC5vbignem9vbVBhblVwZGF0ZScsICgpID0+IHRoaXMuX29uWm9vbVBhblVwZGF0ZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7VUlFbGVtZW50RGF0YX0gZWxlbWVudERhdGFcclxuICAgKi9cclxuICByZWdpc3RlckVsZW1lbnQoZWxlbWVudERhdGEpIHtcclxuICAgIGlmICh0aGlzLmlzUmVnaXN0ZXJlZCkge1xyXG4gICAgICB0aGlzLml0ZW1zLnB1c2goXHJcbiAgICAgICAgbmV3IFVJRWxlbWVudCh0aGlzLnBzd3AsIGVsZW1lbnREYXRhKVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy51aUVsZW1lbnRzRGF0YS5wdXNoKGVsZW1lbnREYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVkIGVhY2ggdGltZSB6b29tIG9yIHBhbiBwb3NpdGlvbiBpcyBjaGFuZ2VkLlxyXG4gICAqIFVwZGF0ZSBjbGFzc2VzIHRoYXQgY29udHJvbCB2aXNpYmlsaXR5IG9mIHpvb20gYnV0dG9uIGFuZCBjdXJzb3IgaWNvbi5cclxuICAgKi9cclxuICBfb25ab29tUGFuVXBkYXRlKCkge1xyXG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgY3VyclNsaWRlLCBvcHRpb25zIH0gPSB0aGlzLnBzd3A7XHJcbiAgICBsZXQgeyBjdXJyWm9vbUxldmVsIH0gPSBjdXJyU2xpZGU7XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cC5vcGVuZXIuaXNDbG9zaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBub3Qgb3BlbiB5ZXQgLSBjaGVjayBhZ2FpbnN0IGluaXRpYWwgem9vbSBsZXZlbFxyXG4gICAgaWYgKCF0aGlzLnBzd3Aub3BlbmVyLmlzT3Blbikge1xyXG4gICAgICBjdXJyWm9vbUxldmVsID0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3Vyclpvb21MZXZlbCA9PT0gdGhpcy5fbGFzdFVwZGF0ZWRab29tTGV2ZWwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGFzdFVwZGF0ZWRab29tTGV2ZWwgPSBjdXJyWm9vbUxldmVsO1xyXG5cclxuICAgIGNvbnN0IGN1cnJab29tTGV2ZWxEaWZmID0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCAtIGN1cnJTbGlkZS56b29tTGV2ZWxzLnNlY29uZGFyeTtcclxuXHJcbiAgICAvLyBJbml0aWFsIGFuZCBzZWNvbmRhcnkgem9vbSBsZXZlbHMgYXJlIGFsbW9zdCBlcXVhbFxyXG4gICAgaWYgKE1hdGguYWJzKGN1cnJab29tTGV2ZWxEaWZmKSA8IDAuMDEgfHwgIWN1cnJTbGlkZS5pc1pvb21hYmxlKCkpIHtcclxuICAgICAgLy8gZGlzYWJsZSB6b29tXHJcbiAgICAgIHNldFpvb21lZEluKHRlbXBsYXRlLCBmYWxzZSk7XHJcbiAgICAgIHRlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHN3cC0tem9vbS1hbGxvd2VkJyk7XHJcblxyXG4gICAgY29uc3QgcG90ZW50aWFsWm9vbUxldmVsID0gY3Vyclpvb21MZXZlbCA9PT0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbFxyXG4gICAgICA/IGN1cnJTbGlkZS56b29tTGV2ZWxzLnNlY29uZGFyeSA6IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWw7XHJcblxyXG4gICAgc2V0Wm9vbWVkSW4odGVtcGxhdGUsIHBvdGVudGlhbFpvb21MZXZlbCA8PSBjdXJyWm9vbUxldmVsKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pbWFnZUNsaWNrQWN0aW9uID09PSAnem9vbSdcclxuICAgICAgICB8fCBvcHRpb25zLmltYWdlQ2xpY2tBY3Rpb24gPT09ICd6b29tLW9yLWNsb3NlJykge1xyXG4gICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKCdwc3dwLS1jbGljay10by16b29tJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlLmpzJykuU2xpZGVEYXRhfSBTbGlkZURhdGEgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXHJcblxyXG4vKiogQHR5cGVkZWYge3sgeDogbnVtYmVyOyB5OiBudW1iZXI7IHc6IG51bWJlcjsgaW5uZXJSZWN0PzogeyB3OiBudW1iZXI7IGg6IG51bWJlcjsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB9fSBCb3VuZHMgKi9cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm91bmRzQnlFbGVtZW50KGVsKSB7XHJcbiAgY29uc3QgdGh1bWJBcmVhUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiB0aHVtYkFyZWFSZWN0LmxlZnQsXHJcbiAgICB5OiB0aHVtYkFyZWFSZWN0LnRvcCxcclxuICAgIHc6IHRodW1iQXJlYVJlY3Qud2lkdGhcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHBhcmFtIHtudW1iZXJ9IGltYWdlV2lkdGhcclxuICogQHBhcmFtIHtudW1iZXJ9IGltYWdlSGVpZ2h0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDcm9wcGVkQm91bmRzQnlFbGVtZW50KGVsLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCkge1xyXG4gIGNvbnN0IHRodW1iQXJlYVJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgLy8gZmlsbCBpbWFnZSBpbnRvIHRoZSBhcmVhXHJcbiAgLy8gKGRvIHRoZXkgc2FtZSBhcyBvYmplY3QtZml0OmNvdmVyIGRvZXMgdG8gcmV0cmlldmUgY29vcmRpbmF0ZXMpXHJcbiAgY29uc3QgaFJhdGlvID0gdGh1bWJBcmVhUmVjdC53aWR0aCAvIGltYWdlV2lkdGg7XHJcbiAgY29uc3QgdlJhdGlvID0gdGh1bWJBcmVhUmVjdC5oZWlnaHQgLyBpbWFnZUhlaWdodDtcclxuICBjb25zdCBmaWxsWm9vbUxldmVsID0gaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvO1xyXG5cclxuICBjb25zdCBvZmZzZXRYID0gKHRodW1iQXJlYVJlY3Qud2lkdGggLSBpbWFnZVdpZHRoICogZmlsbFpvb21MZXZlbCkgLyAyO1xyXG4gIGNvbnN0IG9mZnNldFkgPSAodGh1bWJBcmVhUmVjdC5oZWlnaHQgLSBpbWFnZUhlaWdodCAqIGZpbGxab29tTGV2ZWwpIC8gMjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlLFxyXG4gICAqIGFzIGlmIGl0IHdhcyBub3QgY3JvcHBlZCxcclxuICAgKiBoZWlnaHQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5XHJcbiAgICpcclxuICAgKiBAdHlwZSB7Qm91bmRzfVxyXG4gICAqL1xyXG4gIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgIHg6IHRodW1iQXJlYVJlY3QubGVmdCArIG9mZnNldFgsXHJcbiAgICB5OiB0aHVtYkFyZWFSZWN0LnRvcCArIG9mZnNldFksXHJcbiAgICB3OiBpbWFnZVdpZHRoICogZmlsbFpvb21MZXZlbFxyXG4gIH07XHJcblxyXG4gIC8vIENvb3JkaW5hdGVzIG9mIGlubmVyIGNyb3AgYXJlYVxyXG4gIC8vIHJlbGF0aXZlIHRvIHRoZSBpbWFnZVxyXG4gIGJvdW5kcy5pbm5lclJlY3QgPSB7XHJcbiAgICB3OiB0aHVtYkFyZWFSZWN0LndpZHRoLFxyXG4gICAgaDogdGh1bWJBcmVhUmVjdC5oZWlnaHQsXHJcbiAgICB4OiBvZmZzZXRYLFxyXG4gICAgeTogb2Zmc2V0WVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBib3VuZHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGltZW5zaW9ucyBvZiB0aHVtYm5haWwgaW1hZ2VcclxuICogKGNsaWNrIG9uIHdoaWNoIG9wZW5zIHBob3Rvc3dpcGUgb3IgY2xvc2VzIHBob3Rvc3dpcGUgdG8pXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGFcclxuICogQHBhcmFtIHtQaG90b1N3aXBlfSBpbnN0YW5jZSBQaG90b1N3aXBlIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtCb3VuZHMgfCB1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUaHVtYkJvdW5kcyhpbmRleCwgaXRlbURhdGEsIGluc3RhbmNlKSB7XHJcbiAgLy8gbGVnYWN5IGV2ZW50LCBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICBjb25zdCBldmVudCA9IGluc3RhbmNlLmRpc3BhdGNoKCd0aHVtYkJvdW5kcycsIHtcclxuICAgIGluZGV4LFxyXG4gICAgaXRlbURhdGEsXHJcbiAgICBpbnN0YW5jZVxyXG4gIH0pO1xyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICBpZiAoZXZlbnQudGh1bWJCb3VuZHMpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHJldHVybiBldmVudC50aHVtYkJvdW5kcztcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZWxlbWVudCB9ID0gaXRlbURhdGE7XHJcbiAgbGV0IHRodW1iQm91bmRzO1xyXG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXHJcbiAgbGV0IHRodW1ibmFpbDtcclxuXHJcbiAgaWYgKGVsZW1lbnQgJiYgaW5zdGFuY2Uub3B0aW9ucy50aHVtYlNlbGVjdG9yICE9PSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGh1bWJTZWxlY3RvciA9IGluc3RhbmNlLm9wdGlvbnMudGh1bWJTZWxlY3RvciB8fCAnaW1nJztcclxuICAgIHRodW1ibmFpbCA9IGVsZW1lbnQubWF0Y2hlcyh0aHVtYlNlbGVjdG9yKVxyXG4gICAgICA/IGVsZW1lbnQgOiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGh1bWJTZWxlY3Rvcik7XHJcbiAgfVxyXG5cclxuICB0aHVtYm5haWwgPSBpbnN0YW5jZS5hcHBseUZpbHRlcnMoJ3RodW1iRWwnLCB0aHVtYm5haWwsIGl0ZW1EYXRhLCBpbmRleCk7XHJcblxyXG4gIGlmICh0aHVtYm5haWwpIHtcclxuICAgIGlmICghaXRlbURhdGEudGh1bWJDcm9wcGVkKSB7XHJcbiAgICAgIHRodW1iQm91bmRzID0gZ2V0Qm91bmRzQnlFbGVtZW50KHRodW1ibmFpbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHVtYkJvdW5kcyA9IGdldENyb3BwZWRCb3VuZHNCeUVsZW1lbnQoXHJcbiAgICAgICAgdGh1bWJuYWlsLFxyXG4gICAgICAgIGl0ZW1EYXRhLndpZHRoIHx8IGl0ZW1EYXRhLncsXHJcbiAgICAgICAgaXRlbURhdGEuaGVpZ2h0IHx8IGl0ZW1EYXRhLmhcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBpbnN0YW5jZS5hcHBseUZpbHRlcnMoJ3RodW1iQm91bmRzJywgdGh1bWJCb3VuZHMsIGl0ZW1EYXRhLCBpbmRleCk7XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2xpZ2h0Ym94L2xpZ2h0Ym94LmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZUxpZ2h0Ym94ICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBob3RvU3dpcGVPcHRpb25zfSBQaG90b1N3aXBlT3B0aW9ucyAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLkRhdGFTb3VyY2V9IERhdGFTb3VyY2UgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3VpL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9jb250ZW50LmpzJykuZGVmYXVsdH0gQ29udGVudERlZmF1bHQgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL3NsaWRlLmpzJykuZGVmYXVsdH0gU2xpZGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL3NsaWRlLmpzJykuU2xpZGVEYXRhfSBTbGlkZURhdGEgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL3pvb20tbGV2ZWwuanMnKS5kZWZhdWx0fSBab29tTGV2ZWwgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NsaWRlL2dldC10aHVtYi1ib3VuZHMuanMnKS5Cb3VuZHN9IEJvdW5kcyAqL1xyXG5cclxuLyoqXHJcbiAqIEFsbG93IGFkZGluZyBhbiBhcmJpdHJhcnkgcHJvcHMgdG8gdGhlIENvbnRlbnRcclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9jdXN0b20tY29udGVudC8jdXNpbmctd2VicC1pbWFnZS1mb3JtYXRcclxuICogQHR5cGVkZWYge0NvbnRlbnREZWZhdWx0ICYgUmVjb3JkPHN0cmluZywgYW55Pn0gQ29udGVudFxyXG4gKi9cclxuLyoqIEB0eXBlZGVmIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gUG9pbnQgKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQaG90b1N3aXBlRXZlbnRzTWFwIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzL1xyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2FkZGluZy11aS1lbGVtZW50cy9cclxuICpcclxuICogQHByb3Age3VuZGVmaW5lZH0gdWlSZWdpc3RlclxyXG4gKiBAcHJvcCB7eyBkYXRhOiBVSUVsZW1lbnREYXRhIH19IHVpRWxlbWVudENyZWF0ZVxyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2V2ZW50cy8jaW5pdGlhbGl6YXRpb24tZXZlbnRzXHJcbiAqXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGJlZm9yZU9wZW5cclxuICogQHByb3Age3VuZGVmaW5lZH0gZmlyc3RVcGRhdGVcclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbExheW91dFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjaGFuZ2VcclxuICogQHByb3Age3VuZGVmaW5lZH0gYWZ0ZXJJbml0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGJpbmRFdmVudHNcclxuICpcclxuICpcclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9ldmVudHMvI29wZW5pbmctb3ItY2xvc2luZy10cmFuc2l0aW9uLWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBvcGVuaW5nQW5pbWF0aW9uU3RhcnRcclxuICogQHByb3Age3VuZGVmaW5lZH0gb3BlbmluZ0FuaW1hdGlvbkVuZFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjbG9zaW5nQW5pbWF0aW9uU3RhcnRcclxuICogQHByb3Age3VuZGVmaW5lZH0gY2xvc2luZ0FuaW1hdGlvbkVuZFxyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2V2ZW50cy8jY2xvc2luZy1ldmVudHNcclxuICpcclxuICogQHByb3Age3VuZGVmaW5lZH0gY2xvc2VcclxuICogQHByb3Age3VuZGVmaW5lZH0gZGVzdHJveVxyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2V2ZW50cy8jcG9pbnRlci1hbmQtZ2VzdHVyZS1ldmVudHNcclxuICpcclxuICogQHByb3Age3sgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IHBvaW50ZXJEb3duXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB9fSBwb2ludGVyTW92ZVxyXG4gKiBAcHJvcCB7eyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gcG9pbnRlclVwXHJcbiAqIEBwcm9wIHt7IGJnT3BhY2l0eTogbnVtYmVyIH19IHBpbmNoQ2xvc2UgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHBhblk6IG51bWJlciB9fSB2ZXJ0aWNhbERyYWcgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNzbGlkZS1jb250ZW50LWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnRJbml0XHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQ7IGlzTGF6eTogYm9vbGVhbiB9fSBjb250ZW50TG9hZCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgaXNMYXp5OiBib29sZWFuIH19IGNvbnRlbnRMb2FkSW1hZ2UgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQ7IHNsaWRlOiBTbGlkZTsgaXNFcnJvcj86IGJvb2xlYW4gfX0gbG9hZENvbXBsZXRlXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQ7IHNsaWRlOiBTbGlkZSB9fSBsb2FkRXJyb3JcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfX0gY29udGVudFJlc2l6ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXI7IHNsaWRlOiBTbGlkZSB9fSBpbWFnZVNpemVDaGFuZ2VcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50TGF6eUxvYWQgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudEFwcGVuZCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50QWN0aXZhdGUgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudERlYWN0aXZhdGUgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudFJlbW92ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50RGVzdHJveSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICpcclxuICpcclxuICogdW5kb2N1bWVudGVkXHJcbiAqXHJcbiAqIEBwcm9wIHt7IHBvaW50OiBQb2ludDsgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IGltYWdlQ2xpY2tBY3Rpb24gY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHBvaW50OiBQb2ludDsgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IGJnQ2xpY2tBY3Rpb24gY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHBvaW50OiBQb2ludDsgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IHRhcEFjdGlvbiBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gZG91YmxlVGFwQWN0aW9uIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKlxyXG4gKiBAcHJvcCB7eyBvcmlnaW5hbEV2ZW50OiBLZXlib2FyZEV2ZW50IH19IGtleWRvd24gY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHg6IG51bWJlcjsgZHJhZ2dpbmc6IGJvb2xlYW4gfX0gbW92ZU1haW5TY3JvbGxcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGZpcnN0Wm9vbVBhblxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUsIGRhdGE6IFNsaWRlRGF0YSwgaW5kZXg6IG51bWJlciB9fSBnZXR0aW5nRGF0YVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBiZWZvcmVSZXNpemVcclxuICogQHByb3Age3VuZGVmaW5lZH0gcmVzaXplXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IHZpZXdwb3J0U2l6ZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSB1cGRhdGVTY3JvbGxPZmZzZXRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlSW5pdFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gYWZ0ZXJTZXRDb250ZW50XHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBzbGlkZUxvYWRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGFwcGVuZEhlYXZ5IGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gYXBwZW5kSGVhdnlDb250ZW50XHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBzbGlkZUFjdGl2YXRlXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBzbGlkZURlYWN0aXZhdGVcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlRGVzdHJveVxyXG4gKiBAcHJvcCB7eyBkZXN0Wm9vbUxldmVsOiBudW1iZXIsIGNlbnRlclBvaW50OiBQb2ludCwgdHJhbnNpdGlvbkR1cmF0aW9uOiBudW1iZXIgfCBmYWxzZSB9fSBiZWZvcmVab29tVG9cclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHpvb21QYW5VcGRhdGVcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGluaXRpYWxab29tUGFuXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBjYWxjU2xpZGVTaXplXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IHJlc29sdXRpb25DaGFuZ2VkXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IFdoZWVsRXZlbnQgfX0gd2hlZWwgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudEFwcGVuZEltYWdlIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBpbmRleDogbnVtYmVyOyBpdGVtRGF0YTogU2xpZGVEYXRhIH19IGxhenlMb2FkU2xpZGUgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGxhenlMb2FkXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBjYWxjQm91bmRzXHJcbiAqIEBwcm9wIHt7IHpvb21MZXZlbHM6IFpvb21MZXZlbCwgc2xpZGVEYXRhOiBTbGlkZURhdGEgfX0gem9vbUxldmVsc1VwZGF0ZVxyXG4gKlxyXG4gKlxyXG4gKiBsZWdhY3lcclxuICpcclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0aWFsWm9vbUluXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGluaXRpYWxab29tT3V0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGluaXRpYWxab29tSW5FbmRcclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbFpvb21PdXRFbmRcclxuICogQHByb3Age3sgZGF0YVNvdXJjZTogRGF0YVNvdXJjZSwgbnVtSXRlbXM6IG51bWJlciB9fSBudW1JdGVtc1xyXG4gKiBAcHJvcCB7eyBpdGVtRGF0YTogU2xpZGVEYXRhOyBpbmRleDogbnVtYmVyIH19IGl0ZW1EYXRhXHJcbiAqIEBwcm9wIHt7IGluZGV4OiBudW1iZXIsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluc3RhbmNlOiBQaG90b1N3aXBlIH19IHRodW1iQm91bmRzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBob3RvU3dpcGVGaWx0ZXJzTWFwIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy9cclxuICpcclxuICogQHByb3AgeyhudW1JdGVtczogbnVtYmVyLCBkYXRhU291cmNlOiBEYXRhU291cmNlKSA9PiBudW1iZXJ9IG51bUl0ZW1zXHJcbiAqIE1vZGlmeSB0aGUgdG90YWwgYW1vdW50IG9mIHNsaWRlcy4gRXhhbXBsZSBvbiBEYXRhIHNvdXJjZXMgcGFnZS5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNudW1pdGVtc1xyXG4gKlxyXG4gKiBAcHJvcCB7KGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IFNsaWRlRGF0YX0gaXRlbURhdGFcclxuICogTW9kaWZ5IHNsaWRlIGl0ZW0gZGF0YS4gRXhhbXBsZSBvbiBEYXRhIHNvdXJjZXMgcGFnZS5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNpdGVtZGF0YVxyXG4gKlxyXG4gKiBAcHJvcCB7KGl0ZW1EYXRhOiBTbGlkZURhdGEsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBsaW5rRWw6IEhUTUxBbmNob3JFbGVtZW50KSA9PiBTbGlkZURhdGF9IGRvbUl0ZW1EYXRhXHJcbiAqIE1vZGlmeSBpdGVtIGRhdGEgd2hlbiBpdCdzIHBhcnNlZCBmcm9tIERPTSBlbGVtZW50LiBFeGFtcGxlIG9uIERhdGEgc291cmNlcyBwYWdlLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2RvbWl0ZW1kYXRhXHJcbiAqXHJcbiAqIEBwcm9wIHsoY2xpY2tlZEluZGV4OiBudW1iZXIsIGU6IE1vdXNlRXZlbnQsIGluc3RhbmNlOiBQaG90b1N3aXBlTGlnaHRib3gpID0+IG51bWJlcn0gY2xpY2tlZEluZGV4XHJcbiAqIE1vZGlmeSBjbGlja2VkIGdhbGxlcnkgaXRlbSBpbmRleC5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNjbGlja2VkaW5kZXhcclxuICpcclxuICogQHByb3AgeyhwbGFjZWhvbGRlclNyYzogc3RyaW5nIHwgZmFsc2UsIGNvbnRlbnQ6IENvbnRlbnQpID0+IHN0cmluZyB8IGZhbHNlfSBwbGFjZWhvbGRlclNyY1xyXG4gKiBNb2RpZnkgcGxhY2Vob2xkZXIgaW1hZ2Ugc291cmNlLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI3BsYWNlaG9sZGVyc3JjXHJcbiAqXHJcbiAqIEBwcm9wIHsoaXNDb250ZW50TG9hZGluZzogYm9vbGVhbiwgY29udGVudDogQ29udGVudCkgPT4gYm9vbGVhbn0gaXNDb250ZW50TG9hZGluZ1xyXG4gKiBNb2RpZnkgaWYgdGhlIGNvbnRlbnQgaXMgY3VycmVudGx5IGxvYWRpbmcuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jaXNjb250ZW50bG9hZGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7KGlzQ29udGVudFpvb21hYmxlOiBib29sZWFuLCBjb250ZW50OiBDb250ZW50KSA9PiBib29sZWFufSBpc0NvbnRlbnRab29tYWJsZVxyXG4gKiBNb2RpZnkgaWYgdGhlIGNvbnRlbnQgY2FuIGJlIHpvb21lZC5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNpc2NvbnRlbnR6b29tYWJsZVxyXG4gKlxyXG4gKiBAcHJvcCB7KHVzZUNvbnRlbnRQbGFjZWhvbGRlcjogYm9vbGVhbiwgY29udGVudDogQ29udGVudCkgPT4gYm9vbGVhbn0gdXNlQ29udGVudFBsYWNlaG9sZGVyXHJcbiAqIE1vZGlmeSBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBjb250ZW50LlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI3VzZWNvbnRlbnRwbGFjZWhvbGRlclxyXG4gKlxyXG4gKiBAcHJvcCB7KGlzS2VlcGluZ1BsYWNlaG9sZGVyOiBib29sZWFuLCBjb250ZW50OiBDb250ZW50KSA9PiBib29sZWFufSBpc0tlZXBpbmdQbGFjZWhvbGRlclxyXG4gKiBNb2RpZnkgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBrZXB0IGFmdGVyIHRoZSBjb250ZW50IGlzIGxvYWRlZC5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNpc2tlZXBpbmdwbGFjZWhvbGRlclxyXG4gKlxyXG4gKlxyXG4gKiBAcHJvcCB7KGNvbnRlbnRFcnJvckVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250ZW50OiBDb250ZW50KSA9PiBIVE1MRWxlbWVudH0gY29udGVudEVycm9yRWxlbWVudFxyXG4gKiBNb2RpZnkgYW4gZWxlbWVudCB3aGVuIHRoZSBjb250ZW50IGhhcyBlcnJvciBzdGF0ZSAoZm9yIGV4YW1wbGUsIGlmIGltYWdlIGNhbm5vdCBiZSBsb2FkZWQpLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2NvbnRlbnRlcnJvcmVsZW1lbnRcclxuICpcclxuICogQHByb3AgeyhlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YTogVUlFbGVtZW50RGF0YSkgPT4gSFRNTEVsZW1lbnR9IHVpRWxlbWVudFxyXG4gKiBNb2RpZnkgYSBVSSBlbGVtZW50IHRoYXQncyBiZWluZyBjcmVhdGVkLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI3VpZWxlbWVudFxyXG4gKlxyXG4gKiBAcHJvcCB7KHRodW1ibmFpbDogSFRNTEVsZW1lbnQsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IEhUTUxFbGVtZW50fSB0aHVtYkVsXHJcbiAqIE1vZGlmeSB0aGUgdGh1Ym1uYWlsIGVsZW1lbnQgZnJvbSB3aGljaCBvcGVuaW5nIHpvb20gYW5pbWF0aW9uIHN0YXJ0cyBvciBlbmRzLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI3RodW1iZWxcclxuICpcclxuICogQHByb3Ageyh0aHVtYkJvdW5kczogQm91bmRzLCBpdGVtRGF0YTogU2xpZGVEYXRhLCBpbmRleDogbnVtYmVyKSA9PiBCb3VuZHN9IHRodW1iQm91bmRzXHJcbiAqIE1vZGlmeSB0aGUgdGh1Ym1uYWlsIGJvdW5kcyBmcm9tIHdoaWNoIG9wZW5pbmcgem9vbSBhbmltYXRpb24gc3RhcnRzIG9yIGVuZHMuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jdGh1bWJib3VuZHNcclxuICpcclxuICogQHByb3AgeyhzcmNzZXRTaXplc1dpZHRoOiBudW1iZXIsIGNvbnRlbnQ6IENvbnRlbnQpID0+IG51bWJlcn0gc3Jjc2V0U2l6ZXNXaWR0aFxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHt7IGZuOiBQaG90b1N3aXBlRmlsdGVyc01hcFtUXSwgcHJpb3JpdHk6IG51bWJlciB9fSBGaWx0ZXI8VD5cclxuICovXHJcblxyXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHtQaG90b1N3aXBlRXZlbnRzTWFwW1RdIGV4dGVuZHMgdW5kZWZpbmVkID8gUGhvdG9Td2lwZUV2ZW50PFQ+IDogUGhvdG9Td2lwZUV2ZW50PFQ+ICYgUGhvdG9Td2lwZUV2ZW50c01hcFtUXX0gQXVnbWVudGVkRXZlbnRcclxuICovXHJcblxyXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHsoZXZlbnQ6IEF1Z21lbnRlZEV2ZW50PFQ+KSA9PiB2b2lkfSBFdmVudENhbGxiYWNrPFQ+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgUGhvdG9Td2lwZSBldmVudCBvYmplY3RcclxuICpcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqL1xyXG5jbGFzcyBQaG90b1N3aXBlRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7VH0gdHlwZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUV2ZW50c01hcFtUXX0gW2RldGFpbHNdXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZSwgZGV0YWlscykge1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIGlmIChkZXRhaWxzKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGV0YWlscyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcmV2ZW50RGVmYXVsdCgpIHtcclxuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGhvdG9Td2lwZSBiYXNlIGNsYXNzIHRoYXQgY2FuIGxpc3RlbiBhbmQgZGlzcGF0Y2ggZm9yIGV2ZW50cy5cclxuICogU2hhcmVkIGJ5IFBob3RvU3dpcGUgQ29yZSBhbmQgUGhvdG9Td2lwZSBMaWdodGJveCwgZXh0ZW5kZWQgYnkgYmFzZS5qc1xyXG4gKi9cclxuY2xhc3MgRXZlbnRhYmxlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge3sgW1QgaW4ga2V5b2YgUGhvdG9Td2lwZUV2ZW50c01hcF0/OiAoKGV2ZW50OiBBdWdtZW50ZWRFdmVudDxUPikgPT4gdm9pZClbXSB9fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHt7IFtUIGluIGtleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwXT86IEZpbHRlcjxUPltdIH19XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2ZpbHRlcnMgPSB7fTtcclxuXHJcbiAgICAvKiogQHR5cGUge1Bob3RvU3dpcGU9fSAqL1xyXG4gICAgdGhpcy5wc3dwID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7UGhvdG9Td2lwZU9wdGlvbnN9ICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwfSBUXHJcbiAgICogQHBhcmFtIHtUfSBuYW1lXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlRmlsdGVyc01hcFtUXX0gZm5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlcclxuICAgKi9cclxuICBhZGRGaWx0ZXIobmFtZSwgZm4sIHByaW9yaXR5ID0gMTAwKSB7XHJcbiAgICBpZiAoIXRoaXMuX2ZpbHRlcnNbbmFtZV0pIHtcclxuICAgICAgdGhpcy5fZmlsdGVyc1tuYW1lXSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0ucHVzaCh7IGZuLCBwcmlvcml0eSB9KTtcclxuICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0uc29ydCgoZjEsIGYyKSA9PiBmMS5wcmlvcml0eSAtIGYyLnByaW9yaXR5KTtcclxuXHJcbiAgICBpZiAodGhpcy5wc3dwKSB7XHJcbiAgICAgIHRoaXMucHN3cC5hZGRGaWx0ZXIobmFtZSwgZm4sIHByaW9yaXR5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUZpbHRlcnNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVGaWx0ZXJzTWFwW1RdfSBmblxyXG4gICAqL1xyXG4gIHJlbW92ZUZpbHRlcihuYW1lLCBmbikge1xyXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnNbbmFtZV0pIHtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICB0aGlzLl9maWx0ZXJzW25hbWVdID0gdGhpcy5fZmlsdGVyc1tuYW1lXS5maWx0ZXIoZmlsdGVyID0+IChmaWx0ZXIuZm4gIT09IGZuKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cCkge1xyXG4gICAgICB0aGlzLnBzd3AucmVtb3ZlRmlsdGVyKG5hbWUsIGZuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUZpbHRlcnNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8UGhvdG9Td2lwZUZpbHRlcnNNYXBbVF0+fSBhcmdzXHJcbiAgICogQHJldHVybnMge1BhcmFtZXRlcnM8UGhvdG9Td2lwZUZpbHRlcnNNYXBbVF0+WzBdfVxyXG4gICAqL1xyXG4gIGFwcGx5RmlsdGVycyhuYW1lLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAodGhpcy5fZmlsdGVyc1tuYW1lXSkge1xyXG4gICAgICB0aGlzLl9maWx0ZXJzW25hbWVdLmZvckVhY2goKGZpbHRlcikgPT4ge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBhcmdzWzBdID0gZmlsdGVyLmZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAgICogQHBhcmFtIHtUfSBuYW1lXHJcbiAgICogQHBhcmFtIHtFdmVudENhbGxiYWNrPFQ+fSBmblxyXG4gICAqL1xyXG4gIG9uKG5hbWUsIGZuKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tuYW1lXSkge1xyXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGZuKTtcclxuXHJcbiAgICAvLyBXaGVuIGJpbmRpbmcgZXZlbnRzIHRvIGxpZ2h0Ym94LFxyXG4gICAgLy8gYWxzbyBiaW5kIGV2ZW50cyB0byBQaG90b1N3aXBlIENvcmUsXHJcbiAgICAvLyBpZiBpdCdzIG9wZW4uXHJcbiAgICBpZiAodGhpcy5wc3dwKSB7XHJcbiAgICAgIHRoaXMucHN3cC5vbihuYW1lLCBmbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVFdmVudHNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge0V2ZW50Q2FsbGJhY2s8VD59IGZuXHJcbiAgICovXHJcbiAgb2ZmKG5hbWUsIGZuKSB7XHJcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gdGhpcy5fbGlzdGVuZXJzW25hbWVdLmZpbHRlcihsaXN0ZW5lciA9PiAoZm4gIT09IGxpc3RlbmVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHN3cCkge1xyXG4gICAgICB0aGlzLnBzd3Aub2ZmKG5hbWUsIGZuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUV2ZW50c01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUV2ZW50c01hcFtUXX0gW2RldGFpbHNdXHJcbiAgICogQHJldHVybnMge0F1Z21lbnRlZEV2ZW50PFQ+fVxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKG5hbWUsIGRldGFpbHMpIHtcclxuICAgIGlmICh0aGlzLnBzd3ApIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHN3cC5kaXNwYXRjaChuYW1lLCBkZXRhaWxzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBldmVudCA9IC8qKiBAdHlwZSB7QXVnbWVudGVkRXZlbnQ8VD59ICovIChuZXcgUGhvdG9Td2lwZUV2ZW50KG5hbWUsIGRldGFpbHMpKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tuYW1lXSkge1xyXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0uZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV2ZW50O1xyXG4gIH1cclxufVxuXG5jbGFzcyBQbGFjZWhvbGRlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBmYWxzZX0gaW1hZ2VTcmNcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihpbWFnZVNyYywgY29udGFpbmVyKSB7XHJcbiAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXJcclxuICAgIC8vIChzdHJldGNoZWQgdGh1bWJuYWlsIG9yIHNpbXBsZSBkaXYgYmVoaW5kIHRoZSBtYWluIGltYWdlKVxyXG4gICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudChcclxuICAgICAgJ3Bzd3BfX2ltZyBwc3dwX19pbWctLXBsYWNlaG9sZGVyJyxcclxuICAgICAgaW1hZ2VTcmMgPyAnaW1nJyA6ICcnLFxyXG4gICAgICBjb250YWluZXJcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGltYWdlU3JjKSB7XHJcbiAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi9cclxuICAgICAgKHRoaXMuZWxlbWVudCkuZGVjb2RpbmcgPSAnYXN5bmMnO1xyXG4gICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovXHJcbiAgICAgICh0aGlzLmVsZW1lbnQpLmFsdCA9ICcnO1xyXG4gICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovXHJcbiAgICAgICh0aGlzLmVsZW1lbnQpLnNyYyA9IGltYWdlU3JjO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKi9cclxuICBzZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICghdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgICAgIC8vIFVzZSB0cmFuc2Zvcm0gc2NhbGUoKSB0byBtb2RpZnkgaW1nIHBsYWNlaG9sZGVyIHNpemVcclxuICAgICAgLy8gKGluc3RlYWQgb2YgY2hhbmdpbmcgd2lkdGgvaGVpZ2h0IGRpcmVjdGx5KS5cclxuICAgICAgLy8gVGhpcyBoZWxwcyB3aXRoIHBlcmZvcm1hbmNlLCBzcGVjaWZpY2FsbHkgaW4gaU9TMTUgU2FmYXJpLlxyXG4gICAgICBzZXRXaWR0aEhlaWdodCh0aGlzLmVsZW1lbnQsIDI1MCwgJ2F1dG8nKTtcclxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2Zvcm1TdHJpbmcoMCwgMCwgd2lkdGggLyAyNTApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0V2lkdGhIZWlnaHQodGhpcy5lbGVtZW50LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcclxuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC91dGlsLmpzJykuTG9hZFN0YXRlfSBMb2FkU3RhdGUgKi9cclxuXHJcbmNsYXNzIENvbnRlbnQge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBTbGlkZSBkYXRhXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBpbnN0YW5jZSBQaG90b1N3aXBlIG9yIFBob3RvU3dpcGVMaWdodGJveCBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGl0ZW1EYXRhLCBpbnN0YW5jZSwgaW5kZXgpIHtcclxuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIHRoaXMuZGF0YSA9IGl0ZW1EYXRhO1xyXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxEaXZFbGVtZW50fSAqL1xyXG4gICAgdGhpcy5lbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCA9IDA7XHJcbiAgICB0aGlzLmRpc3BsYXllZEltYWdlSGVpZ2h0ID0gMDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuZGF0YS53KSB8fCBOdW1iZXIodGhpcy5kYXRhLndpZHRoKSB8fCAwO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIodGhpcy5kYXRhLmgpIHx8IE51bWJlcih0aGlzLmRhdGEuaGVpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYXNTbGlkZSA9IGZhbHNlO1xyXG4gICAgLyoqIEB0eXBlIHtMb2FkU3RhdGV9ICovXHJcbiAgICB0aGlzLnN0YXRlID0gTE9BRF9TVEFURS5JRExFO1xyXG5cclxuICAgIGlmICh0aGlzLmRhdGEudHlwZSkge1xyXG4gICAgICB0aGlzLnR5cGUgPSB0aGlzLmRhdGEudHlwZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnNyYykge1xyXG4gICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50eXBlID0gJ2h0bWwnO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRJbml0JywgeyBjb250ZW50OiB0aGlzIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlUGxhY2Vob2xkZXIoKSB7XHJcbiAgICBpZiAodGhpcy5wbGFjZWhvbGRlciAmJiAhdGhpcy5rZWVwUGxhY2Vob2xkZXIoKSkge1xyXG4gICAgICAvLyBXaXRoIGRlbGF5LCBhcyBpbWFnZSBtaWdodCBiZSBsb2FkZWQsIGJ1dCBub3QgcmVuZGVyZWRcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZWxvYWQgY29udGVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNMYXp5XHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcmVsb2FkXHJcbiAgICovXHJcbiAgbG9hZChpc0xhenksIHJlbG9hZCkge1xyXG4gICAgaWYgKHRoaXMuc2xpZGUgJiYgdGhpcy51c2VQbGFjZWhvbGRlcigpKSB7XHJcbiAgICAgIGlmICghdGhpcy5wbGFjZWhvbGRlcikge1xyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyU3JjID0gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoXHJcbiAgICAgICAgICAncGxhY2Vob2xkZXJTcmMnLFxyXG4gICAgICAgICAgLy8gdXNlICBpbWFnZS1iYXNlZCBwbGFjZWhvbGRlciBvbmx5IGZvciB0aGUgZmlyc3Qgc2xpZGUsXHJcbiAgICAgICAgICAvLyBhcyByZW5kZXJpbmcgKGV2ZW4gc21hbGwgc3RyZXRjaGVkIHRodW1ibmFpbCkgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvblxyXG4gICAgICAgICAgKHRoaXMuZGF0YS5tc3JjICYmIHRoaXMuc2xpZGUuaXNGaXJzdFNsaWRlKSA/IHRoaXMuZGF0YS5tc3JjIDogZmFsc2UsXHJcbiAgICAgICAgICB0aGlzXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gbmV3IFBsYWNlaG9sZGVyKFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXJTcmMsXHJcbiAgICAgICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lclxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJFbCA9IHRoaXMucGxhY2Vob2xkZXIuZWxlbWVudDtcclxuICAgICAgICAvLyBBZGQgcGxhY2Vob2xkZXIgdG8gRE9NIGlmIGl0IHdhcyBhbHJlYWR5IGNyZWF0ZWRcclxuICAgICAgICBpZiAocGxhY2Vob2xkZXJFbCAmJiAhcGxhY2Vob2xkZXJFbC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5wcmVwZW5kKHBsYWNlaG9sZGVyRWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgIXJlbG9hZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRMb2FkJywgeyBjb250ZW50OiB0aGlzLCBpc0xhenkgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19pbWcnLCAnaW1nJyk7XHJcbiAgICAgIC8vIFN0YXJ0IGxvYWRpbmcgb25seSBhZnRlciB3aWR0aCBpcyBkZWZpbmVkLCBhcyBzaXplcyBtaWdodCBkZXBlbmQgb24gaXQuXHJcbiAgICAgIC8vIER1ZSB0byBTYWZhcmkgZmVhdHVyZSwgd2UgbXVzdCBkZWZpbmUgc2l6ZXMgYmVmb3JlIHNyY3NldC5cclxuICAgICAgaWYgKHRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCkge1xyXG4gICAgICAgIHRoaXMubG9hZEltYWdlKGlzTGF6eSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX2NvbnRlbnQnKTtcclxuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuZGF0YS5odG1sIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZWxvYWQgJiYgdGhpcy5zbGlkZSkge1xyXG4gICAgICB0aGlzLnNsaWRlLnVwZGF0ZUNvbnRlbnRTaXplKHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlbG9hZCBpbWFnZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xhenlcclxuICAgKi9cclxuICBsb2FkSW1hZ2UoaXNMYXp5KSB7XHJcbiAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSAvKiogQHR5cGUgSFRNTEltYWdlRWxlbWVudCAqLyAodGhpcy5lbGVtZW50KTtcclxuXHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudExvYWRJbWFnZScsIHsgY29udGVudDogdGhpcywgaXNMYXp5IH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlU3Jjc2V0U2l6ZXMoKTtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhLnNyY3NldCkge1xyXG4gICAgICBpbWFnZUVsZW1lbnQuc3Jjc2V0ID0gdGhpcy5kYXRhLnNyY3NldDtcclxuICAgIH1cclxuXHJcbiAgICBpbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5kYXRhLnNyYztcclxuXHJcbiAgICBpbWFnZUVsZW1lbnQuYWx0ID0gdGhpcy5kYXRhLmFsdCB8fCAnJztcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gTE9BRF9TVEFURS5MT0FESU5HO1xyXG5cclxuICAgIGlmIChpbWFnZUVsZW1lbnQuY29tcGxldGUpIHtcclxuICAgICAgdGhpcy5vbkxvYWRlZCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLm9uRXJyb3IoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2lnbiBzbGlkZSB0byBjb250ZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NsaWRlfSBzbGlkZVxyXG4gICAqL1xyXG4gIHNldFNsaWRlKHNsaWRlKSB7XHJcbiAgICB0aGlzLnNsaWRlID0gc2xpZGU7XHJcbiAgICB0aGlzLmhhc1NsaWRlID0gdHJ1ZTtcclxuICAgIHRoaXMuaW5zdGFuY2UgPSBzbGlkZS5wc3dwO1xyXG5cclxuICAgIC8vIHRvZG86IGRvIHdlIG5lZWQgdG8gdW5zZXQgc2xpZGU/XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb250ZW50IGxvYWQgc3VjY2VzcyBoYW5kbGVyXHJcbiAgICovXHJcbiAgb25Mb2FkZWQoKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gTE9BRF9TVEFURS5MT0FERUQ7XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZENvbXBsZXRlJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgY29udGVudDogdGhpcyB9KTtcclxuXHJcbiAgICAgIC8vIGlmIGNvbnRlbnQgaXMgcmVsb2FkZWRcclxuICAgICAgaWYgKHRoaXMuc2xpZGUuaXNBY3RpdmVcclxuICAgICAgICAgICYmIHRoaXMuc2xpZGUuaGVhdnlBcHBlbmRlZFxyXG4gICAgICAgICAgJiYgIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmQoKTtcclxuICAgICAgICB0aGlzLnNsaWRlLnVwZGF0ZUNvbnRlbnRTaXplKHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5MT0FERUQgfHwgdGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUikge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGVudCBsb2FkIGVycm9yIGhhbmRsZXJcclxuICAgKi9cclxuICBvbkVycm9yKCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IExPQURfU1RBVEUuRVJST1I7XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZENvbXBsZXRlJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgaXNFcnJvcjogdHJ1ZSwgY29udGVudDogdGhpcyB9KTtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZEVycm9yJywgeyBzbGlkZTogdGhpcy5zbGlkZSwgY29udGVudDogdGhpcyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgY29udGVudCBpcyBjdXJyZW50bHkgbG9hZGluZ1xyXG4gICAqL1xyXG4gIGlzTG9hZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ2lzQ29udGVudExvYWRpbmcnLFxyXG4gICAgICB0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkxPQURJTkcsXHJcbiAgICAgIHRoaXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBpc0Vycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IExPQURfU1RBVEUuRVJST1I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgaXMgaW1hZ2VcclxuICAgKi9cclxuICBpc0ltYWdlQ29udGVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdpbWFnZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgY29udGVudCBzaXplXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcbiAgICovXHJcbiAgc2V0RGlzcGxheWVkU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgdGhpcy5wbGFjZWhvbGRlci5zZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudFJlc2l6ZScsIHsgY29udGVudDogdGhpcywgd2lkdGgsIGhlaWdodCB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRXaWR0aEhlaWdodCh0aGlzLmVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGlmICh0aGlzLmlzSW1hZ2VDb250ZW50KCkgJiYgIXRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgIGNvbnN0IGlzSW5pdGlhbFNpemVVcGRhdGUgPSAoIXRoaXMuZGlzcGxheWVkSW1hZ2VXaWR0aCAmJiB3aWR0aCk7XHJcblxyXG4gICAgICB0aGlzLmRpc3BsYXllZEltYWdlV2lkdGggPSB3aWR0aDtcclxuICAgICAgdGhpcy5kaXNwbGF5ZWRJbWFnZUhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgIGlmIChpc0luaXRpYWxTaXplVXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2UoZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3Jjc2V0U2l6ZXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2ltYWdlU2l6ZUNoYW5nZScsIHsgc2xpZGU6IHRoaXMuc2xpZGUsIHdpZHRoLCBoZWlnaHQsIGNvbnRlbnQ6IHRoaXMgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgY29udGVudCBjYW4gYmUgem9vbWVkXHJcbiAgICovXHJcbiAgaXNab29tYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ2lzQ29udGVudFpvb21hYmxlJyxcclxuICAgICAgdGhpcy5pc0ltYWdlQ29udGVudCgpICYmICh0aGlzLnN0YXRlICE9PSBMT0FEX1NUQVRFLkVSUk9SKSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBpbWFnZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlIGJhc2VkIG9uIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgKi9cclxuICB1cGRhdGVTcmNzZXRTaXplcygpIHtcclxuICAgIC8vIEhhbmRsZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlLlxyXG4gICAgLy9cclxuICAgIC8vIE5ldmVyIGxvd2VyIHF1YWxpdHksIGlmIGl0IHdhcyBpbmNyZWFzZWQgcHJldmlvdXNseS5cclxuICAgIC8vIENocm9tZSBkb2VzIHRoaXMgYXV0b21hdGljYWxseSwgRmlyZWZveCBhbmQgU2FmYXJpIGRvIG5vdCxcclxuICAgIC8vIHNvIHdlIHN0b3JlIGxhcmdlc3QgdXNlZCBzaXplIGluIGRhdGFzZXQuXHJcbiAgICAvLyBIYW5kbGUgc3Jjc2V0IHNpemVzIGF0dHJpYnV0ZS5cclxuICAgIC8vXHJcbiAgICAvLyBOZXZlciBsb3dlciBxdWFsaXR5LCBpZiBpdCB3YXMgaW5jcmVhc2VkIHByZXZpb3VzbHkuXHJcbiAgICAvLyBDaHJvbWUgZG9lcyB0aGlzIGF1dG9tYXRpY2FsbHksIEZpcmVmb3ggYW5kIFNhZmFyaSBkbyBub3QsXHJcbiAgICAvLyBzbyB3ZSBzdG9yZSBsYXJnZXN0IHVzZWQgc2l6ZSBpbiBkYXRhc2V0LlxyXG4gICAgaWYgKHRoaXMuZGF0YS5zcmNzZXQpIHtcclxuICAgICAgY29uc3QgaW1hZ2UgPSAvKiogQHR5cGUgSFRNTEltYWdlRWxlbWVudCAqLyAodGhpcy5lbGVtZW50KTtcclxuICAgICAgY29uc3Qgc2l6ZXNXaWR0aCA9IHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKFxyXG4gICAgICAgICdzcmNzZXRTaXplc1dpZHRoJyxcclxuICAgICAgICB0aGlzLmRpc3BsYXllZEltYWdlV2lkdGgsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKCFpbWFnZS5kYXRhc2V0Lmxhcmdlc3RVc2VkU2l6ZVxyXG4gICAgICAgICAgfHwgc2l6ZXNXaWR0aCA+IHBhcnNlSW50KGltYWdlLmRhdGFzZXQubGFyZ2VzdFVzZWRTaXplLCAxMCkpIHtcclxuICAgICAgICBpbWFnZS5zaXplcyA9IHNpemVzV2lkdGggKyAncHgnO1xyXG4gICAgICAgIGltYWdlLmRhdGFzZXQubGFyZ2VzdFVzZWRTaXplID0gU3RyaW5nKHNpemVzV2lkdGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgY29udGVudCBzaG91bGQgdXNlIGEgcGxhY2Vob2xkZXIgKGZyb20gbXNyYyBieSBkZWZhdWx0KVxyXG4gICAqL1xyXG4gIHVzZVBsYWNlaG9sZGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKFxyXG4gICAgICAndXNlQ29udGVudFBsYWNlaG9sZGVyJyxcclxuICAgICAgdGhpcy5pc0ltYWdlQ29udGVudCgpLFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlbG9hZCBjb250ZW50IHdpdGggbGF6eS1sb2FkaW5nIHBhcmFtXHJcbiAgICovXHJcbiAgbGF6eUxvYWQoKSB7XHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudExhenlMb2FkJywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9hZCh0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBJZiBwbGFjZWhvbGRlciBzaG91bGQgYmUga2VwdCBhZnRlciBjb250ZW50IGlzIGxvYWRlZFxyXG4gICAqL1xyXG4gIGtlZXBQbGFjZWhvbGRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycyhcclxuICAgICAgJ2lzS2VlcGluZ1BsYWNlaG9sZGVyJyxcclxuICAgICAgdGhpcy5pc0xvYWRpbmcoKSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIGNvbnRlbnRcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5oYXNTbGlkZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zbGlkZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnREZXN0cm95JywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcclxuICAgICAgdGhpcy5wbGFjZWhvbGRlci5kZXN0cm95KCk7XHJcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzSW1hZ2VDb250ZW50KCkgJiYgdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5vbmxvYWQgPSBudWxsO1xyXG4gICAgICB0aGlzLmVsZW1lbnQub25lcnJvciA9IG51bGw7XHJcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwbGF5IGVycm9yIG1lc3NhZ2VcclxuICAgKi9cclxuICBkaXNwbGF5RXJyb3IoKSB7XHJcbiAgICBpZiAodGhpcy5zbGlkZSkge1xyXG4gICAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xyXG4gICAgICBsZXQgZXJyb3JNc2dFbCA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX2Vycm9yLW1zZycpO1xyXG4gICAgICBlcnJvck1zZ0VsLmlubmVyVGV4dCA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5lcnJvck1zZztcclxuICAgICAgZXJyb3JNc2dFbCA9IHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKFxyXG4gICAgICAgICdjb250ZW50RXJyb3JFbGVtZW50JyxcclxuICAgICAgICBlcnJvck1zZ0VsLFxyXG4gICAgICAgIHRoaXNcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudCgncHN3cF9fY29udGVudCBwc3dwX19lcnJvci1tc2ctY29udGFpbmVyJyk7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChlcnJvck1zZ0VsKTtcclxuICAgICAgdGhpcy5zbGlkZS5jb250YWluZXIuaW5uZXJUZXh0ID0gJyc7XHJcbiAgICAgIHRoaXMuc2xpZGUuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuc2xpZGUudXBkYXRlQ29udGVudFNpemUodHJ1ZSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCB0aGUgY29udGVudFxyXG4gICAqL1xyXG4gIGFwcGVuZCgpIHtcclxuICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XHJcblxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IExPQURfU1RBVEUuRVJST1IpIHtcclxuICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50QXBwZW5kJywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN1cHBvcnRzRGVjb2RlID0gKCdkZWNvZGUnIGluIHRoaXMuZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSkge1xyXG4gICAgICAvLyBVc2UgZGVjb2RlKCkgb24gbmVhcmJ5IHNsaWRlc1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBOZWFyYnkgc2xpZGUgaW1hZ2VzIGFyZSBpbiBET00gYW5kIG5vdCBoaWRkZW4gdmlhIGRpc3BsYXk6bm9uZS5cclxuICAgICAgLy8gSG93ZXZlciwgdGhleSBhcmUgcGxhY2VkIG9mZnNjcmVlbiAodG8gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUpLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBjb21wb3NpdGUgdGhlIGltYWdlIHVudGlsIGl0J3MgYWN0dWFsbHkgdmlzaWJsZSxcclxuICAgICAgLy8gdXNpbmcgZGVjb2RlKCkgaGVscHMuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFlvdSBtaWdodCBhc2sgXCJ3aHkgZG9udCB5b3UganVzdCBkZWNvZGUoKSBhbmQgdGhlbiBhcHBlbmQgYWxsIGltYWdlc1wiLFxyXG4gICAgICAvLyB0aGF0J3MgYmVjYXVzZSBJIHdhbnQgdG8gc2hvdyBpbWFnZSBiZWZvcmUgaXQncyBmdWxseSBsb2FkZWQsXHJcbiAgICAgIC8vIGFzIGJyb3dzZXIgY2FuIHJlbmRlciBwYXJ0cyBvZiBpbWFnZSB3aGlsZSBpdCBpcyBsb2FkaW5nLlxyXG4gICAgICAvLyBXZSBkbyBub3QgZG8gdGhpcyBpbiBTYWZhcmkgZHVlIHRvIHBhcnRpYWwgbG9hZGluZyBidWcuXHJcbiAgICAgIGlmIChzdXBwb3J0c0RlY29kZSAmJiB0aGlzLnNsaWRlICYmICghdGhpcy5zbGlkZS5pc0FjdGl2ZSB8fCBpc1NhZmFyaSgpKSkge1xyXG4gICAgICAgIHRoaXMuaXNEZWNvZGluZyA9IHRydWU7XHJcbiAgICAgICAgLy8gcHVycG9zZWZ1bGx5IHVzaW5nIGZpbmFsbHkgaW5zdGVhZCBvZiB0aGVuLFxyXG4gICAgICAgIC8vIGFzIGlmIHNyY3NldCBzaXplcyBjaGFuZ2VzIGR5bmFtaWNhbGx5IC0gaXQgbWF5IGNhdXNlIGRlY29kZSBlcnJvclxyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi9cclxuICAgICAgICAodGhpcy5lbGVtZW50KS5kZWNvZGUoKS5jYXRjaCgoKSA9PiB7fSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmlzRGVjb2RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuYXBwZW5kSW1hZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFwcGVuZEltYWdlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50ICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWN0aXZhdGUgdGhlIHNsaWRlLFxyXG4gICAqIGFjdGl2ZSBzbGlkZSBpcyBnZW5lcmFsbHkgdGhlIGN1cnJlbnQgb25lLFxyXG4gICAqIG1lYW5pbmcgdGhlIHVzZXIgY2FuIHNlZSBpdC5cclxuICAgKi9cclxuICBhY3RpdmF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50QWN0aXZhdGUnLCB7IGNvbnRlbnQ6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcclxuICAgICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSAmJiB0aGlzLmlzRGVjb2RpbmcgJiYgIWlzU2FmYXJpKCkpIHtcclxuICAgICAgICAvLyBhZGQgaW1hZ2UgdG8gc2xpZGUgd2hlbiBpdCBiZWNvbWVzIGFjdGl2ZSxcclxuICAgICAgICAvLyBldmVuIGlmIGl0J3Mgbm90IGZpbmlzaGVkIGRlY29kaW5nXHJcbiAgICAgICAgdGhpcy5hcHBlbmRJbWFnZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkKGZhbHNlLCB0cnVlKTsgLy8gdHJ5IHRvIHJlbG9hZFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5zbGlkZS5ob2xkZXJFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5zbGlkZS5ob2xkZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVhY3RpdmF0ZSB0aGUgY29udGVudFxyXG4gICAqL1xyXG4gIGRlYWN0aXZhdGUoKSB7XHJcbiAgICB0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50RGVhY3RpdmF0ZScsIHsgY29udGVudDogdGhpcyB9KTtcclxuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMuc2xpZGUuaG9sZGVyRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnNsaWRlLmhvbGRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBjb250ZW50IGZyb20gRE9NXHJcbiAgICovXHJcbiAgcmVtb3ZlKCkge1xyXG4gICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRSZW1vdmUnLCB7IGNvbnRlbnQ6IHRoaXMgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIgJiYgdGhpcy5wbGFjZWhvbGRlci5lbGVtZW50KSB7XHJcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIuZWxlbWVudC5yZW1vdmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCB0aGUgaW1hZ2UgY29udGVudCB0byBzbGlkZSBjb250YWluZXJcclxuICAgKi9cclxuICBhcHBlbmRJbWFnZSgpIHtcclxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudEFwcGVuZEltYWdlJywgeyBjb250ZW50OiB0aGlzIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGVuc3VyZSB0aGF0IGVsZW1lbnQgZXhpc3RzIGFuZCBpcyBub3QgYWxyZWFkeSBhcHBlbmRlZFxyXG4gICAgaWYgKHRoaXMuc2xpZGUgJiYgdGhpcy5lbGVtZW50ICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkxPQURFRCB8fCB0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkVSUk9SKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoKTtcclxuICAgIH1cclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29udGVudC5qcycpLmRlZmF1bHR9IENvbnRlbnQgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL2Jhc2UuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlQmFzZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2xpZ2h0Ym94L2xpZ2h0Ym94LmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZUxpZ2h0Ym94ICovXHJcblxyXG5jb25zdCBNSU5fU0xJREVTX1RPX0NBQ0hFID0gNTtcclxuXHJcbi8qKlxyXG4gKiBMYXp5LWxvYWQgYW4gaW1hZ2VcclxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggYnkgTGlnaHRib3ggYW5kIFBob3RvU3dpcGUgY29yZSxcclxuICogdGh1cyBpdCBjYW4gYmUgY2FsbGVkIGJlZm9yZSBkaWFsb2cgaXMgb3BlbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgRGF0YSBhYm91dCB0aGUgc2xpZGVcclxuICogQHBhcmFtIHtQaG90b1N3aXBlIHwgUGhvdG9Td2lwZUxpZ2h0Ym94IHwgUGhvdG9Td2lwZUJhc2V9IGluc3RhbmNlIFBob3RvU3dpcGUgaW5zdGFuY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqIEByZXR1cm5zIEltYWdlIHRoYXQgaXMgYmVpbmcgZGVjb2RlZCBvciBmYWxzZS5cclxuICovXHJcbmZ1bmN0aW9uIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgaW5zdGFuY2UsIGluZGV4KSB7XHJcbiAgLy8gc3JjL3NsaWRlL2NvbnRlbnQvY29udGVudC5qc1xyXG4gIGNvbnN0IGNvbnRlbnQgPSBpbnN0YW5jZS5jcmVhdGVDb250ZW50RnJvbURhdGEoaXRlbURhdGEsIGluZGV4KTtcclxuXHJcbiAgaWYgKCFjb250ZW50IHx8ICFjb250ZW50LmxhenlMb2FkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IG9wdGlvbnMgfSA9IGluc3RhbmNlO1xyXG5cclxuICAvLyBXZSBuZWVkIHRvIGtub3cgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgdG8gcHJlbG9hZCBpdCxcclxuICAvLyBhcyBpdCBtaWdodCB1c2Ugc3Jjc2V0IGFuZCB3ZSBuZWVkIHRvIGRlZmluZSBzaXplc1xyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3Igc2hvdWxkIHByb3ZpZGUgcHN3cCBpbnN0YW5jZT9cclxuICBjb25zdCB2aWV3cG9ydFNpemUgPSBpbnN0YW5jZS52aWV3cG9ydFNpemUgfHwgZ2V0Vmlld3BvcnRTaXplKG9wdGlvbnMsIGluc3RhbmNlKTtcclxuICBjb25zdCBwYW5BcmVhU2l6ZSA9IGdldFBhbkFyZWFTaXplKG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KTtcclxuXHJcbiAgY29uc3Qgem9vbUxldmVsID0gbmV3IFpvb21MZXZlbChvcHRpb25zLCBpdGVtRGF0YSwgLTEpO1xyXG4gIHpvb21MZXZlbC51cGRhdGUoY29udGVudC53aWR0aCwgY29udGVudC5oZWlnaHQsIHBhbkFyZWFTaXplKTtcclxuXHJcbiAgY29udGVudC5sYXp5TG9hZCgpO1xyXG4gIGNvbnRlbnQuc2V0RGlzcGxheWVkU2l6ZShcclxuICAgIE1hdGguY2VpbChjb250ZW50LndpZHRoICogem9vbUxldmVsLmluaXRpYWwpLFxyXG4gICAgTWF0aC5jZWlsKGNvbnRlbnQuaGVpZ2h0ICogem9vbUxldmVsLmluaXRpYWwpXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIGNvbnRlbnQ7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTGF6eS1sb2FkcyBzcGVjaWZpYyBzbGlkZS5cclxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggYnkgTGlnaHRib3ggYW5kIFBob3RvU3dpcGUgY29yZSxcclxuICogdGh1cyBpdCBjYW4gYmUgY2FsbGVkIGJlZm9yZSBkaWFsb2cgaXMgb3BlbmVkLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0IGl0IGxvYWRzIGltYWdlIGJhc2VkIG9uIHZpZXdwb3J0IHNpemUgYW5kIGluaXRpYWwgem9vbSBsZXZlbC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFNsaWRlIGluZGV4XHJcbiAqIEBwYXJhbSB7UGhvdG9Td2lwZSB8IFBob3RvU3dpcGVMaWdodGJveH0gaW5zdGFuY2UgUGhvdG9Td2lwZSBvciBQaG90b1N3aXBlTGlnaHRib3ggZXZlbnRhYmxlIGluc3RhbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXp5TG9hZFNsaWRlKGluZGV4LCBpbnN0YW5jZSkge1xyXG4gIGNvbnN0IGl0ZW1EYXRhID0gaW5zdGFuY2UuZ2V0SXRlbURhdGEoaW5kZXgpO1xyXG5cclxuICBpZiAoaW5zdGFuY2UuZGlzcGF0Y2goJ2xhenlMb2FkU2xpZGUnLCB7IGluZGV4LCBpdGVtRGF0YSB9KS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGF6eUxvYWREYXRhKGl0ZW1EYXRhLCBpbnN0YW5jZSwgaW5kZXgpO1xyXG59XHJcblxyXG5cclxuY2xhc3MgQ29udGVudExvYWRlciB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocHN3cCkge1xyXG4gICAgdGhpcy5wc3dwID0gcHN3cDtcclxuICAgIC8vIFRvdGFsIGFtb3VudCBvZiBjYWNoZWQgaW1hZ2VzXHJcbiAgICB0aGlzLmxpbWl0ID0gTWF0aC5tYXgoXHJcbiAgICAgIHBzd3Aub3B0aW9ucy5wcmVsb2FkWzBdICsgcHN3cC5vcHRpb25zLnByZWxvYWRbMV0gKyAxLFxyXG4gICAgICBNSU5fU0xJREVTX1RPX0NBQ0hFXHJcbiAgICApO1xyXG4gICAgLyoqIEB0eXBlIHtDb250ZW50W119ICovXHJcbiAgICB0aGlzLl9jYWNoZWRJdGVtcyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGF6eSBsb2FkIG5lYXJieSBzbGlkZXMgYmFzZWQgb24gYHByZWxvYWRgIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGlmZiBEaWZmZXJlbmNlIGJldHdlZW4gc2xpZGUgaW5kZXhlcyB0aGF0IHdhcyBjaGFuZ2VkIHJlY2VudGx5LCBvciAwLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUxhenkoZGlmZikge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmIChwc3dwLmRpc3BhdGNoKCdsYXp5TG9hZCcpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgcHJlbG9hZCB9ID0gcHN3cC5vcHRpb25zO1xyXG4gICAgY29uc3QgaXNGb3J3YXJkID0gZGlmZiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IChkaWZmID49IDApO1xyXG4gICAgbGV0IGk7XHJcblxyXG4gICAgLy8gcHJlbG9hZFsxXSAtIG51bSBpdGVtcyB0byBwcmVsb2FkIGluIGZvcndhcmQgZGlyZWN0aW9uXHJcbiAgICBmb3IgKGkgPSAwOyBpIDw9IHByZWxvYWRbMV07IGkrKykge1xyXG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gaSA6ICgtaSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcmVsb2FkWzBdIC0gbnVtIGl0ZW1zIHRvIHByZWxvYWQgaW4gYmFja3dhcmQgZGlyZWN0aW9uXHJcbiAgICBmb3IgKGkgPSAxOyBpIDw9IHByZWxvYWRbMF07IGkrKykge1xyXG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gKC1pKSA6IGkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIGxvYWRTbGlkZUJ5SW5kZXgoaW5kZXgpIHtcclxuICAgIGluZGV4ID0gdGhpcy5wc3dwLmdldExvb3BlZEluZGV4KGluZGV4KTtcclxuICAgIC8vIHRyeSB0byBnZXQgY2FjaGVkIGNvbnRlbnRcclxuICAgIGxldCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50QnlJbmRleChpbmRleCk7XHJcbiAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgLy8gbm8gY2FjaGVkIGNvbnRlbnQsIHNvIHRyeSB0byBsb2FkIGZyb20gc2NyYXRjaDpcclxuICAgICAgY29udGVudCA9IGxhenlMb2FkU2xpZGUoaW5kZXgsIHRoaXMucHN3cCk7XHJcbiAgICAgIC8vIGlmIGNvbnRlbnQgY2FuIGJlIGxvYWRlZCwgYWRkIGl0IHRvIGNhY2hlOlxyXG4gICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgIHRoaXMuYWRkVG9DYWNoZShjb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTbGlkZX0gc2xpZGVcclxuICAgKi9cclxuICBnZXRDb250ZW50QnlTbGlkZShzbGlkZSkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnRCeUluZGV4KHNsaWRlLmluZGV4KTtcclxuICAgIGlmICghY29udGVudCkge1xyXG4gICAgICAvLyBjcmVhdGUgY29udGVudCBpZiBub3QgZm91bmQgaW4gY2FjaGVcclxuICAgICAgY29udGVudCA9IHRoaXMucHN3cC5jcmVhdGVDb250ZW50RnJvbURhdGEoc2xpZGUuZGF0YSwgc2xpZGUuaW5kZXgpO1xyXG4gICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgIHRoaXMuYWRkVG9DYWNoZShjb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgIC8vIGFzc2lnbiBzbGlkZSB0byBjb250ZW50XHJcbiAgICAgIGNvbnRlbnQuc2V0U2xpZGUoc2xpZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0NvbnRlbnR9IGNvbnRlbnRcclxuICAgKi9cclxuICBhZGRUb0NhY2hlKGNvbnRlbnQpIHtcclxuICAgIC8vIG1vdmUgdG8gdGhlIGVuZCBvZiBhcnJheVxyXG4gICAgdGhpcy5yZW1vdmVCeUluZGV4KGNvbnRlbnQuaW5kZXgpO1xyXG4gICAgdGhpcy5fY2FjaGVkSXRlbXMucHVzaChjb250ZW50KTtcclxuXHJcbiAgICBpZiAodGhpcy5fY2FjaGVkSXRlbXMubGVuZ3RoID4gdGhpcy5saW1pdCkge1xyXG4gICAgICAvLyBEZXN0cm95IHRoZSBmaXJzdCBjb250ZW50IHRoYXQncyBub3QgYXR0YWNoZWRcclxuICAgICAgY29uc3QgaW5kZXhUb1JlbW92ZSA9IHRoaXMuX2NhY2hlZEl0ZW1zLmZpbmRJbmRleCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIHJldHVybiAhaXRlbS5pc0F0dGFjaGVkICYmICFpdGVtLmhhc1NsaWRlO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGluZGV4VG9SZW1vdmUgIT09IC0xKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZEl0ZW0gPSB0aGlzLl9jYWNoZWRJdGVtcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSlbMF07XHJcbiAgICAgICAgcmVtb3ZlZEl0ZW0uZGVzdHJveSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFuIGltYWdlIGZyb20gY2FjaGUsIGRvZXMgbm90IGRlc3Ryb3koKSBpdCwganVzdCByZW1vdmVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgcmVtb3ZlQnlJbmRleChpbmRleCkge1xyXG4gICAgY29uc3QgaW5kZXhUb1JlbW92ZSA9IHRoaXMuX2NhY2hlZEl0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0uaW5kZXggPT09IGluZGV4KTtcclxuICAgIGlmIChpbmRleFRvUmVtb3ZlICE9PSAtMSkge1xyXG4gICAgICB0aGlzLl9jYWNoZWRJdGVtcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKi9cclxuICBnZXRDb250ZW50QnlJbmRleChpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEl0ZW1zLmZpbmQoY29udGVudCA9PiBjb250ZW50LmluZGV4ID09PSBpbmRleCk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fY2FjaGVkSXRlbXMuZm9yRWFjaChjb250ZW50ID0+IGNvbnRlbnQuZGVzdHJveSgpKTtcclxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zID0gbnVsbDtcclxuICB9XHJcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9waG90b3N3aXBlLmpzXCIpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9waG90b3N3aXBlLmpzXCIpLlBob3RvU3dpcGVPcHRpb25zfSBQaG90b1N3aXBlT3B0aW9ucyAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL3NsaWRlL3NsaWRlLmpzXCIpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXHJcblxyXG4vKipcclxuICogUGhvdG9Td2lwZSBiYXNlIGNsYXNzIHRoYXQgY2FuIHJldHJpZXZlIGRhdGEgYWJvdXQgZXZlcnkgc2xpZGUuXHJcbiAqIFNoYXJlZCBieSBQaG90b1N3aXBlIENvcmUgYW5kIFBob3RvU3dpcGUgTGlnaHRib3hcclxuICovXHJcbmNsYXNzIFBob3RvU3dpcGVCYXNlIGV4dGVuZHMgRXZlbnRhYmxlIHtcclxuICAvKipcclxuICAgKiBHZXQgdG90YWwgbnVtYmVyIG9mIHNsaWRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXROdW1JdGVtcygpIHtcclxuICAgIGxldCBudW1JdGVtcztcclxuICAgIGNvbnN0IHsgZGF0YVNvdXJjZSB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgaWYgKCFkYXRhU291cmNlKSB7XHJcbiAgICAgIG51bUl0ZW1zID0gMDtcclxuICAgIH0gZWxzZSBpZiAoJ2xlbmd0aCcgaW4gZGF0YVNvdXJjZSkge1xyXG4gICAgICAvLyBtYXkgYmUgYW4gYXJyYXkgb3IganVzdCBvYmplY3Qgd2l0aCBsZW5ndGggcHJvcGVydHlcclxuICAgICAgbnVtSXRlbXMgPSBkYXRhU291cmNlLmxlbmd0aDtcclxuICAgIH0gZWxzZSBpZiAoJ2dhbGxlcnknIGluIGRhdGFTb3VyY2UpIHtcclxuICAgICAgLy8gcXVlcnkgRE9NIGVsZW1lbnRzXHJcbiAgICAgIGlmICghZGF0YVNvdXJjZS5pdGVtcykge1xyXG4gICAgICAgIGRhdGFTb3VyY2UuaXRlbXMgPSB0aGlzLl9nZXRHYWxsZXJ5RE9NRWxlbWVudHMoZGF0YVNvdXJjZS5nYWxsZXJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRhdGFTb3VyY2UuaXRlbXMpIHtcclxuICAgICAgICBudW1JdGVtcyA9IGRhdGFTb3VyY2UuaXRlbXMubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbGVnYWN5IGV2ZW50LCBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5kaXNwYXRjaCgnbnVtSXRlbXMnLCB7XHJcbiAgICAgIGRhdGFTb3VyY2UsXHJcbiAgICAgIG51bUl0ZW1zXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnbnVtSXRlbXMnLCBldmVudC5udW1JdGVtcywgZGF0YVNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gc2xpZGVEYXRhXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgY3JlYXRlQ29udGVudEZyb21EYXRhKHNsaWRlRGF0YSwgaW5kZXgpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHJldHVybiBuZXcgQ29udGVudChzbGlkZURhdGEsIHRoaXMsIGluZGV4KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBpdGVtIGRhdGEgYnkgaW5kZXguXHJcbiAgICpcclxuICAgKiBcIml0ZW0gZGF0YVwiIHNob3VsZCBjb250YWluIG5vcm1hbGl6ZWQgaW5mb3JtYXRpb24gdGhhdCBQaG90b1N3aXBlIG5lZWRzIHRvIGdlbmVyYXRlIGEgc2xpZGUuXHJcbiAgICogRm9yIGV4YW1wbGUsIGl0IG1heSBjb250YWluIHByb3BlcnRpZXMgbGlrZVxyXG4gICAqIGBzcmNgLCBgc3Jjc2V0YCwgYHdgLCBgaGAsIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBhIHNsaWRlIHdpdGggaW1hZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKi9cclxuICBnZXRJdGVtRGF0YShpbmRleCkge1xyXG4gICAgY29uc3QgeyBkYXRhU291cmNlIH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBsZXQgZGF0YVNvdXJjZUl0ZW07XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhU291cmNlKSkge1xyXG4gICAgICAvLyBEYXRhc291cmNlIGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzXHJcbiAgICAgIGRhdGFTb3VyY2VJdGVtID0gZGF0YVNvdXJjZVtpbmRleF07XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFTb3VyY2UgJiYgZGF0YVNvdXJjZS5nYWxsZXJ5KSB7XHJcbiAgICAgIC8vIGRhdGFTb3VyY2UgaGFzIGdhbGxlcnkgcHJvcGVydHksXHJcbiAgICAgIC8vIHRodXMgaXQgd2FzIGNyZWF0ZWQgYnkgTGlnaHRib3gsIGJhc2VkIG9uXHJcbiAgICAgIC8vIGdhbGxlcnkgYW5kIGNoaWxkcmVuIG9wdGlvbnNcclxuXHJcbiAgICAgIC8vIHF1ZXJ5IERPTSBlbGVtZW50c1xyXG4gICAgICBpZiAoIWRhdGFTb3VyY2UuaXRlbXMpIHtcclxuICAgICAgICBkYXRhU291cmNlLml0ZW1zID0gdGhpcy5fZ2V0R2FsbGVyeURPTUVsZW1lbnRzKGRhdGFTb3VyY2UuZ2FsbGVyeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRhdGFTb3VyY2VJdGVtID0gZGF0YVNvdXJjZS5pdGVtc1tpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGl0ZW1EYXRhID0gZGF0YVNvdXJjZUl0ZW07XHJcblxyXG4gICAgaWYgKGl0ZW1EYXRhIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICBpdGVtRGF0YSA9IHRoaXMuX2RvbUVsZW1lbnRUb0l0ZW1EYXRhKGl0ZW1EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaGluZyB0aGUgaXRlbURhdGEgZXZlbnQsXHJcbiAgICAvLyBpdCdzIGEgbGVnYWN5IHZlcmlvbiBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcclxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5kaXNwYXRjaCgnaXRlbURhdGEnLCB7XHJcbiAgICAgIGl0ZW1EYXRhOiBpdGVtRGF0YSB8fCB7fSxcclxuICAgICAgaW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnaXRlbURhdGEnLCBldmVudC5pdGVtRGF0YSwgaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFycmF5IG9mIGdhbGxlcnkgRE9NIGVsZW1lbnRzLFxyXG4gICAqIGJhc2VkIG9uIGNoaWxkU2VsZWN0b3IgYW5kIGdhbGxlcnkgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGdhbGxlcnlFbGVtZW50XHJcbiAgICovXHJcbiAgX2dldEdhbGxlcnlET01FbGVtZW50cyhnYWxsZXJ5RWxlbWVudCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jaGlsZHJlbiB8fCB0aGlzLm9wdGlvbnMuY2hpbGRTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gZ2V0RWxlbWVudHNGcm9tT3B0aW9uKFxyXG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGlsZHJlbixcclxuICAgICAgICB0aGlzLm9wdGlvbnMuY2hpbGRTZWxlY3RvcixcclxuICAgICAgICBnYWxsZXJ5RWxlbWVudFxyXG4gICAgICApIHx8IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbZ2FsbGVyeUVsZW1lbnRdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgRE9NIGVsZW1lbnQgdG8gaXRlbSBkYXRhIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRE9NIGVsZW1lbnRcclxuICAgKi9cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xyXG4gIF9kb21FbGVtZW50VG9JdGVtRGF0YShlbGVtZW50KSB7XHJcbiAgICAvKiogQHR5cGUge1NsaWRlRGF0YX0gKi9cclxuICAgIGNvbnN0IGl0ZW1EYXRhID0ge1xyXG4gICAgICBlbGVtZW50XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICBjb25zdCBsaW5rRWwgPSAvKiogQHR5cGUge0hUTUxBbmNob3JFbGVtZW50fSAqLyAoZWxlbWVudC50YWdOYW1lID09PSAnQScgPyBlbGVtZW50IDogZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhJykpO1xyXG5cclxuICAgIGlmIChsaW5rRWwpIHtcclxuICAgICAgLy8gc3JjIGNvbWVzIGZyb20gZGF0YS1wc3dwLXNyYyBhdHRyaWJ1dGUsXHJcbiAgICAgIC8vIGlmIGl0J3MgZW1wdHkgbGluayBocmVmIGlzIHVzZWRcclxuICAgICAgaXRlbURhdGEuc3JjID0gbGlua0VsLmRhdGFzZXQucHN3cFNyYyB8fCBsaW5rRWwuaHJlZjtcclxuXHJcbiAgICAgIGlmIChsaW5rRWwuZGF0YXNldC5wc3dwU3Jjc2V0KSB7XHJcbiAgICAgICAgaXRlbURhdGEuc3Jjc2V0ID0gbGlua0VsLmRhdGFzZXQucHN3cFNyY3NldDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlbURhdGEud2lkdGggPSBwYXJzZUludChsaW5rRWwuZGF0YXNldC5wc3dwV2lkdGgsIDEwKTtcclxuICAgICAgaXRlbURhdGEuaGVpZ2h0ID0gcGFyc2VJbnQobGlua0VsLmRhdGFzZXQucHN3cEhlaWdodCwgMTApO1xyXG5cclxuICAgICAgLy8gc3VwcG9ydCBsZWdhY3kgdyAmIGggcHJvcGVydGllc1xyXG4gICAgICBpdGVtRGF0YS53ID0gaXRlbURhdGEud2lkdGg7XHJcbiAgICAgIGl0ZW1EYXRhLmggPSBpdGVtRGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgICBpZiAobGlua0VsLmRhdGFzZXQucHN3cFR5cGUpIHtcclxuICAgICAgICBpdGVtRGF0YS50eXBlID0gbGlua0VsLmRhdGFzZXQucHN3cFR5cGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRodW1ibmFpbEVsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcclxuXHJcbiAgICAgIGlmICh0aHVtYm5haWxFbCkge1xyXG4gICAgICAgIC8vIG1zcmMgaXMgVVJMIHRvIHBsYWNlaG9sZGVyIGltYWdlIHRoYXQncyBkaXNwbGF5ZWQgYmVmb3JlIGxhcmdlIGltYWdlIGlzIGxvYWRlZFxyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgaXQncyBkaXNwbGF5ZWQgb25seSBmb3IgdGhlIGZpcnN0IHNsaWRlXHJcbiAgICAgICAgaXRlbURhdGEubXNyYyA9IHRodW1ibmFpbEVsLmN1cnJlbnRTcmMgfHwgdGh1bWJuYWlsRWwuc3JjO1xyXG4gICAgICAgIGl0ZW1EYXRhLmFsdCA9IHRodW1ibmFpbEVsLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChsaW5rRWwuZGF0YXNldC5wc3dwQ3JvcHBlZCB8fCBsaW5rRWwuZGF0YXNldC5jcm9wcGVkKSB7XHJcbiAgICAgICAgaXRlbURhdGEudGh1bWJDcm9wcGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnZG9tSXRlbURhdGEnLCBpdGVtRGF0YSwgZWxlbWVudCwgbGlua0VsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExhenktbG9hZCBieSBzbGlkZSBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgRGF0YSBhYm91dCB0aGUgc2xpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJucyBJbWFnZSB0aGF0IGlzIGJlaW5nIGRlY29kZWQgb3IgZmFsc2UuXHJcbiAgICovXHJcbiAgbGF6eUxvYWREYXRhKGl0ZW1EYXRhLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgdGhpcywgaW5kZXgpO1xyXG4gIH1cclxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9nZXQtdGh1bWItYm91bmRzLmpzJykuQm91bmRzfSBCb3VuZHMgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbC9hbmltYXRpb25zLmpzJykuQW5pbWF0aW9uUHJvcHN9IEFuaW1hdGlvblByb3BzICovXHJcblxyXG4vLyBzb21lIGJyb3dzZXJzIGRvIG5vdCBwYWludFxyXG4vLyBlbGVtZW50cyB3aGljaCBvcGFjaXR5IGlzIHNldCB0byAwLFxyXG4vLyBzaW5jZSB3ZSBuZWVkIHRvIHByZS1yZW5kZXIgZWxlbWVudHMgZm9yIHRoZSBhbmltYXRpb24gLVxyXG4vLyB3ZSBzZXQgaXQgdG8gdGhlIG1pbmltdW0gYW1vdW50XHJcbmNvbnN0IE1JTl9PUEFDSVRZID0gMC4wMDM7XHJcblxyXG4vKipcclxuICogTWFuYWdlcyBvcGVuaW5nIGFuZCBjbG9zaW5nIHRyYW5zaXRpb25zIG9mIHRoZSBQaG90b1N3aXBlLlxyXG4gKlxyXG4gKiBJdCBjYW4gcGVyZm9ybSB6b29tLCBmYWRlIG9yIG5vIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jbGFzcyBPcGVuZXIge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcclxuICAgIHRoaXMucHN3cCA9IHBzd3A7XHJcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcclxuICAgIHRoaXMuX3ByZXBhcmVPcGVuID0gdGhpcy5fcHJlcGFyZU9wZW4uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2ZhbHNlIHwgQm91bmRzfSAqL1xyXG4gICAgdGhpcy5fdGh1bWJCb3VuZHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gT3ZlcnJpZGUgaW5pdGlhbCB6b29tIGFuZCBwYW4gcG9zaXRpb25cclxuICAgIHBzd3Aub24oJ2ZpcnN0Wm9vbVBhbicsIHRoaXMuX3ByZXBhcmVPcGVuKTtcclxuICB9XHJcblxyXG4gIG9wZW4oKSB7XHJcbiAgICB0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG4gICAgdGhpcy5fc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNsb3NlKCkge1xyXG4gICAgaWYgKHRoaXMuaXNDbG9zZWQgfHwgdGhpcy5pc0Nsb3NpbmcgfHwgdGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgLy8gaWYgd2UgY2xvc2UgZHVyaW5nIG9wZW5pbmcgYW5pbWF0aW9uXHJcbiAgICAgIC8vIGZvciBub3cgZG8gbm90aGluZyxcclxuICAgICAgLy8gYnJvd3NlcnMgYXJlbid0IGdvb2QgYXQgY2hhbmdpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgQ1NTIHRyYW5zaXRpb25cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuXHJcbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNDbG9zaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5wc3dwLm9wdGlvbnMuaGlkZUFuaW1hdGlvbkR1cmF0aW9uO1xyXG5cclxuICAgIGlmIChzbGlkZSAmJiBzbGlkZS5jdXJyWm9vbUxldmVsICogc2xpZGUud2lkdGggPj0gdGhpcy5wc3dwLm9wdGlvbnMubWF4V2lkdGhUb0FuaW1hdGUpIHtcclxuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2FwcGx5U3RhcnRQcm9wcygpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICB9LCB0aGlzLl9jcm9wcGVkWm9vbSA/IDMwIDogMCk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZU9wZW4oKSB7XHJcbiAgICB0aGlzLnBzd3Aub2ZmKCdmaXJzdFpvb21QYW4nLCB0aGlzLl9wcmVwYXJlT3Blbik7XHJcbiAgICBpZiAoIXRoaXMuaXNPcGVuaW5nKSB7XHJcbiAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuICAgICAgdGhpcy5pc09wZW5pbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLmlzQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMucHN3cC5vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbjtcclxuICAgICAgaWYgKHNsaWRlICYmIHNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCAqIHNsaWRlLndpZHRoID49IHRoaXMucHN3cC5vcHRpb25zLm1heFdpZHRoVG9BbmltYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2FwcGx5U3RhcnRQcm9wcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2FwcGx5U3RhcnRQcm9wcygpIHtcclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcclxuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcHN3cDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5zaG93SGlkZUFuaW1hdGlvblR5cGUgPT09ICdmYWRlJykge1xyXG4gICAgICBvcHRpb25zLnNob3dIaWRlT3BhY2l0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3RodW1iQm91bmRzID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2hvd0hpZGVBbmltYXRpb25UeXBlID09PSAnbm9uZScpIHtcclxuICAgICAgb3B0aW9ucy5zaG93SGlkZU9wYWNpdHkgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xyXG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzT3BlbmluZyAmJiBwc3dwLl9pbml0aWFsVGh1bWJCb3VuZHMpIHtcclxuICAgICAgLy8gVXNlIGluaXRpYWwgYm91bmRzIGlmIGRlZmluZWRcclxuICAgICAgdGhpcy5fdGh1bWJCb3VuZHMgPSBwc3dwLl9pbml0aWFsVGh1bWJCb3VuZHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IHRoaXMucHN3cC5nZXRUaHVtYkJvdW5kcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gc2xpZGUuZ2V0UGxhY2Vob2xkZXJFbGVtZW50KCk7XHJcblxyXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGwoKTtcclxuXHJcbiAgICAvLyBEaXNjYXJkIGFuaW1hdGlvbnMgd2hlbiBkdXJhdGlvbiBpcyBsZXNzIHRoYW4gNTBtc1xyXG4gICAgdGhpcy5fdXNlQW5pbWF0aW9uID0gKHRoaXMuX2R1cmF0aW9uID4gNTApO1xyXG4gICAgdGhpcy5fYW5pbWF0ZVpvb20gPSBCb29sZWFuKHRoaXMuX3RodW1iQm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoc2xpZGUuY29udGVudCAmJiBzbGlkZS5jb250ZW50LnVzZVBsYWNlaG9sZGVyKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICghdGhpcy5pc0Nsb3NpbmcgfHwgIXBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSk7XHJcbiAgICBpZiAoIXRoaXMuX2FuaW1hdGVab29tKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSA9IHRydWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgICBzbGlkZS56b29tQW5kUGFuVG9Jbml0aWFsKCk7XHJcbiAgICAgICAgc2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSBvcHRpb25zLnNob3dIaWRlT3BhY2l0eTtcclxuICAgIH1cclxuICAgIHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgPSAhdGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5ICYmIHRoaXMucHN3cC5vcHRpb25zLmJnT3BhY2l0eSA+IE1JTl9PUEFDSVRZO1xyXG4gICAgdGhpcy5fb3BhY2l0eUVsZW1lbnQgPSB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPyBwc3dwLmVsZW1lbnQgOiBwc3dwLmJnO1xyXG5cclxuICAgIGlmICghdGhpcy5fdXNlQW5pbWF0aW9uKSB7XHJcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVpvb20gPSBmYWxzZTtcclxuICAgICAgdGhpcy5fYW5pbWF0ZUJnT3BhY2l0eSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSB0cnVlO1xyXG4gICAgICBpZiAodGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgICBwc3dwLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XHJcbiAgICAgICAgcHN3cC5hcHBseUJnT3BhY2l0eSgxKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVab29tICYmIHRoaXMuX3RodW1iQm91bmRzICYmIHRoaXMuX3RodW1iQm91bmRzLmlubmVyUmVjdCkge1xyXG4gICAgICAvLyBQcm9wZXJ0aWVzIGFyZSB1c2VkIHdoZW4gYW5pbWF0aW9uIGZyb20gY3JvcHBlZCB0aHVtYm5haWxcclxuICAgICAgdGhpcy5fY3JvcHBlZFpvb20gPSB0cnVlO1xyXG4gICAgICB0aGlzLl9jcm9wQ29udGFpbmVyMSA9IHRoaXMucHN3cC5jb250YWluZXI7XHJcbiAgICAgIHRoaXMuX2Nyb3BDb250YWluZXIyID0gdGhpcy5wc3dwLmN1cnJTbGlkZS5ob2xkZXJFbGVtZW50O1xyXG5cclxuICAgICAgcHN3cC5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgcHN3cC5jb250YWluZXIuc3R5bGUud2lkdGggPSBwc3dwLnZpZXdwb3J0U2l6ZS54ICsgJ3B4JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2Nyb3BwZWRab29tID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNPcGVuaW5nKSB7XHJcbiAgICAgIC8vIEFwcGx5IHN0eWxlcyBiZWZvcmUgb3BlbmluZyB0cmFuc2l0aW9uXHJcbiAgICAgIGlmICh0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkpIHtcclxuICAgICAgICBwc3dwLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XHJcbiAgICAgICAgcHN3cC5hcHBseUJnT3BhY2l0eSgxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZUJnT3BhY2l0eSkge1xyXG4gICAgICAgICAgcHN3cC5iZy5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKE1JTl9PUEFDSVRZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHN3cC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9hbmltYXRlWm9vbSkge1xyXG4gICAgICAgIHRoaXMuX3NldENsb3NlZFN0YXRlWm9vbVBhbigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgLy8gdGVsbCBicm93c2VyIHRoYXQgd2UgcGxhbiB0byBhbmltYXRlIHRoZSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xyXG5cclxuICAgICAgICAgIC8vIGhpZGUgcGxhY2Vob2xkZXIgdG8gYWxsb3cgaGlkaW5nIG9mXHJcbiAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IG92ZXJsYXAgaXQgKHN1Y2ggYXMgaWNvbnMgb3ZlciB0aGUgdGh1bWJuYWlsKVxyXG4gICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbG9zaW5nKSB7XHJcbiAgICAgIC8vIGhpZGUgbmVhcmJ5IHNsaWRlcyB0byBtYWtlIHN1cmUgdGhhdFxyXG4gICAgICAvLyB0aGV5IGFyZSBub3QgcGFpbnRlZCBkdXJpbmcgdGhlIHRyYW5zaXRpb25cclxuICAgICAgcHN3cC5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgIHBzd3AubWFpblNjcm9sbC5pdGVtSG9sZGVyc1syXS5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2Nyb3BwZWRab29tKSB7XHJcbiAgICAgICAgaWYgKHBzd3AubWFpblNjcm9sbC54ICE9PSAwKSB7XHJcbiAgICAgICAgICAvLyBzaGlmdCB0aGUgbWFpbiBzY3JvbGxlciB0byB6ZXJvIHBvc2l0aW9uXHJcbiAgICAgICAgICBwc3dwLm1haW5TY3JvbGwucmVzZXRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgcHN3cC5tYWluU2Nyb2xsLnJlc2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3N0YXJ0KCkge1xyXG4gICAgaWYgKHRoaXMuaXNPcGVuaW5nXHJcbiAgICAgICAgJiYgdGhpcy5fdXNlQW5pbWF0aW9uXHJcbiAgICAgICAgJiYgdGhpcy5fcGxhY2Vob2xkZXJcclxuICAgICAgICAmJiB0aGlzLl9wbGFjZWhvbGRlci50YWdOYW1lID09PSAnSU1HJykge1xyXG4gICAgICAvLyBUbyBlbnN1cmUgc21vb3RoIGFuaW1hdGlvblxyXG4gICAgICAvLyB3ZSB3YWl0IHRpbGwgdGhlIGN1cnJlbnQgc2xpZGUgaW1hZ2UgcGxhY2Vob2xkZXIgaXMgZGVjb2RlZCxcclxuICAgICAgLy8gYnV0IG5vIGxvbmdlciB0aGFuIDI1MG1zLFxyXG4gICAgICAvLyBhbmQgbm8gc2hvcnRlciB0aGFuIDUwbXNcclxuICAgICAgLy8gKGp1c3QgdXNpbmcgcmVxdWVzdGFuaW1hdGlvbmZyYW1lIGlzIG5vdCBlbm91Z2ggaW4gRmlyZWZveCxcclxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uKVxyXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIGxldCBkZWNvZGVkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGlzRGVsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgIGRlY29kZUltYWdlKC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKHRoaXMuX3BsYWNlaG9sZGVyKSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICBkZWNvZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGlmICghaXNEZWxheWluZykge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpc0RlbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoZGVjb2RlZCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgNTApO1xyXG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMjUwKTtcclxuICAgICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLl9pbml0aWF0ZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2luaXRpYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaW5pdGlhdGUoKSB7XHJcbiAgICB0aGlzLnBzd3AuZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1wc3dwLXRyYW5zaXRpb24tZHVyYXRpb24nLCB0aGlzLl9kdXJhdGlvbiArICdtcycpO1xyXG5cclxuICAgIHRoaXMucHN3cC5kaXNwYXRjaChcclxuICAgICAgdGhpcy5pc09wZW5pbmcgPyAnb3BlbmluZ0FuaW1hdGlvblN0YXJ0JyA6ICdjbG9zaW5nQW5pbWF0aW9uU3RhcnQnXHJcbiAgICApO1xyXG5cclxuICAgIC8vIGxlZ2FjeSBldmVudFxyXG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKFxyXG4gICAgICAvKiogQHR5cGUgeydpbml0aWFsWm9vbUluJyB8ICdpbml0aWFsWm9vbU91dCd9ICovXHJcbiAgICAgICgnaW5pdGlhbFpvb20nICsgKHRoaXMuaXNPcGVuaW5nID8gJ0luJyA6ICdPdXQnKSlcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5wc3dwLmVsZW1lbnQuY2xhc3NMaXN0W3RoaXMuaXNPcGVuaW5nID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ3Bzd3AtLXVpLXZpc2libGUnKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc09wZW5pbmcpIHtcclxuICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgLy8gdW5oaWRlIHRoZSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvT3BlblN0YXRlKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbG9zaW5nKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVUb0Nsb3NlZFN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl91c2VBbmltYXRpb24pIHtcclxuICAgICAgdGhpcy5fb25BbmltYXRpb25Db21wbGV0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uQW5pbWF0aW9uQ29tcGxldGUoKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICB0aGlzLmlzT3BlbiA9IHRoaXMuaXNPcGVuaW5nO1xyXG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRoaXMuaXNDbG9zaW5nO1xyXG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XHJcblxyXG4gICAgcHN3cC5kaXNwYXRjaChcclxuICAgICAgdGhpcy5pc09wZW4gPyAnb3BlbmluZ0FuaW1hdGlvbkVuZCcgOiAnY2xvc2luZ0FuaW1hdGlvbkVuZCdcclxuICAgICk7XHJcblxyXG4gICAgLy8gbGVnYWN5IGV2ZW50XHJcbiAgICBwc3dwLmRpc3BhdGNoKFxyXG4gICAgICAvKiogQHR5cGUgeydpbml0aWFsWm9vbUluRW5kJyB8ICdpbml0aWFsWm9vbU91dEVuZCd9ICovXHJcbiAgICAgICgnaW5pdGlhbFpvb20nICsgKHRoaXMuaXNPcGVuID8gJ0luRW5kJyA6ICdPdXRFbmQnKSlcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcclxuICAgICAgcHN3cC5kZXN0cm95KCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuKSB7XHJcbiAgICAgIGlmICh0aGlzLl9hbmltYXRlWm9vbSkge1xyXG4gICAgICAgIHBzd3AuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xyXG4gICAgICAgIHBzd3AuY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICB9XHJcbiAgICAgIHBzd3AuY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hbmltYXRlVG9PcGVuU3RhdGUoKSB7XHJcbiAgICBjb25zdCB7IHBzd3AgfSA9IHRoaXM7XHJcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVpvb20pIHtcclxuICAgICAgaWYgKHRoaXMuX2Nyb3BwZWRab29tKSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKHRoaXMuX2Nyb3BDb250YWluZXIxLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyh0aGlzLl9jcm9wQ29udGFpbmVyMiwgJ3RyYW5zZm9ybScsICdub25lJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBzd3AuY3VyclNsaWRlLnpvb21BbmRQYW5Ub0luaXRpYWwoKTtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvKFxyXG4gICAgICAgIHBzd3AuY3VyclNsaWRlLmNvbnRhaW5lcixcclxuICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICBwc3dwLmN1cnJTbGlkZS5nZXRDdXJyZW50VHJhbnNmb3JtKClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fYW5pbWF0ZUJnT3BhY2l0eSkge1xyXG4gICAgICB0aGlzLl9hbmltYXRlVG8ocHN3cC5iZywgJ29wYWNpdHknLCBTdHJpbmcocHN3cC5vcHRpb25zLmJnT3BhY2l0eSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkpIHtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuZWxlbWVudCwgJ29wYWNpdHknLCAnMScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2FuaW1hdGVUb0Nsb3NlZFN0YXRlKCkge1xyXG4gICAgY29uc3QgeyBwc3dwIH0gPSB0aGlzO1xyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRlWm9vbSkge1xyXG4gICAgICB0aGlzLl9zZXRDbG9zZWRTdGF0ZVpvb21QYW4odHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVCZ09wYWNpdHlcclxuICAgICAgICAmJiBwc3dwLmJnT3BhY2l0eSA+IDAuMDEpIHsgLy8gZG8gbm90IGFuaW1hdGUgb3BhY2l0eSBpZiBpdCdzIGFscmVhZHkgYXQgMFxyXG4gICAgICB0aGlzLl9hbmltYXRlVG8ocHN3cC5iZywgJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkpIHtcclxuICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuZWxlbWVudCwgJ29wYWNpdHknLCAnMCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gYW5pbWF0ZVxyXG4gICAqL1xyXG4gIF9zZXRDbG9zZWRTdGF0ZVpvb21QYW4oYW5pbWF0ZSkge1xyXG4gICAgaWYgKCF0aGlzLl90aHVtYkJvdW5kcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHsgcHN3cCB9ID0gdGhpcztcclxuICAgIGNvbnN0IHsgaW5uZXJSZWN0IH0gPSB0aGlzLl90aHVtYkJvdW5kcztcclxuICAgIGNvbnN0IHsgY3VyclNsaWRlLCB2aWV3cG9ydFNpemUgfSA9IHBzd3A7XHJcblxyXG4gICAgaWYgKHRoaXMuX2Nyb3BwZWRab29tKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lck9uZVBhblggPSAtdmlld3BvcnRTaXplLnggKyAodGhpcy5fdGh1bWJCb3VuZHMueCAtIGlubmVyUmVjdC54KSArIGlubmVyUmVjdC53O1xyXG4gICAgICBjb25zdCBjb250YWluZXJPbmVQYW5ZID0gLXZpZXdwb3J0U2l6ZS55ICsgKHRoaXMuX3RodW1iQm91bmRzLnkgLSBpbm5lclJlY3QueSkgKyBpbm5lclJlY3QuaDtcclxuICAgICAgY29uc3QgY29udGFpbmVyVHdvUGFuWCA9IHZpZXdwb3J0U2l6ZS54IC0gaW5uZXJSZWN0Lnc7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclR3b1BhblkgPSB2aWV3cG9ydFNpemUueSAtIGlubmVyUmVjdC5oO1xyXG5cclxuXHJcbiAgICAgIGlmIChhbmltYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKFxyXG4gICAgICAgICAgdGhpcy5fY3JvcENvbnRhaW5lcjEsXHJcbiAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgIHRvVHJhbnNmb3JtU3RyaW5nKGNvbnRhaW5lck9uZVBhblgsIGNvbnRhaW5lck9uZVBhblkpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKFxyXG4gICAgICAgICAgdGhpcy5fY3JvcENvbnRhaW5lcjIsXHJcbiAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgIHRvVHJhbnNmb3JtU3RyaW5nKGNvbnRhaW5lclR3b1BhblgsIGNvbnRhaW5lclR3b1BhblkpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRUcmFuc2Zvcm0odGhpcy5fY3JvcENvbnRhaW5lcjEsIGNvbnRhaW5lck9uZVBhblgsIGNvbnRhaW5lck9uZVBhblkpO1xyXG4gICAgICAgIHNldFRyYW5zZm9ybSh0aGlzLl9jcm9wQ29udGFpbmVyMiwgY29udGFpbmVyVHdvUGFuWCwgY29udGFpbmVyVHdvUGFuWSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlcXVhbGl6ZVBvaW50cyhjdXJyU2xpZGUucGFuLCBpbm5lclJlY3QgfHwgdGhpcy5fdGh1bWJCb3VuZHMpO1xyXG4gICAgY3VyclNsaWRlLmN1cnJab29tTGV2ZWwgPSB0aGlzLl90aHVtYkJvdW5kcy53IC8gY3VyclNsaWRlLndpZHRoO1xyXG5cclxuICAgIGlmIChhbmltYXRlKSB7XHJcbiAgICAgIHRoaXMuX2FuaW1hdGVUbyhjdXJyU2xpZGUuY29udGFpbmVyLCAndHJhbnNmb3JtJywgY3VyclNsaWRlLmdldEN1cnJlbnRUcmFuc2Zvcm0oKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHsndHJhbnNmb3JtJyB8ICdvcGFjaXR5J30gcHJvcFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wVmFsdWVcclxuICAgKi9cclxuICBfYW5pbWF0ZVRvKHRhcmdldCwgcHJvcCwgcHJvcFZhbHVlKSB7XHJcbiAgICBpZiAoIXRoaXMuX2R1cmF0aW9uKSB7XHJcbiAgICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IHByb3BWYWx1ZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgYW5pbWF0aW9ucyB9ID0gdGhpcy5wc3dwO1xyXG4gICAgLyoqIEB0eXBlIHtBbmltYXRpb25Qcm9wc30gKi9cclxuICAgIGNvbnN0IGFuaW1Qcm9wcyA9IHtcclxuICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxyXG4gICAgICBlYXNpbmc6IHRoaXMucHN3cC5vcHRpb25zLmVhc2luZyxcclxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgIGlmICghYW5pbWF0aW9ucy5hY3RpdmVBbmltYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgdGhpcy5fb25BbmltYXRpb25Db21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgfTtcclxuICAgIGFuaW1Qcm9wc1twcm9wXSA9IHByb3BWYWx1ZTtcclxuICAgIGFuaW1hdGlvbnMuc3RhcnRUcmFuc2l0aW9uKGFuaW1Qcm9wcyk7XHJcbiAgfVxyXG59XG5cbi8qKlxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3R5cGVzLmpzJykuVHlwZTxUPn0gVHlwZTxUPlxyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL3NsaWRlLmpzJykuU2xpZGVEYXRhfSBTbGlkZURhdGEgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUvem9vbS1sZXZlbC5qcycpLlpvb21MZXZlbE9wdGlvbn0gWm9vbUxldmVsT3B0aW9uICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3VpL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL21haW4tc2Nyb2xsLmpzJykuSXRlbUhvbGRlcn0gSXRlbUhvbGRlciAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL2V2ZW50YWJsZS5qcycpLlBob3RvU3dpcGVFdmVudHNNYXB9IFBob3RvU3dpcGVFdmVudHNNYXAgKi9cclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5QaG90b1N3aXBlRmlsdGVyc01hcH0gUGhvdG9Td2lwZUZpbHRlcnNNYXAgKi9cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5FdmVudENhbGxiYWNrPFQ+fSBFdmVudENhbGxiYWNrPFQ+XHJcbiAqL1xyXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL2V2ZW50YWJsZS5qcycpLkF1Z21lbnRlZEV2ZW50PFQ+fSBBdWdtZW50ZWRFdmVudDxUPlxyXG4gKi9cclxuXHJcbi8qKiBAdHlwZWRlZiB7eyB4PzogbnVtYmVyOyB5PzogbnVtYmVyOyBpZD86IHN0cmluZyB8IG51bWJlciB9fSBQb2ludCAqL1xyXG4vKiogQHR5cGVkZWYge3sgeD86IG51bWJlcjsgeT86IG51bWJlciB9fSBTaXplICovXHJcbi8qKiBAdHlwZWRlZiB7eyB0b3A6IG51bWJlcjsgYm90dG9tOiBudW1iZXI7IGxlZnQ6IG51bWJlcjsgcmlnaHQ6IG51bWJlciB9fSBQYWRkaW5nICovXHJcbi8qKiBAdHlwZWRlZiB7U2xpZGVEYXRhW119IERhdGFTb3VyY2VBcnJheSAqL1xyXG4vKiogQHR5cGVkZWYge3sgZ2FsbGVyeTogSFRNTEVsZW1lbnQ7IGl0ZW1zPzogSFRNTEVsZW1lbnRbXSB9fSBEYXRhU291cmNlT2JqZWN0ICovXHJcbi8qKiBAdHlwZWRlZiB7RGF0YVNvdXJjZUFycmF5IHwgRGF0YVNvdXJjZU9iamVjdH0gRGF0YVNvdXJjZSAqL1xyXG4vKiogQHR5cGVkZWYgeyhwb2ludDogUG9pbnQsIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gdm9pZH0gQWN0aW9uRm4gKi9cclxuLyoqIEB0eXBlZGVmIHsnY2xvc2UnIHwgJ25leHQnIHwgJ3pvb20nIHwgJ3pvb20tb3ItY2xvc2UnIHwgJ3RvZ2dsZS1jb250cm9scyd9IEFjdGlvblR5cGUgKi9cclxuLyoqIEB0eXBlZGVmIHtUeXBlPFBob3RvU3dpcGU+IHwgeyBkZWZhdWx0OiBUeXBlPFBob3RvU3dpcGU+IH19IFBob3RvU3dpcGVNb2R1bGUgKi9cclxuLyoqIEB0eXBlZGVmIHtQaG90b1N3aXBlTW9kdWxlIHwgUHJvbWlzZTxQaG90b1N3aXBlTW9kdWxlPiB8ICgoKSA9PiBQcm9taXNlPFBob3RvU3dpcGVNb2R1bGU+KX0gUGhvdG9Td2lwZU1vZHVsZU9wdGlvbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtzdHJpbmcgfCBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PiB8IEhUTUxFbGVtZW50W10gfCBIVE1MRWxlbWVudH0gRWxlbWVudFByb3ZpZGVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBob3RvU3dpcGVPcHRpb25zIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vb3B0aW9ucy9cclxuICpcclxuICogQHByb3Age0RhdGFTb3VyY2U9fSBkYXRhU291cmNlXHJcbiAqIFBhc3MgYW4gYXJyYXkgb2YgYW55IGl0ZW1zIHZpYSBkYXRhU291cmNlIG9wdGlvbi4gSXRzIGxlbmd0aCB3aWxsIGRldGVybWluZSBhbW91bnQgb2Ygc2xpZGVzXHJcbiAqICh3aGljaCBtYXkgYmUgbW9kaWZpZWQgZnVydGhlciBmcm9tIG51bUl0ZW1zIGV2ZW50KS5cclxuICpcclxuICogRWFjaCBpdGVtIHNob3VsZCBjb250YWluIGRhdGEgdGhhdCB5b3UgbmVlZCB0byBnZW5lcmF0ZSBzbGlkZVxyXG4gKiAoZm9yIGltYWdlIHNsaWRlIGl0IHdvdWxkIGJlIHNyYyAoaW1hZ2UgVVJMKSwgd2lkdGggKGltYWdlIHdpZHRoKSwgaGVpZ2h0LCBzcmNzZXQsIGFsdCkuXHJcbiAqXHJcbiAqIElmIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBwcmVzZW50IGluIHlvdXIgaW5pdGlhbCBhcnJheSwgeW91IG1heSBcInByZS1wYXJzZVwiIGVhY2ggaXRlbSBmcm9tIGl0ZW1EYXRhIGZpbHRlci5cclxuICpcclxuICogQHByb3Age251bWJlcj19IGJnT3BhY2l0eVxyXG4gKiBCYWNrZ3JvdW5kIGJhY2tkcm9wIG9wYWNpdHksIGFsd2F5cyBkZWZpbmUgaXQgdmlhIHRoaXMgb3B0aW9uIGFuZCBub3QgdmlhIENTUyByZ2JhIGNvbG9yLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyPX0gc3BhY2luZ1xyXG4gKiBTcGFjaW5nIGJldHdlZW4gc2xpZGVzLiBEZWZpbmVkIGFzIHJhdGlvIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCB3aWR0aCAoMC4xID0gMTAlIG9mIHZpZXdwb3J0KS5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW49fSBhbGxvd1BhblRvTmV4dFxyXG4gKiBBbGxvdyBzd2lwZSBuYXZpZ2F0aW9uIHRvIHRoZSBuZXh0IHNsaWRlIHdoZW4gdGhlIGN1cnJlbnQgc2xpZGUgaXMgem9vbWVkLiBEb2VzIG5vdCBhcHBseSB0byBtb3VzZSBldmVudHMuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gbG9vcFxyXG4gKiBJZiBzZXQgdG8gdHJ1ZSB5b3UnbGwgYmUgYWJsZSB0byBzd2lwZSBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdCBpbWFnZS5cclxuICogT3B0aW9uIGlzIGFsd2F5cyBmYWxzZSB3aGVuIHRoZXJlIGFyZSBsZXNzIHRoYW4gMyBzbGlkZXMuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gd2hlZWxUb1pvb21cclxuICogQnkgZGVmYXVsdCBQaG90b1N3aXBlIHpvb21zIGltYWdlIHdpdGggY3RybC13aGVlbCwgaWYgeW91IGVuYWJsZSB0aGlzIG9wdGlvbiAtIGltYWdlIHdpbGwgem9vbSBqdXN0IHZpYSB3aGVlbC5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW49fSBwaW5jaFRvQ2xvc2VcclxuICogUGluY2ggdG91Y2ggZ2VzdHVyZSB0byBjbG9zZSB0aGUgZ2FsbGVyeS5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW49fSBjbG9zZU9uVmVydGljYWxEcmFnXHJcbiAqIFZlcnRpY2FsIGRyYWcgZ2VzdHVyZSB0byBjbG9zZSB0aGUgUGhvdG9Td2lwZS5cclxuICpcclxuICogQHByb3Age1BhZGRpbmc9fSBwYWRkaW5nXHJcbiAqIFNsaWRlIGFyZWEgcGFkZGluZyAoaW4gcGl4ZWxzKS5cclxuICpcclxuICogQHByb3Ageyh2aWV3cG9ydFNpemU6IFNpemUsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IFBhZGRpbmd9IFtwYWRkaW5nRm5dXHJcbiAqIFRoZSBvcHRpb24gaXMgY2hlY2tlZCBmcmVxdWVudGx5LCBzbyBtYWtlIHN1cmUgaXQncyBwZXJmb3JtYW50LiBPdmVycmlkZXMgcGFkZGluZyBvcHRpb24gaWYgZGVmaW5lZC4gRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIEBwcm9wIHtudW1iZXIgfCBmYWxzZX0gW2hpZGVBbmltYXRpb25EdXJhdGlvbl1cclxuICogVHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMsIGNhbiBiZSAwLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyIHwgZmFsc2V9IFtzaG93QW5pbWF0aW9uRHVyYXRpb25dXHJcbiAqIFRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLCBjYW4gYmUgMC5cclxuICpcclxuICogQHByb3Age251bWJlciB8IGZhbHNlfSBbem9vbUFuaW1hdGlvbkR1cmF0aW9uXVxyXG4gKiBUcmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcywgY2FuIGJlIDAuXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBlYXNpbmdcclxuICogU3RyaW5nLCAnY3ViaWMtYmV6aWVyKC40LDAsLjIyLDEpJy4gQ1NTIGVhc2luZyBmdW5jdGlvbiBmb3Igb3Blbi9jbG9zZS96b29tIHRyYW5zaXRpb25zLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGVzY0tleVxyXG4gKiBFc2Mga2V5IHRvIGNsb3NlLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGFycm93S2V5c1xyXG4gKiBMZWZ0L3JpZ2h0IGFycm93IGtleXMgZm9yIG5hdmlnYXRpb24uXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gcmV0dXJuRm9jdXNcclxuICogUmVzdG9yZSBmb2N1cyB0aGUgbGFzdCBhY3RpdmUgZWxlbWVudCBhZnRlciBQaG90b1N3aXBlIGlzIGNsb3NlZC5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW49fSBjbGlja1RvQ2xvc2VOb25ab29tYWJsZVxyXG4gKiBJZiBpbWFnZSBpcyBub3Qgem9vbWFibGUgKGZvciBleGFtcGxlLCBzbWFsbGVyIHRoYW4gdmlld3BvcnQpIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgb24gaXQuXHJcbiAqXHJcbiAqIEBwcm9wIHtBY3Rpb25UeXBlIHwgQWN0aW9uRm4gfCBmYWxzZX0gW2ltYWdlQ2xpY2tBY3Rpb25dXHJcbiAqIFJlZmVyIHRvIGNsaWNrIGFuZCB0YXAgYWN0aW9ucyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7QWN0aW9uVHlwZSB8IEFjdGlvbkZuIHwgZmFsc2V9IFtiZ0NsaWNrQWN0aW9uXVxyXG4gKiBSZWZlciB0byBjbGljayBhbmQgdGFwIGFjdGlvbnMgcGFnZS5cclxuICpcclxuICogQHByb3Age0FjdGlvblR5cGUgfCBBY3Rpb25GbiB8IGZhbHNlfSBbdGFwQWN0aW9uXVxyXG4gKiBSZWZlciB0byBjbGljayBhbmQgdGFwIGFjdGlvbnMgcGFnZS5cclxuICpcclxuICogQHByb3Age0FjdGlvblR5cGUgfCBBY3Rpb25GbiB8IGZhbHNlfSBbZG91YmxlVGFwQWN0aW9uXVxyXG4gKiBSZWZlciB0byBjbGljayBhbmQgdGFwIGFjdGlvbnMgcGFnZS5cclxuICpcclxuICogQHByb3Age251bWJlcj19IHByZWxvYWRlckRlbGF5XHJcbiAqIERlbGF5IGJlZm9yZSB0aGUgbG9hZGluZyBpbmRpY2F0b3Igd2lsbCBiZSBkaXNwbGF5ZWQsXHJcbiAqIGlmIGltYWdlIGlzIGxvYWRlZCBkdXJpbmcgaXQgLSB0aGUgaW5kaWNhdG9yIHdpbGwgbm90IGJlIGRpc3BsYXllZCBhdCBhbGwuIENhbiBiZSB6ZXJvLlxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gaW5kZXhJbmRpY2F0b3JTZXBcclxuICogVXNlZCBmb3Igc2xpZGUgY291bnQgaW5kaWNhdG9yIChcIjEgb2YgMTAgXCIpLlxyXG4gKlxyXG4gKiBAcHJvcCB7KG9wdGlvbnM6IFBob3RvU3dpcGVPcHRpb25zLCBwc3dwOiBQaG90b1N3aXBlKSA9PiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH19IFtnZXRWaWV3cG9ydFNpemVGbl1cclxuICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gc2xpZGUgdmlld3BvcnQgd2lkdGggYW5kIGhlaWdodCwgaW4gZm9ybWF0IHt4OiAxMDAsIHk6IDEwMH0uXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBlcnJvck1zZ1xyXG4gKiBNZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB0aGUgaW1hZ2Ugd2Fzbid0IGFibGUgdG8gbG9hZC4gSWYgeW91IG5lZWQgdG8gZGlzcGxheSBIVE1MIC0gdXNlIGNvbnRlbnRFcnJvckVsZW1lbnQgZmlsdGVyLlxyXG4gKlxyXG4gKiBAcHJvcCB7W251bWJlciwgbnVtYmVyXT19IHByZWxvYWRcclxuICogTGF6eSBsb2FkaW5nIG9mIG5lYXJieSBzbGlkZXMgYmFzZWQgb24gZGlyZWN0aW9uIG9mIG1vdmVtZW50LiBTaG91bGQgYmUgYW4gYXJyYXkgd2l0aCB0d28gaW50ZWdlcnMsXHJcbiAqIGZpcnN0IG9uZSAtIG51bWJlciBvZiBpdGVtcyB0byBwcmVsb2FkIGJlZm9yZSB0aGUgY3VycmVudCBpbWFnZSwgc2Vjb25kIG9uZSAtIGFmdGVyIHRoZSBjdXJyZW50IGltYWdlLlxyXG4gKiBUd28gbmVhcmJ5IGltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZC5cclxuICpcclxuICogQHByb3Age3N0cmluZz19IG1haW5DbGFzc1xyXG4gKiBDbGFzcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBvZiBQaG90b1N3aXBlLCBtYXkgY29udGFpbiBtdWx0aXBsZSBzZXBhcmF0ZWQgYnkgc3BhY2UuXHJcbiAqIEV4YW1wbGUgb24gU3R5bGluZyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnQ9fSBhcHBlbmRUb0VsXHJcbiAqIEVsZW1lbnQgdG8gd2hpY2ggUGhvdG9Td2lwZSBkaWFsb2cgd2lsbCBiZSBhcHBlbmRlZCB3aGVuIGl0IG9wZW5zLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyPX0gbWF4V2lkdGhUb0FuaW1hdGVcclxuICogTWF4aW11bSB3aWR0aCBvZiBpbWFnZSB0byBhbmltYXRlLCBpZiBpbml0aWFsIHJlbmRlcmVkIGltYWdlIHdpZHRoXHJcbiAqIGlzIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUgLSB0aGUgb3BlbmluZy9jbG9zaW5nIHRyYW5zaXRpb24gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRpc2FibGVkLlxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gY2xvc2VUaXRsZVxyXG4gKiBUcmFuc2xhdGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gem9vbVRpdGxlXHJcbiAqIFRyYW5zbGF0aW5nXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBhcnJvd1ByZXZUaXRsZVxyXG4gKiBUcmFuc2xhdGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gYXJyb3dOZXh0VGl0bGVcclxuICogVHJhbnNsYXRpbmdcclxuICpcclxuICogQHByb3Ageyd6b29tJyB8ICdmYWRlJyB8ICdub25lJ30gW3Nob3dIaWRlQW5pbWF0aW9uVHlwZV1cclxuICogVG8gYWRqdXN0IG9wZW5pbmcgb3IgY2xvc2luZyB0cmFuc2l0aW9uIHR5cGUgdXNlIGxpZ2h0Ym94IG9wdGlvbiBgc2hvd0hpZGVBbmltYXRpb25UeXBlYCAoYFN0cmluZ2ApLlxyXG4gKiBJdCBzdXBwb3J0cyB0aHJlZSB2YWx1ZXMgLSBgem9vbWAgKGRlZmF1bHQpLCBgZmFkZWAgKGRlZmF1bHQgaWYgdGhlcmUgaXMgbm8gdGh1bWJuYWlsKSBhbmQgYG5vbmVgLlxyXG4gKlxyXG4gKiBBbmltYXRpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGRpc2FibGVkIGlmIHVzZXIgYChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpYC5cclxuICpcclxuICogQHByb3Age251bWJlcj19IGluZGV4XHJcbiAqIERlZmluZXMgc3RhcnQgc2xpZGUgaW5kZXguXHJcbiAqXHJcbiAqIEBwcm9wIHsoZTogTW91c2VFdmVudCkgPT4gbnVtYmVyfSBbZ2V0Q2xpY2tlZEluZGV4Rm5dXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gYXJyb3dQcmV2XHJcbiAqIEBwcm9wIHtib29sZWFuPX0gYXJyb3dOZXh0XHJcbiAqIEBwcm9wIHtib29sZWFuPX0gem9vbVxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IGNsb3NlXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gY291bnRlclxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gYXJyb3dQcmV2U1ZHXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBhcnJvd05leHRTVkdcclxuICogQHByb3Age3N0cmluZz19IHpvb21TVkdcclxuICogQHByb3Age3N0cmluZz19IGNsb3NlU1ZHXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBjb3VudGVyU1ZHXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBhcnJvd1ByZXZUaXRsZVxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gYXJyb3dOZXh0VGl0bGVcclxuICogQHByb3Age3N0cmluZz19IHpvb21UaXRsZVxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gY2xvc2VUaXRsZVxyXG4gKiBAcHJvcCB7c3RyaW5nPX0gY291bnRlclRpdGxlXHJcbiAqXHJcbiAqIEBwcm9wIHtab29tTGV2ZWxPcHRpb249fSBpbml0aWFsWm9vbUxldmVsXHJcbiAqIEBwcm9wIHtab29tTGV2ZWxPcHRpb249fSBzZWNvbmRhcnlab29tTGV2ZWxcclxuICogQHByb3Age1pvb21MZXZlbE9wdGlvbj19IG1heFpvb21MZXZlbFxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IG1vdXNlTW92ZVBhblxyXG4gKiBAcHJvcCB7UG9pbnQgfCBudWxsfSBbaW5pdGlhbFBvaW50ZXJQb3NdXHJcbiAqIEBwcm9wIHtib29sZWFuPX0gc2hvd0hpZGVPcGFjaXR5XHJcbiAqXHJcbiAqIEBwcm9wIHtQaG90b1N3aXBlTW9kdWxlT3B0aW9ufSBbcHN3cE1vZHVsZV1cclxuICogQHByb3AgeygpID0+IFByb21pc2U8YW55Pn0gW29wZW5Qcm9taXNlXVxyXG4gKiBAcHJvcCB7Ym9vbGVhbj19IHByZWxvYWRGaXJzdFNsaWRlXHJcbiAqIEBwcm9wIHtFbGVtZW50UHJvdmlkZXI9fSBnYWxsZXJ5XHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBnYWxsZXJ5U2VsZWN0b3JcclxuICogQHByb3Age0VsZW1lbnRQcm92aWRlcj19IGNoaWxkcmVuXHJcbiAqIEBwcm9wIHtzdHJpbmc9fSBjaGlsZFNlbGVjdG9yXHJcbiAqIEBwcm9wIHtzdHJpbmcgfCBmYWxzZX0gW3RodW1iU2VsZWN0b3JdXHJcbiAqL1xyXG5cclxuLyoqIEB0eXBlIHtQaG90b1N3aXBlT3B0aW9uc30gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgYWxsb3dQYW5Ub05leHQ6IHRydWUsXHJcbiAgc3BhY2luZzogMC4xLFxyXG4gIGxvb3A6IHRydWUsXHJcbiAgcGluY2hUb0Nsb3NlOiB0cnVlLFxyXG4gIGNsb3NlT25WZXJ0aWNhbERyYWc6IHRydWUsXHJcbiAgaGlkZUFuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXHJcbiAgc2hvd0FuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXHJcbiAgem9vbUFuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXHJcbiAgZXNjS2V5OiB0cnVlLFxyXG4gIGFycm93S2V5czogdHJ1ZSxcclxuICByZXR1cm5Gb2N1czogdHJ1ZSxcclxuICBtYXhXaWR0aFRvQW5pbWF0ZTogNDAwMCxcclxuICBjbGlja1RvQ2xvc2VOb25ab29tYWJsZTogdHJ1ZSxcclxuICBpbWFnZUNsaWNrQWN0aW9uOiAnem9vbS1vci1jbG9zZScsXHJcbiAgYmdDbGlja0FjdGlvbjogJ2Nsb3NlJyxcclxuICB0YXBBY3Rpb246ICd0b2dnbGUtY29udHJvbHMnLFxyXG4gIGRvdWJsZVRhcEFjdGlvbjogJ3pvb20nLFxyXG4gIGluZGV4SW5kaWNhdG9yU2VwOiAnIC8gJyxcclxuICBwcmVsb2FkZXJEZWxheTogMjAwMCxcclxuICBiZ09wYWNpdHk6IDAuOCxcclxuXHJcbiAgaW5kZXg6IDAsXHJcbiAgZXJyb3JNc2c6ICdUaGUgaW1hZ2UgY2Fubm90IGJlIGxvYWRlZCcsXHJcbiAgcHJlbG9hZDogWzEsIDJdLFxyXG4gIGVhc2luZzogJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQaG90b1N3aXBlIENvcmVcclxuICovXHJcbmNsYXNzIFBob3RvU3dpcGUgZXh0ZW5kcyBQaG90b1N3aXBlQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBvZmZzZXQgb2Ygdmlld3BvcnQgcmVsYXRpdmUgdG8gZG9jdW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7eyB4PzogbnVtYmVyOyB5PzogbnVtYmVyIH19XHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7eyB4PzogbnVtYmVyOyB5PzogbnVtYmVyIH19XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wcmV2Vmlld3BvcnRTaXplID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaXplIG9mIHNjcm9sbGFibGUgUGhvdG9Td2lwZSB2aWV3cG9ydFxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX1cclxuICAgICAqL1xyXG4gICAgdGhpcy52aWV3cG9ydFNpemUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGJhY2tncm91bmQgKGJhY2tkcm9wKSBvcGFjaXR5XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5iZ09wYWNpdHkgPSAxO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovXHJcbiAgICB0aGlzLnRvcEJhciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBET01FdmVudHMoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvbnN9ICovXHJcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucygpO1xyXG5cclxuICAgIHRoaXMubWFpblNjcm9sbCA9IG5ldyBNYWluU2Nyb2xsKHRoaXMpO1xyXG4gICAgdGhpcy5nZXN0dXJlcyA9IG5ldyBHZXN0dXJlcyh0aGlzKTtcclxuICAgIHRoaXMub3BlbmVyID0gbmV3IE9wZW5lcih0aGlzKTtcclxuICAgIHRoaXMua2V5Ym9hcmQgPSBuZXcgS2V5Ym9hcmQodGhpcyk7XHJcbiAgICB0aGlzLmNvbnRlbnRMb2FkZXIgPSBuZXcgQ29udGVudExvYWRlcih0aGlzKTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICBpZiAodGhpcy5pc09wZW4gfHwgdGhpcy5pc0Rlc3Ryb3lpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcclxuICAgIHRoaXMuZGlzcGF0Y2goJ2luaXQnKTsgLy8gbGVnYWN5XHJcbiAgICB0aGlzLmRpc3BhdGNoKCdiZWZvcmVPcGVuJyk7XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlTWFpblN0cnVjdHVyZSgpO1xyXG5cclxuICAgIC8vIGFkZCBjbGFzc2VzIHRvIHRoZSByb290IGVsZW1lbnQgb2YgUGhvdG9Td2lwZVxyXG4gICAgbGV0IHJvb3RDbGFzc2VzID0gJ3Bzd3AtLW9wZW4nO1xyXG4gICAgaWYgKHRoaXMuZ2VzdHVyZXMuc3VwcG9ydHNUb3VjaCkge1xyXG4gICAgICByb290Q2xhc3NlcyArPSAnIHBzd3AtLXRvdWNoJztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMubWFpbkNsYXNzKSB7XHJcbiAgICAgIHJvb3RDbGFzc2VzICs9ICcgJyArIHRoaXMub3B0aW9ucy5tYWluQ2xhc3M7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIHJvb3RDbGFzc2VzO1xyXG5cclxuICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5vcHRpb25zLmluZGV4IHx8IDA7XHJcbiAgICB0aGlzLnBvdGVudGlhbEluZGV4ID0gdGhpcy5jdXJySW5kZXg7XHJcbiAgICB0aGlzLmRpc3BhdGNoKCdmaXJzdFVwZGF0ZScpOyAvLyBzdGFydGluZyBpbmRleCBjYW4gYmUgbW9kaWZpZWQgaGVyZVxyXG5cclxuICAgIC8vIGluaXRpYWxpemUgc2Nyb2xsIHdoZWVsIGhhbmRsZXIgdG8gYmxvY2sgdGhlIHNjcm9sbFxyXG4gICAgdGhpcy5zY3JvbGxXaGVlbCA9IG5ldyBTY3JvbGxXaGVlbCh0aGlzKTtcclxuXHJcbiAgICAvLyBzYW5pdGl6ZSBpbmRleFxyXG4gICAgaWYgKE51bWJlci5pc05hTih0aGlzLmN1cnJJbmRleClcclxuICAgICAgICB8fCB0aGlzLmN1cnJJbmRleCA8IDBcclxuICAgICAgICB8fCB0aGlzLmN1cnJJbmRleCA+PSB0aGlzLmdldE51bUl0ZW1zKCkpIHtcclxuICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5nZXN0dXJlcy5zdXBwb3J0c1RvdWNoKSB7XHJcbiAgICAgIC8vIGVuYWJsZSBtb3VzZSBmZWF0dXJlcyBpZiBubyB0b3VjaCBzdXBwb3J0IGRldGVjdGVkXHJcbiAgICAgIHRoaXMubW91c2VEZXRlY3RlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhdXNlcyBmb3JjZWQgc3luY2hyb25vdXMgbGF5b3V0XHJcbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuXHJcbiAgICB0aGlzLm9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG5cclxuICAgIHRoaXMuX2luaXRpYWxJdGVtRGF0YSA9IHRoaXMuZ2V0SXRlbURhdGEodGhpcy5jdXJySW5kZXgpO1xyXG4gICAgdGhpcy5kaXNwYXRjaCgnZ2V0dGluZ0RhdGEnLCB7XHJcbiAgICAgIGluZGV4OiB0aGlzLmN1cnJJbmRleCxcclxuICAgICAgZGF0YTogdGhpcy5faW5pdGlhbEl0ZW1EYXRhLFxyXG4gICAgICBzbGlkZTogdW5kZWZpbmVkXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAqTGF5b3V0KiAtIGNhbGN1bGF0ZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBlbGVtZW50cyBoZXJlXHJcbiAgICB0aGlzLl9pbml0aWFsVGh1bWJCb3VuZHMgPSB0aGlzLmdldFRodW1iQm91bmRzKCk7XHJcbiAgICB0aGlzLmRpc3BhdGNoKCdpbml0aWFsTGF5b3V0Jyk7XHJcblxyXG4gICAgdGhpcy5vbignb3BlbmluZ0FuaW1hdGlvbkVuZCcsICgpID0+IHtcclxuICAgICAgdGhpcy5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblxyXG4gICAgICAvLyBBZGQgY29udGVudCB0byB0aGUgcHJldmlvdXMgYW5kIG5leHQgc2xpZGVcclxuICAgICAgdGhpcy5zZXRDb250ZW50KHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVyc1swXSwgdGhpcy5jdXJySW5kZXggLSAxKTtcclxuICAgICAgdGhpcy5zZXRDb250ZW50KHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVyc1syXSwgdGhpcy5jdXJySW5kZXggKyAxKTtcclxuXHJcbiAgICAgIHRoaXMuYXBwZW5kSGVhdnkoKTtcclxuXHJcbiAgICAgIHRoaXMuY29udGVudExvYWRlci51cGRhdGVMYXp5KCk7XHJcblxyXG4gICAgICB0aGlzLmV2ZW50cy5hZGQod2luZG93LCAncmVzaXplJywgdGhpcy5faGFuZGxlUGFnZVJlc2l6ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgdGhpcy5ldmVudHMuYWRkKHdpbmRvdywgJ3Njcm9sbCcsIHRoaXMuX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQuYmluZCh0aGlzKSk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2goJ2JpbmRFdmVudHMnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNldCBjb250ZW50IGZvciBjZW50ZXIgc2xpZGUgKGZpcnN0IHRpbWUpXHJcbiAgICB0aGlzLnNldENvbnRlbnQodGhpcy5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzFdLCB0aGlzLmN1cnJJbmRleCk7XHJcbiAgICB0aGlzLmRpc3BhdGNoKCdjaGFuZ2UnKTtcclxuXHJcbiAgICB0aGlzLm9wZW5lci5vcGVuKCk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnYWZ0ZXJJbml0Jyk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgbG9vcGVkIHNsaWRlIGluZGV4XHJcbiAgICogKGZvciBleGFtcGxlLCAtMSB3aWxsIHJldHVybiB0aGUgbGFzdCBzbGlkZSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIGdldExvb3BlZEluZGV4KGluZGV4KSB7XHJcbiAgICBjb25zdCBudW1TbGlkZXMgPSB0aGlzLmdldE51bUl0ZW1zKCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb29wKSB7XHJcbiAgICAgIGlmIChpbmRleCA+IG51bVNsaWRlcyAtIDEpIHtcclxuICAgICAgICBpbmRleCAtPSBudW1TbGlkZXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCArPSBudW1TbGlkZXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbmRleCA9IGNsYW1wKGluZGV4LCAwLCBudW1TbGlkZXMgLSAxKTtcclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbiAgfVxyXG5cclxuICBhcHBlbmRIZWF2eSgpIHtcclxuICAgIHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVycy5mb3JFYWNoKChpdGVtSG9sZGVyKSA9PiB7XHJcbiAgICAgIGlmIChpdGVtSG9sZGVyLnNsaWRlKSB7XHJcbiAgICAgICAgaXRlbUhvbGRlci5zbGlkZS5hcHBlbmRIZWF2eSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgc2xpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggTmV3IGluZGV4XHJcbiAgICovXHJcbiAgZ29UbyhpbmRleCkge1xyXG4gICAgdGhpcy5tYWluU2Nyb2xsLm1vdmVJbmRleEJ5KFxyXG4gICAgICB0aGlzLmdldExvb3BlZEluZGV4KGluZGV4KSAtIHRoaXMucG90ZW50aWFsSW5kZXhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHbyB0byB0aGUgbmV4dCBzbGlkZS5cclxuICAgKi9cclxuICBuZXh0KCkge1xyXG4gICAgdGhpcy5nb1RvKHRoaXMucG90ZW50aWFsSW5kZXggKyAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cclxuICAgKi9cclxuICBwcmV2KCkge1xyXG4gICAgdGhpcy5nb1RvKHRoaXMucG90ZW50aWFsSW5kZXggLSAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBzZWUgc2xpZGUvc2xpZGUuanMgem9vbVRvXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8U2xpZGVbJ3pvb21UbyddPn0gYXJnc1xyXG4gICAqL1xyXG4gIHpvb21UbyguLi5hcmdzKSB7XHJcbiAgICB0aGlzLmN1cnJTbGlkZS56b29tVG8oLi4uYXJncyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAc2VlIHNsaWRlL3NsaWRlLmpzIHRvZ2dsZVpvb21cclxuICAgKi9cclxuICB0b2dnbGVab29tKCkge1xyXG4gICAgdGhpcy5jdXJyU2xpZGUudG9nZ2xlWm9vbSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvc2UgdGhlIGdhbGxlcnkuXHJcbiAgICogQWZ0ZXIgY2xvc2luZyB0cmFuc2l0aW9uIGVuZHMgLSBkZXN0cm95IGl0XHJcbiAgICovXHJcbiAgY2xvc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMub3BlbmVyLmlzT3BlbiB8fCB0aGlzLmlzRGVzdHJveWluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pc0Rlc3Ryb3lpbmcgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2goJ2Nsb3NlJyk7XHJcblxyXG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCk7XHJcbiAgICB0aGlzLm9wZW5lci5jbG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgdGhlIGdhbGxlcnk6XHJcbiAgICogLSBpbnN0YW50bHkgY2xvc2VzIHRoZSBnYWxsZXJ5XHJcbiAgICogLSB1bmJpbmRzIGV2ZW50cyxcclxuICAgKiAtIGNsZWFucyBpbnRlcnZhbHMgYW5kIHRpbWVvdXRzXHJcbiAgICogLSByZW1vdmVzIGVsZW1lbnRzIGZyb20gRE9NXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGlmICghdGhpcy5pc0Rlc3Ryb3lpbmcpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLnNob3dIaWRlQW5pbWF0aW9uVHlwZSA9ICdub25lJztcclxuICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnZGVzdHJveScpO1xyXG5cclxuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNjcm9sbFdyYXAub250b3VjaG1vdmUgPSBudWxsO1xyXG4gICAgdGhpcy5zY3JvbGxXcmFwLm9udG91Y2hlbmQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnMuZm9yRWFjaCgoaXRlbUhvbGRlcikgPT4ge1xyXG4gICAgICBpZiAoaXRlbUhvbGRlci5zbGlkZSkge1xyXG4gICAgICAgIGl0ZW1Ib2xkZXIuc2xpZGUuZGVzdHJveSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRMb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoL3JlbG9hZCBjb250ZW50IG9mIGEgc2xpZGUgYnkgaXRzIGluZGV4XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2xpZGVJbmRleFxyXG4gICAqL1xyXG4gIHJlZnJlc2hTbGlkZUNvbnRlbnQoc2xpZGVJbmRleCkge1xyXG4gICAgdGhpcy5jb250ZW50TG9hZGVyLnJlbW92ZUJ5SW5kZXgoc2xpZGVJbmRleCk7XHJcbiAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnMuZm9yRWFjaCgoaXRlbUhvbGRlciwgaSkgPT4ge1xyXG4gICAgICBsZXQgcG90ZW50aWFsSG9sZGVySW5kZXggPSB0aGlzLmN1cnJTbGlkZS5pbmRleCAtIDEgKyBpO1xyXG4gICAgICBpZiAodGhpcy5jYW5Mb29wKCkpIHtcclxuICAgICAgICBwb3RlbnRpYWxIb2xkZXJJbmRleCA9IHRoaXMuZ2V0TG9vcGVkSW5kZXgocG90ZW50aWFsSG9sZGVySW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwb3RlbnRpYWxIb2xkZXJJbmRleCA9PT0gc2xpZGVJbmRleCkge1xyXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IHNsaWRlIGNvbnRlbnRcclxuICAgICAgICB0aGlzLnNldENvbnRlbnQoaXRlbUhvbGRlciwgc2xpZGVJbmRleCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGFjdGl2YXRlIHRoZSBuZXcgc2xpZGUgaWYgaXQncyBjdXJyZW50XHJcbiAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgIC8qKiBAdHlwZSB7U2xpZGV9ICovXHJcbiAgICAgICAgICB0aGlzLmN1cnJTbGlkZSA9IGl0ZW1Ib2xkZXIuc2xpZGU7XHJcbiAgICAgICAgICBpdGVtSG9sZGVyLnNsaWRlLnNldElzQWN0aXZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnY2hhbmdlJyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHNsaWRlIGNvbnRlbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SXRlbUhvbGRlcn0gaG9sZGVyIG1haW5TY3JvbGwuaXRlbUhvbGRlcnMgYXJyYXkgaXRlbVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBTbGlkZSBpbmRleFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlIElmIGNvbnRlbnQgc2hvdWxkIGJlIHNldCBldmVuIGlmIGluZGV4IHdhc24ndCBjaGFuZ2VkXHJcbiAgICovXHJcbiAgc2V0Q29udGVudChob2xkZXIsIGluZGV4LCBmb3JjZSkge1xyXG4gICAgaWYgKHRoaXMuY2FuTG9vcCgpKSB7XHJcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRMb29wZWRJbmRleChpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhvbGRlci5zbGlkZSkge1xyXG4gICAgICBpZiAoaG9sZGVyLnNsaWRlLmluZGV4ID09PSBpbmRleCAmJiAhZm9yY2UpIHtcclxuICAgICAgICAvLyBleGl0IGlmIGhvbGRlciBhbHJlYWR5IGNvbnRhaW5zIHRoaXMgc2xpZGVcclxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGNvbW1vbiB3aGVuIGp1c3QgdGhyZWUgc2xpZGVzIGFyZSB1c2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkZXN0cm95IHByZXZpb3VzIHNsaWRlXHJcbiAgICAgIGhvbGRlci5zbGlkZS5kZXN0cm95KCk7XHJcbiAgICAgIGhvbGRlci5zbGlkZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXhpdCBpZiBubyBsb29wIGFuZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICBpZiAoIXRoaXMuY2FuTG9vcCgpICYmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5nZXROdW1JdGVtcygpKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXRlbURhdGEgPSB0aGlzLmdldEl0ZW1EYXRhKGluZGV4KTtcclxuICAgIGhvbGRlci5zbGlkZSA9IG5ldyBTbGlkZShpdGVtRGF0YSwgaW5kZXgsIHRoaXMpO1xyXG5cclxuICAgIC8vIHNldCBjdXJyZW50IHNsaWRlXHJcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuY3VyckluZGV4KSB7XHJcbiAgICAgIHRoaXMuY3VyclNsaWRlID0gaG9sZGVyLnNsaWRlO1xyXG4gICAgfVxyXG5cclxuICAgIGhvbGRlci5zbGlkZS5hcHBlbmQoaG9sZGVyLmVsKTtcclxuICB9XHJcblxyXG4gIGdldFZpZXdwb3J0Q2VudGVyUG9pbnQoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB0aGlzLnZpZXdwb3J0U2l6ZS54IC8gMixcclxuICAgICAgeTogdGhpcy52aWV3cG9ydFNpemUueSAvIDJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgc2l6ZSBvZiBhbGwgZWxlbWVudHMuXHJcbiAgICogRXhlY3V0ZWQgb24gaW5pdCBhbmQgb24gcGFnZSByZXNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZSBVcGRhdGUgc2l6ZSBldmVuIGlmIHNpemUgb2Ygdmlld3BvcnQgd2FzIG5vdCBjaGFuZ2VkLlxyXG4gICAqL1xyXG4gIHVwZGF0ZVNpemUoZm9yY2UpIHtcclxuICAgIC8vIGxldCBpdGVtO1xyXG4gICAgLy8gbGV0IGl0ZW1JbmRleDtcclxuXHJcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3lpbmcpIHtcclxuICAgICAgLy8gZXhpdCBpZiBQaG90b1N3aXBlIGlzIGNsb3NlZCBvciBjbG9zaW5nXHJcbiAgICAgIC8vICh0byBhdm9pZCBlcnJvcnMsIGFzIHJlc2l6ZSBldmVudCBtaWdodCBiZSBkZWxheWVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zdCBuZXdXaWR0aCA9IHRoaXMuc2Nyb2xsV3JhcC5jbGllbnRXaWR0aDtcclxuICAgIC8vY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5zY3JvbGxXcmFwLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICBjb25zdCBuZXdWaWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUodGhpcy5vcHRpb25zLCB0aGlzKTtcclxuXHJcbiAgICBpZiAoIWZvcmNlICYmIHBvaW50c0VxdWFsKG5ld1ZpZXdwb3J0U2l6ZSwgdGhpcy5fcHJldlZpZXdwb3J0U2l6ZSkpIHtcclxuICAgICAgLy8gRXhpdCBpZiBkaW1lbnNpb25zIHdlcmUgbm90IGNoYW5nZWRcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdGhpcy5fcHJldlZpZXdwb3J0U2l6ZS54ID0gbmV3V2lkdGg7XHJcbiAgICAvL3RoaXMuX3ByZXZWaWV3cG9ydFNpemUueSA9IG5ld0hlaWdodDtcclxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX3ByZXZWaWV3cG9ydFNpemUsIG5ld1ZpZXdwb3J0U2l6ZSk7XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaCgnYmVmb3JlUmVzaXplJyk7XHJcblxyXG4gICAgZXF1YWxpemVQb2ludHModGhpcy52aWV3cG9ydFNpemUsIHRoaXMuX3ByZXZWaWV3cG9ydFNpemUpO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQoKTtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoKCd2aWV3cG9ydFNpemUnKTtcclxuXHJcbiAgICAvLyBSZXNpemUgc2xpZGVzIG9ubHkgYWZ0ZXIgb3BlbmVyIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxyXG4gICAgLy8gYW5kIGRvbid0IHJlLWNhbGN1bGF0ZSBzaXplIG9uIGluaXRhbCBzaXplIHVwZGF0ZVxyXG4gICAgdGhpcy5tYWluU2Nyb2xsLnJlc2l6ZSh0aGlzLm9wZW5lci5pc09wZW4pO1xyXG5cclxuICAgIGlmICghdGhpcy5oYXNNb3VzZSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKGFueS1ob3ZlcjogaG92ZXIpJykubWF0Y2hlcykge1xyXG4gICAgICB0aGlzLm1vdXNlRGV0ZWN0ZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoKCdyZXNpemUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XHJcbiAgICovXHJcbiAgYXBwbHlCZ09wYWNpdHkob3BhY2l0eSkge1xyXG4gICAgdGhpcy5iZ09wYWNpdHkgPSBNYXRoLm1heChvcGFjaXR5LCAwKTtcclxuICAgIHRoaXMuYmcuc3R5bGUub3BhY2l0eSA9IFN0cmluZyh0aGlzLmJnT3BhY2l0eSAqIHRoaXMub3B0aW9ucy5iZ09wYWNpdHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciBtb3VzZSBpcyBkZXRlY3RlZFxyXG4gICAqL1xyXG4gIG1vdXNlRGV0ZWN0ZWQoKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzTW91c2UpIHtcclxuICAgICAgdGhpcy5oYXNNb3VzZSA9IHRydWU7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwc3dwLS1oYXNfbW91c2UnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhZ2UgcmVzaXplIGV2ZW50IGhhbmRsZXJcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2hhbmRsZVBhZ2VSZXNpemUoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuXHJcbiAgICAvLyBJbiBpT1Mgd2VidmlldywgaWYgZWxlbWVudCBzaXplIGRlcGVuZHMgb24gZG9jdW1lbnQgc2l6ZSxcclxuICAgIC8vIGl0J2xsIGJlIG1lYXN1cmVkIGluY29ycmVjdGx5IGluIHJlc2l6ZSBldmVudFxyXG4gICAgLy9cclxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA1OTVcclxuICAgIC8vIGh0dHBzOi8vaGFja2Vybm9vbi5jb20vb25yZXNpemUtZXZlbnQtYnJva2VuLWluLW1vYmlsZS1zYWZhcmktZDg0NjkwMjdiZjRkXHJcbiAgICBpZiAoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhZ2Ugc2Nyb2xsIG9mZnNldCBpcyB1c2VkXHJcbiAgICogdG8gZ2V0IGNvcnJlY3QgY29vcmRpbmF0ZXNcclxuICAgKiByZWxhdGl2ZSB0byBQaG90b1N3aXBlIHZpZXdwb3J0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCgpIHtcclxuICAgIHRoaXMuc2V0U2Nyb2xsT2Zmc2V0KDAsIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICovXHJcbiAgc2V0U2Nyb2xsT2Zmc2V0KHgsIHkpIHtcclxuICAgIHRoaXMub2Zmc2V0LnggPSB4O1xyXG4gICAgdGhpcy5vZmZzZXQueSA9IHk7XHJcbiAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVTY3JvbGxPZmZzZXQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBtYWluIEhUTUwgc3RydWN0dXJlIG9mIFBob3RvU3dpcGUsXHJcbiAgICogYW5kIGFkZCBpdCB0byBET01cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NyZWF0ZU1haW5TdHJ1Y3R1cmUoKSB7XHJcbiAgICAvLyByb290IERPTSBlbGVtZW50IG9mIFBob3RvU3dpcGUgKC5wc3dwKVxyXG4gICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudCgncHN3cCcpO1xyXG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XHJcblxyXG4gICAgLy8gdGVtcGxhdGUgaXMgbGVnYWN5IHByb3BcclxuICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLmVsZW1lbnQ7XHJcblxyXG4gICAgLy8gQmFja2dyb3VuZCBpcyBhZGRlZCBhcyBhIHNlcGFyYXRlIGVsZW1lbnQsXHJcbiAgICAvLyBhcyBhbmltYXRpbmcgb3BhY2l0eSBpcyBmYXN0ZXIgdGhhbiBhbmltYXRpbmcgcmdiYSgpXHJcbiAgICB0aGlzLmJnID0gY3JlYXRlRWxlbWVudCgncHN3cF9fYmcnLCBmYWxzZSwgdGhpcy5lbGVtZW50KTtcclxuICAgIHRoaXMuc2Nyb2xsV3JhcCA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX3Njcm9sbC13cmFwJywgJ3NlY3Rpb24nLCB0aGlzLmVsZW1lbnQpO1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19jb250YWluZXInLCBmYWxzZSwgdGhpcy5zY3JvbGxXcmFwKTtcclxuXHJcbiAgICAvLyBhcmlhIHBhdHRlcm46IGNhcm91c2VsXHJcbiAgICB0aGlzLnNjcm9sbFdyYXAuc2V0QXR0cmlidXRlKCdhcmlhLXJvbGVkZXNjcmlwdGlvbicsICdjYXJvdXNlbCcpO1xyXG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XHJcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Bzd3BfX2l0ZW1zJyk7XHJcblxyXG4gICAgdGhpcy5tYWluU2Nyb2xsLmFwcGVuZEhvbGRlcnMoKTtcclxuXHJcbiAgICB0aGlzLnVpID0gbmV3IFVJKHRoaXMpO1xyXG4gICAgdGhpcy51aS5pbml0KCk7XHJcblxyXG4gICAgLy8gYXBwZW5kIHRvIERPTVxyXG4gICAgKHRoaXMub3B0aW9ucy5hcHBlbmRUb0VsIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIG9mIHNtYWxsIHRodW1ibmFpbFxyXG4gICAqICAge3g6LHk6LHc6fVxyXG4gICAqXHJcbiAgICogSGVpZ2h0IGlzIG9wdGlvbmFsIChjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBsYXJnZSBpbWFnZSlcclxuICAgKi9cclxuICBnZXRUaHVtYkJvdW5kcygpIHtcclxuICAgIHJldHVybiBnZXRUaHVtYkJvdW5kcyhcclxuICAgICAgdGhpcy5jdXJySW5kZXgsXHJcbiAgICAgIHRoaXMuY3VyclNsaWRlID8gdGhpcy5jdXJyU2xpZGUuZGF0YSA6IHRoaXMuX2luaXRpYWxJdGVtRGF0YSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHRoZSBQaG90b1N3aXBlIGNhbiBoYXZlIGNvbnRpbmlvdXMgbG9vcFxyXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cclxuICAgKi9cclxuICBjYW5Mb29wKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLm9wdGlvbnMubG9vcCAmJiB0aGlzLmdldE51bUl0ZW1zKCkgPiAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZU9wdGlvbnN9IG9wdGlvbnNcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uKSwgKHVwZGF0ZTogc2xvdyknKS5tYXRjaGVzKSB7XHJcbiAgICAgIG9wdGlvbnMuc2hvd0hpZGVBbmltYXRpb25UeXBlID0gJ25vbmUnO1xyXG4gICAgICBvcHRpb25zLnpvb21BbmltYXRpb25EdXJhdGlvbiA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEB0eXBlIHtQaG90b1N3aXBlT3B0aW9uc30qL1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuICB9XHJcbn1cblxuZXhwb3J0IHsgUGhvdG9Td2lwZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG90b3N3aXBlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==